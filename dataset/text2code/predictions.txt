void function ( ScriptOrFnNode arg0 )  { collectFuncNodes ( arg0 ,  loc0 ,  null )  ;  }
public static Sha256Hash function ( File arg0 )  { Sha256Hash loc0 = null ;  try { InputStream loc1 = new FileInputStream ( arg0 )  ;  byte [  ]  loc2 = ByteStreams . toByteArray ( loc1 )  ;  loc1 . close (  )  ;  loc0 = Sha256Hash . create ( loc2 )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
String function ( boolean canCreate ,  Object arg0 )  { String loc0 = "" ;  if  ( arg0 == null )  { return loc0 ;  } ItemUID uid = new ItemUID (  )  ;  try { loc0 = uid . readObjectID ( arg0 )  ;  if  ( loc0 . isEmpty (  )  && canCreate )  { loc0 = uid . createObjectID ( arg0 )  ;  } } catch  ( Exception e )  { uid . LOG . error ( "Error in function" ,  e )  ;  } return loc0 ;  }
import org . hamcrest . Matcher ;  import org . hamcrest . number . OrderingComparison ;  public class OrderingComparison { public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 )  { return OrderingComparison .  < T > usingNaturalOrdering (  )  . greaterThan ( arg0 )  ;  } }
int function (  )  { return denom ;  }
public String function ( String arg0 ,  String image )  { builder (  )  . addText ( arg0 )  . addField ( "id" ,  id_str )   . addField ( "screen_name" ,  screen_name )  . addField ( "place_name" ,  place_name )   . addField ( "user_name" ,  user_name )  . addField ( "lng" ,  Double . toString ( lng )  )   . addField ( "lat" ,  Double . toString ( lat )  )  . addField ( "image" ,  image )   . addField ( "created_at" ,   ( created_at == null )  ? null : created_at . toString (  )  )   . setCoordinateRadius ( loc0 )  . setAuthor ( user_id ,  "unknown" )   . setCoordinate ( loc1 ,  loc2 )  . setCreatedTime ( created_at )   . setUserid ( user_id )  ;  return this . buildFieldJSON (  )  ;  }
public void function ( BundleContext arg0 )  { deregisterConnectionFactory (  )  ;  factories . remove ( config . getHost (  )  )  ;  }
void function (  )  { long arg0 = 10 ;  mTestStream . seek ( arg0 )  ;  assertEquals ( arg0 ,  mTestStream . getPosition (  )  )  ;  byte [  ]  loc0 = new byte [ 100 ]  ;  int loc1 = mTestStream . read ( loc0 ,  0 ,  loc0 . length )  ;  assertEquals ( mBlockSize - arg0 ,  mTestStream . getRemaining (  )  )  ;  }
void function ( CountDownLatch arg0 ,  WeakReference < ? >  arg1 )  { try { System . gc (  )  ;  System . runFinalization (  )  ;  arg0 . await (  )  ;  arg0 . countDown (  )  ;  arg1 . finalize (  )  ;  } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  } catch  ( Throwable t )  { throw new RuntimeException ( "Exception occurred during garbage collection: " + t . getMessage (  )  ,  t )  ;  } }
void function (  )  { MockedClass loc0 = mock ( MockedClass . class )  ;  when ( loc0 . mockedMethod ( any ( String . class )  )  )  . thenReturn ( "mockedReturnValue" )  ;  mManager = mock ( TransferManager . class )  ;  mStream = mock ( S3ADirectOutputStream . class )  ;  doReturn ( mStream )  . when ( mManager )  . upload ( any ( String . class )  ,  any ( String . class )  ,  any ( File . class )  )  ;  mStream . close (  )  ;  }
String function ( Object arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 )  { String loc0 = DocumentationManager . getComments ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  loc0 = loc0 . replace ( "/**" ,  "" )  ;  loc0 = loc0 . replace ( "*/" ,  "" )  ;  loc0 = loc0 . replaceAll ( "\\*\\s+" ,  "" )  ;  loc0 = loc0 . trim (  )  ;  return loc0 ;  }
Level function (  )  { return Level . WARNING ;  }
String function ( String arg0 )  { TSTNode loc0 = search ( root ,  arg0 ,  0 )  ;  if  ( loc0 == null || !loc0 . is_End_Of_String )  { return null ;  } else { return arg0 ;  } } char [  ]  rootChars = root . toCharArray (  )  ; 
void function (  )  { lhsscan . close (  )  ;  prodscan . close (  )  ;  if  ( rhsscan != null )  { rhsscan . close (  )  ;  } }
Map < String ,  String >  function ( String [  ]  arg0 )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  for  ( String arg : arg0 )  { String [  ]  tokens = arg . split ( "#" )  ;  loc0 . put ( tokens [ 0 ]  ,  tokens [ 1 ]  )  ;  } return loc0 ;  }
T [  ]  function ( XMLSource loc0 ,  String loc1 )  { try { T [  ]  loc2 = loc0 . getNodes ( loc1 ,  String . class )  ;  List < T >  loc3 = new ArrayList <  >  (  )  ;  for  ( T loc4 : loc2 )  { if  ( ! ( loc4 instanceof Comment )  )  { loc3 . add ( loc4 )  ;  } } return loc3 . toArray ( Arrays . copyOf ( loc2 ,  loc3 . size (  )  )  )  ;  } catch  ( Exception loc5 )  { return null ;  } }
boolean function ( Collection < Source >  arg0 )  { return runToGoal ( arg0 ,  new GoalFactory (  )  {  @ Override public Goal getGoal ( Job arg1 )  { return sourceExtension (  )  . getValidationGoal ( arg1 )  ;  } } )  ;  }
void function ( boolean arg0 )  { ContentResolver loc0 = context . getContentResolver (  )  ;  loc0 . setLocationProviderEnabled ( "gps" ,  arg0 )  ;  }
boolean function ( View arg0 )  { boolean result = false ;  if  ( Build . VERSION . SDK_INT  > = Build . VERSION_CODES . JELLY_BEAN_MR1 )  { result = arg0 . getLayoutDirection (  )  == View . LAYOUT_DIRECTION_RTL ;  } return result ;  }
Checklist function ( Object arg0 )  { Class < ? >  loc0 = arg0 . getClass (  )  ;  Checklist loc1 = lookupChecklist ( loc0 )  ;  if  ( loc1 == null && loc0 . getSuperclass (  )  != null )  { loc1 = lookupChecklist ( loc0 . getSuperclass (  )  )  ;  } return loc1 ;  }
void function (  )  { try { int loc0 = 1 ;  // replace with desired day value instance . setDay ( loc0 )  ;  } catch  ( Exception loc1 )  { fail ( "Exception occurred: " + loc1 . getMessage (  )  )  ;  } }
int function ( int arg0 ,  int arg1 )  { int loc0 = 0 ;  for  ( int loc1 = tiles . get ( arg0 )  . size - 1 ;  loc1  > = 0 ;  loc1 --  )  { if  ( tiles . get ( arg0 )  . get ( loc1 )  . get ( arg1 )  == null )  { loc0 = loc1 ;  } else { break ;  } } return loc0 ;  }
public static Matrix function ( Matrix arg0 )  { Matrix loc0 = transpose ( arg0 )  ;  Matrix loc1 = cofactor ( loc0 )  ;  double loc2 = determinant ( loc0 )  ;  double loc3 = 1 . 0 / loc2 ;  Matrix loc4 = multiplyByConstant ( loc1 ,  loc3 )  ;  return loc4 ;  } Note: Since the original code was not provided ,  I assumed the existence of the methods "multiplyByConstant (  ) " and "transpose (  ) " ,  as they were used in the implementation . 
public String function (  )  { String loc0 = thisExitStatus . getExitCode (  )  ;  List < JobExitStatus >  loc1 = getPartialFailureCodes (  )  ;  String loc2 = "" ;  if  ( loc1 != null && !loc1 . isEmpty (  )  )  { for  ( JobExitStatus loc3 : loc1 )  { loc2 += loc3 . getExitCode (  )  + " ; " ;  } } return loc0 + " - " + getExitDescription (  )  + " - Partial Failure Codes: " + loc2 ;  }
boolean function ( Element arg0 )  { return this . nsh . isHover ( arg0 )  ;  }
public List < AttributeStatementProvider >  function (  )  { List < AttributeStatementProvider >  attributeStatementProviders = new ArrayList <  >  (  )  ;  try { attributeStatementProviders = attributeStatementProviders ;  } catch  ( Exception e )  { LOG . error ( "Error getting attribute statement providers" ,  e )  ;  } return attributeStatementProviders ;  }
void function (  )  { Array < Asset >  loc0 = getAssets (  )  ;  unload ( loc0 )  ;  }
public ProjectModel function ( UserModel arg0 )  { List < ProjectModel >  loc0 = getProjectModels ( arg0 ,  true )  ;  return loc0 . isEmpty (  )  ? null : loc0 . get ( 0 )  ;  }
String function ( String arg0 )  { int loc0 = Integer . parseInt ( arg0 ,  16 )  ;  int loc1 =  ( loc0  >  >  16 )  & 0xFF ;  int loc2 =  ( loc0  >  >  8 )  & 0xFF ;  int loc3 = loc0 & 0xFF ;  String loc4 = getClosestNamedColor ( loc1 ,  loc2 ,  loc3 )  ;  return loc4 ;  }
String function (  )  { String loc0 = getSuffixFromType (  )  ;  return String . format ( "%s . %s . %s . %s%s" ,  getSchema (  )  ,  getType (  )  ,  getName (  )  ,  getClass (  )  . getSimpleName (  )  ,  loc0 )  ;  }
int function (  )  { try { return port ;  } catch  ( Exception e )  { } return 0 ;  // default value if exception occurs }
Set < String >  function ( Jedis jedis )  { Set < String >  urlSetKeys = new HashSet <  >  (  )  ;  try { String pattern = "*urlSet:*" ;  urlSetKeys = jedis . keys ( pattern )  ;  } catch  ( Exception e )  { System . err . println ( "Error getting URLSet keys: " + e . getMessage (  )  )  ;  } return urlSetKeys ;  }
void function (  )  { mBlocksToMoveIn . clear (  )  ;  mBlocksToMoveOut . clear (  )  ;  }
UserSubject function (  )  { return subject ;  }
int function ( boolean arg0 )  { char type = getType (  )  ;  if  ( type == 'x' )  { return 1 ;  } else if  ( type == 't' )  { checkType ( 't' ,  true )  ;  String loc0 = format . substring ( formatOff ,  formatOff + formatRepeatCount )  ;  formatOff += formatRepeatCount ;  try { return Integer . parseInt ( loc0 )  ;  } catch  ( NumberFormatException e )  { throw new RuntimeException ( "Failed to parse repeat count: " + loc0 ,  e )  ;  } } else { return getIntFromFormat ( arg0 )  ;  } }
String function ( TestResultDetailsDTO arg0 )  { String loc0 = arg0 . getErrorMsg (  )  ;  return loc0 ;  }
boolean function ( String arg0 )  { return _all . containsKey ( arg0 )  ;  }
String function ( Node arg0 )  { StringBuilder result = new StringBuilder (  )  ;  NodeList children = arg0 . getChildNodes (  )  ;  int numChildren = children . getLength (  )  ;  for  ( int i = 0 ;  i  <  numChildren ;  i ++  )  { Node child = children . item ( i )  ;  if  ( child instanceof Text || child instanceof CDATASection )  { result . append ( child . getNodeValue (  )  )  ;  } } return result . toString (  )  ;  }
public static void function ( Object arg0 ,  Object arg1 )  { String loc0 = "marshal . registry" ;  String loc1 =  ( String )  System . getProperty ( loc0 )  ;  MarshalRegistry loc2 = null ;  if  ( loc1 != null )  { loc2 =  ( MarshalRegistry )  loc1 ;  } else { loc2 = new MarshalRegistry (  )  ;  System . setProperty ( loc0 ,  loc2 )  ;  } loc2 . setProperty ( arg0 ,  arg1 )  ;  }
List < Object >  function ( Object arg0 ,  Object arg1 )  { List < Object >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 . add ( arg0 )  ;  loc0 . add ( arg1 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( ParametersMetaData arg0 )  { try { setParametersMetaData ( arg0 )  ;  } catch  ( Exception e )  { } }
ArrayList < String >  function (  )  { ArrayList < String >  details = new ArrayList <  >  (  )  ;  String loc0 = "Our details tab ( s )  .  Proof of concept only . " ;  try { TestPanel testPanel = TestPanel . getInstance (  )  ;  details . add ( loc0 )  ;  } catch  ( Exception e )  { } return details ;  }
void function ( String arg0 ,  String arg1 ,  byte [  ]  arg2 ,  XMLStreamWriter arg3 )  { try { arg3 . writeStartElement ( arg0 )  ;  arg3 . writeCharacters ( new String ( arg2 )  )  ;  arg3 . writeEndElement (  )  ;  } catch  ( XMLStreamException e )  { System . err . println ( "Error writing XML: " + e . getMessage (  )  )  ;  } }
String function ( PCLDataUnitEntity arg0 )  { String loc0 = arg0 . isActive ;  return loc0 ;  }
private Object function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { Object loc0 = null ;  try { loc0 = CommonUtils . createNewClassInstance ( Configuration . getClass ( "DataServer" )  )  ;   (  ( DataServer )  loc0 )  . getPort (  )  ;   (  ( DataServer )  loc0 )  . isClosed (  )  ;   (  ( DataServer )  loc0 )  . getBindHost (  )  ;  } catch  ( Throwable loc1 )  { Throwables . propagate ( loc1 )  ;  } return loc0 ;  }
ECKey function ( List < ECKey >  arg0 )  { ECKey loc0 = null ;  for  ( ECKey key : arg0 )  { try { loc0 = key . getPrivKey (  )  ;  } catch  ( ECKey . MissingPrivateKeyException e )  { continue ;  } break ;  } return loc0 ;  }
void function (  )  { destroyInstrumentationService (  )  ;  } private void destroyInstrumentationService (  )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  loc0 . put ( JVM_INSTRUMENTATION_GROUP ,  "" )  ;  log . debug ( "Unregistering JVM instrumentation . " )  ;  instrumentation . removeGroup ( loc0 )  ;  log . debug ( "Destroying instrumentation service . " )  ;  instrumentation . destroy (  )  ;  instrumentation = null ;  }
void function ( long arg0 )  { this . maximumKeySize = arg0 ;  }
String function ( String arg0 )  { if  ( ts . hasField ( arg0 )  )  { return ts . getVal ( arg0 )  ;  } else { return s . getVal ( arg0 )  ;  } }
public int function ( int arg0 )  { byte [  ]  loc0 = new byte [ 4 ]  ;  loc0 [ 0 ]  =  ( byte )   ( arg0  >  >  24 & 0xff )  ;  loc0 [ 1 ]  =  ( byte )   ( arg0  >  >  16 & 0xff )  ;  loc0 [ 2 ]  =  ( byte )   ( arg0  >  >  8 & 0xff )  ;  loc0 [ 3 ]  =  ( byte )   ( arg0 & 0xff )  ;  return ByteBuffer . wrap ( loc0 )  . getInt (  )  ;  }
long function ( Coin arg0 )  { try { return arg0 . longValue (  )  ;  } catch  ( Exception loc0 )  { return 0 ;  } }
public void function ( MenuItemWrapper menuItemWrapper ,  int arg0 )  { menuItemWrapper . mMenuItem . setActionView ( arg0 )  ;  }
public void function ( ServerSession arg0 ,  ServerMessage arg1 )  { notificationController . deletePersistentNotification ( null ,  mockServerMessage )  ;  }
void function ( double seconds )  { try { if  ( seconds  <  0 || seconds  > = 60 )  { throw new IllegalArgumentException ( "srini_string" )  ;  } this . seconds = seconds ;  } catch  ( IllegalArgumentException e )  { System . err . println ( e . getMessage (  )  )  ;  } }
void function ( ServiceID serviceID )  { try { setServiceID ( serviceID )  ;  } catch  ( Exception e )  { } }
public int function ( int arg0 ,  int arg1 ,  int arg2 ) { int loc0 = 32 + StoredBlock . COMPACT_SERIALIZED_SIZE ;  int loc1 = arg1 ;  int loc2 = arg2 ;  return loc0 * loc1 + loc2 ;  } This method calculates the size in bytes of the file used to store the chain with the current parameters ,  using the formula: size =  ( 32 + StoredBlock . COMPACT_SERIALIZED_SIZE )  * numHeaders + FILE_PROLOGUE_BYTES .  The method takes three integer arguments corresponding to the values of RECORD_SIZE ,  numHeaders ,  and FILE_PROLOGUE_BYTES respectively ,  and returns the calculated size .  No exception handling is performed in this method . 
T function (  )  { return mPayload ;  }
String function (  )  { String loc0 = DateTime . formatUTCtoSqlUTC ( this . addedDate )  ;  return loc0 ;  }
List < DirectedAcyclicGraphNode < T >  >  function ( DirectedAcyclicGraphNode < T >  arg0 )  { List < DirectedAcyclicGraphNode < T >  >  mChildren = new ArrayList <  >  (  )  ;  try { mChildren = arg0 . mChildren ;  } catch  ( NullPointerException e )  { System . out . println ( "Error: Node has no children . " )  ;  } return mChildren ;  }
View function ( RecyclerView arg0 ,  HeaderPositionCalculator arg1 )  { int childCount = arg0 . getChildCount (  )  ;  HeaderProvider loc0 = arg1 . mHeaderProvider ;  OrientationProvider loc1 = arg1 . mOrientationProvider ;  StickyRecyclerHeadersAdapter loc2 = arg1 . mAdapter ;  DimensionCalculator loc3 = arg1 . mDimensionCalculator ;  for  ( int i = 0 ;  i  <  childCount ;  i ++  )  { View child = arg0 . getChildAt ( i )  ;  if  ( loc2 . getHeaderId ( i )  == StickyRecyclerHeadersAdapter . NO_HEADER_ID )  { if  ( !arg1 . itemIsObscuredByHeader ( arg0 ,  child ,  loc0 . getHeader ( arg0 ,  i )  ,  loc1 . getOrientation ( arg0 )  ,  loc3 )  )  { return child ;  } } } return null ;  }
void function ( List < TestResultDetailsDTO >  arg0 )  { regTestResultDetailsLst = arg0 ;  }
public long function ( RegPCLTestResultEntity arg0 )  { long loc0 = -1 ;  try { loc0 = arg0 . getTestId (  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Error while getting test ID: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
void function (  )  { Time loc0 = new Time ( 0 )  ;  Time loc1 = new Time ( 0 )  ;  loc0 . testSetTime (  )  ;  loc0 . toDate (  )  ;  loc1 . setTime ( loc0 )  ;  loc1 . toDate (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  assertEquals ( loc0 . getTime (  )  ,  loc1 . getTime (  )  )  ;  }
public void function ( BigDecimal arg0 )  { try { this . feedConfigId = arg0 ;  } catch  ( Exception loc0 )  { } }
public String function ( String arg0 )  { ImageWriter loc0 = lookupImageWriterForFormat ( DEFAULT_IMAGE_FORMAT )  ;  ImageWriteParam loc1 = getImageWriteParameters ( loc0 )  ;  loc1 . setCompressionType ( arg0 )  ;  return writeCompressionType ;  }
public boolean function ( Range < C >  loc0 )  { return encloses ( loc0 )  ;  }
void function ( Map < String ,  Object >  arg0 )  { try { vars . putAll ( arg0 )  ;  } catch  ( NullPointerException e )  { } catch  ( IllegalArgumentException e )  { } }
public boolean function ( int arg0 ,  int arg1 ,  ByteBuffer arg2 )  { ensureCapacity ( arg0 )  ;  expandCapacity ( arg1 )  ;  setOutputMode (  )  ;  ByteBuffer loc0 = this . buffer ;  expand (  )  ;  ByteBuffer loc1 = this . buffer ;  clear (  )  ;  int loc2 = loc1 . capacity (  )  - loc1 . position (  )  ;  int loc3 = loc0 == null ? 0 : loc0 . capacity (  )  - loc0 . position (  )  ;  return loc2  >  loc3 ;  }
String function ( int arg0 ,  String arg1 ,  int arg2 ,  int arg3 ,  String arg4 )  { StringBuilder sb = new StringBuilder (  )  ;  sb . append ( "SETSTRING " )  ;  sb . append ( arg3 )  ;  sb . append ( " " )  ;  sb . append ( arg1 )  ;  sb . append ( " " )  ;  sb . append ( arg2 )  ;  sb . append ( " " )  ;  sb . append ( blk . getFilename (  )  )  ;  sb . append ( " " )  ;  sb . append ( offset )  ;  sb . append ( " " )  ;  sb . append ( oldval )  ;  sb . append ( " " )  ;  sb . append ( newval )  ;  return sb . toString (  )  ;  }
public static void function ( DataFlowHandler dataFlowHandler ,  int line ,  List < DataFlowNode >  dataFlow ,  Object arg0 )  { try { DataFlowNode node = dataFlowHandler . createDataFlowNode ( line ,  arg0 )  ;  dataFlow . add ( node )  ;  } catch  ( Exception e )  { Structure . LOGGER . severe ( "Error creating DataFlowNode: " + e . getMessage (  )  )  ;  } }
public User function (  )  { try { if  ( !SecurityUtils . isAuthenticationEnabled (  )  )  { throw new IOException ( ExceptionMessage . AUTHENTICATION_IS_NOT_ENABLED . getMessage (  )  )  ;  } return sUserThreadLocal . get (  )  ;  } catch  ( IOException e )  { return null ;  } }
public void function ( String arg0 )  { try { if  ( !selectedRecipients . contains ( arg0 )  )  { selectedRecipients . add ( arg0 )  ;  } } catch  ( Exception e )  { System . out . println ( "Error: Failed to add recipient to the required recipients list . " )  ;  e . printStackTrace (  )  ;  } }
File function ( String arg0 )  { File loc0 = new File ( arg0 )  ;  String loc1 = loc0 . getRoot (  )  . getPath (  )  ;  ExpectedException loc2 = ExpectedException . none (  )  ;  try { FileUtils . delete ( arg0 )  ;  fail ( "Expected an exception when trying to delete a non-existent file . " )  ;  } catch  ( IOException e )  { loc2 . expect ( FileNotFoundException . class )  ;  } return loc0 ;  }
boolean function ( String arg0 ,  OperationSigMask arg1 )  { if  ( arg1 . covers ( OperationSignature loc0 )  )  { Set < OperationSignature >  keys = operations . keySet (  )  ;  Map < String ,  OperationStats >  operationStats = operations . get ( OperationSignature loc0 )  ;  if  ( operations . containsKey ( OperationSignature loc0 )  )  { return true ;  } } return false ;  }
boolean function ( Collection < UserModel >  arg0 )  { return userService . updateUserModels ( arg0 )  ;  }
void function ( Object arg0 ,  Object arg1 )  { try { this . config . getServletContext (  )  . log ( this . config . getFilterName (  )  + "srini_string" + arg0 ,  arg1 )  ;  } catch  ( Throwable loc0 )  { this . config . getServletContext (  )  . log ( "Exception occurred in ConcatFilter" ,  loc0 )  ;  } }
import javax . servlet . http . HttpServletRequest ;  import javax . servlet . http . HttpServletResponse ;  import org . slf4j . Logger ;  import org . slf4j . LoggerFactory ;  import java . io . IOException ;  public class JsonControllerUtils { private static final Logger LOG = LoggerFactory . getLogger ( JsonControllerUtils . class )  ;  public static void function ( HttpServletRequest arg0 ,  HttpServletResponse arg1 )  { try { writeResponse ( arg0 ,  arg1 ,  "" )  ;  } catch  ( IOException e )  { LOG . error ( "Failed to write empty response" ,  e )  ;  } } private static void writeResponse ( HttpServletRequest request ,  HttpServletResponse response ,  String content )  throws IOException { response . setContentType ( "application/json" )  ;  response . setCharacterEncoding ( "UTF-8" )  ;  response . getWriter (  )  . write ( content )  ;  response . flushBuffer (  )  ;  } }
void function ( int arg0 ,  ProgressMonitor progressMonitor )  { progressMonitor . curValue = arg0 ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = function (  )  ;  } catch  ( Exception loc1 )  { m_log . error ( "Error accessing JSON string" ,  loc1 )  ;  } return m_escapedJson ;  }
NodeIterator function ( NodeTester arg0 )  { NodeIterator loc0 = documentTraversal . createNodeIterator ( rootNode ,  NodeFilter . SHOW_ALL ,  arg0 ,  false )  ;  Node loc1 ;  while  (  ( loc1 = loc0 . nextNode (  )  )  != null )  { if  ( !arg0 . testNode ( loc1 )  )  { loc0 . detach (  )  ;  return null ;  } } loc0 . detach (  )  ;  return loc0 ;  }
BlockStoreContext function ( InetSocketAddress arg0 )  { BlockStoreContext loc0 = CACHED_CONTEXTS . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new BlockStoreContext ( mBlockMasterClientPool ,  mHasLocalWorker )  ;  CACHED_CONTEXTS . put ( arg0 ,  loc0 )  ;  } return loc0 ;  }
void function ( String arg0 ,  String arg1 ,  float arg2 )  { FSImageWriter loc0 = new FSImageWriter (  )  ;  loc0 . setWriteCompressionMode ( 2 )  ;  loc0 . setWriteCompressionType ( arg0 )  ;  loc0 . setWriteCompressionQuality ( arg2 )  ;  } Note: The method sets the compression mode to 2 which corresponds to the JPEG compression mode . 
String function ( String arg0 ,  String arg1 )  { String loc0 = conditionallyPrependHttp ( arg0 )  ;  String loc1 = getHost ( loc0 )  + getPath ( loc0 )  ;  String loc2 = createQueryString ( getKeyList ( getParameterMap ( getQuery ( loc0 )  )  )  ,  getParameterMap ( getQuery ( loc0 )  )  )  ;  String loc3 = removePath ( loc2 )  ;  return OMA_REDIRECT_LINK + SITE_PARAM + "=" + loc1 + loc3 ;  }
void function ( Map < String ,  ThreadingParameters >  arg0 ,  String arg1 )  { try { threadingParametersMap . putAll ( arg0 )  ;  } catch  ( Exception loc0 )  { LOG . warn ( "Error setting ThreadingParameters for JettyHTTPServerEngine on port " + arg1 ,  loc0 )  ;  } }
public void function ( Language arg0 ,  CodeGenerator arg1 )  { if  ( generators . containsKey ( arg0 )  )  { generators . remove ( arg0 )  ;  } generators . put ( arg0 ,  arg1 )  ;  LOG . debug ( "Generator registered for language: " + arg0 . getName (  )  )  ;  fireEvent ( "GeneratorRegistered" ,  arg0 )  ;  }
public void function ( String arg0 ,  Object arg1 )  { try { setVariable ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { } }
public void function ( StoredTransactionOutput output )  { try { int loc0 = output . index ;  output . index = -1 ;  System . out . println ( "Successfully removed index " + loc0 + " from the output . " )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { if  ( System . nanoTime (  )  - bulletTime  < = BULLET_INTERVAL && bullets . size (  )   <  MAX_BULLETS )  { float bulletXPos = xPos ;  float bulletYPos = yPos + walkbias - 0 . 2f ;  float bulletZPos = zPos ;  float bulletHeading = heading ;  bullets . add ( new Bullet ( bulletXPos ,  bulletYPos ,  bulletZPos ,  bulletHeading )  )  ;  } }
public static GetOfferDetailsResponse . Return . DetailOfferData . OfferDisplay function (  )  { GetOfferDetailsResponse loc0 = createGetOfferDetailsResponse (  )  ;  GetOfferDetailsResponse . Return loc1 = loc0 . getReturn (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData loc2 = loc1 . getDetailOfferData (  )  ;  return loc2 . getOfferDisplay (  )  ;  }
public static Long function ( RMConfiguration rmCfg )  { Long loc0 = rmCfg == null ? null : rmCfg . getAcknowledgementInterval (  )  ;  if  ( loc0 == null )  { return null ;  } try { return loc0 . longValue (  )  ;  } catch  ( NullPointerException | NumberFormatException e )  { return null ;  } }
void function (  )  { server . stopAsync (  )  ;  server . awaitTerminated (  )  ;  }
String function ( String arg0 ,  String arg1 ,  Position pos ,  int level )  { StringBuffer sb = new StringBuffer ( arg0 )  ;  sb . append ( arg1 )  ;  ErrorQueue eq = getQueue (  )  ;  if  ( should_report ( debug ,  level )  )  { ErrorInfo info = new ErrorInfo ( debug ,  pos ,  sb . toString (  )  )  ;  eq . enqueue ( info )  ;  } return sb . toString (  )  ;  }
JAXBElement < Access >  function ( String arg0 )  { Access loc0 = new Access (  )  ;  JAXBElement < Access >  loc1 = new JAXBElement < Access >  ( _Access_QNAME ,  Access . class ,  null ,  loc0 )  ;  return loc1 ;  }
void function ( String arg0 )  { failedAttributeName = arg0 ;  }
List < String >  function ( String arg0 )  { List < String >  loc0 = CommonUtils . getUnixGroups ( arg0 )  ;  ArrayList < String >  loc1 = new ArrayList <  >  ( loc0 )  ;  LinkedHashSet < String >  loc2 = new LinkedHashSet <  >  ( loc1 )  ;  return new ArrayList <  >  ( loc2 )  ;  }
void function (  )  { try { Socket loc0 = clientEndpoint . getSocket (  )  ;  loc0 . getOutputStream (  )  . flush (  )  ;  } catch  ( IOException loc1 )  { logger . error ( "Failed to flush data" ,  loc1 )  ;  } }
void function ( String arg0 ,  String arg1 )  { MetadataEditorCompat loc0 = editMetadata ( true )  ;  loc0 . putString ( arg0 ,  arg1 )  ;  }
void function ( int arg0 ,  String arg1 )  { GeneralMotorCon ourInstance = GeneralMotorCon . getInstance (  )  ;  ourInstance . appendToConsole ( arg1 )  ;  ourInstance . landing (  )  ;  ourInstance . doFor ( arg0 )  ;  }
public Optional < GroupConfiguration >  function ( String arg0 ,  int arg1 ,  Map < String , String >  arg2 ,  int arg3 ,  int arg4 )  { try { GroupConfiguration . Builder builder = new GroupConfiguration . Builder (  )  ;  builder . name ( arg0 )  . cooldown ( arg1 )  . metadata ( arg2 )  . maxEntities ( arg3 )  . minEntities ( arg4 )  ;  return Optional . of ( builder . build (  )  )  ;  } catch  ( Exception e )  { return Optional . empty (  )  ;  } }
void function (  )  { RMCParser rmc = new RMCParser (  )  ;  rmc . setData ( EXAMPLE )  ;  rmc . setVariation ( 6 . 1 )  ;  assertEquals ( 6 . 1 ,  rmc . getVariation (  )  ,  0 . 1 )  ;  rmc . setDirectionOfVariation ( 'E' )  ;  assertEquals ( 'E' ,  rmc . getDirectionOfVariation (  )  )  ;  assertTrue ( rmc . isValid (  )  )  ;  }
public static String function ( String arg0 )  { String loc0 = "" ;  try { loc0 = StringEscapeUtils . escapeJavaScript ( arg0 )  ;  loc0 = loc0 . replaceAll ( " ( ?i ) javascript" ,  "" )  ;  loc0 = loc0 . replaceAll ( " ( ?s ) /\\* . *?\\*/" ,  "" )  ;  } catch  ( Exception e )  { } return loc0 ;  }
String function ( TokenReference obj )  { String loc0 = obj . getWsseValueType (  )  ;  return loc0 ;  }
public String function ( String arg0 ,  String arg1 ,  int arg2 ,  String arg3 ,  String arg4 ,  ArrayList < String >  arg5 ,  double arg6 ,  String arg7 ,  String arg8 ,  String arg9 ,  double arg10 ,  Date arg11 )  { DAOWrapper loc0 = new DAOWrapper (  )  ;  try { loc0 . setIDstr ( arg0 )  ;  loc0 . setAuthor ( arg1 ,  "unknown" )  ;  loc0 . setCoordinateRadius ( arg2 )  ;  loc0 . addText ( arg3 )  ;  loc0 . setAuthor ( arg4 ,  "unknown" )  ;  loc0 . setCoordinate ( arg6 ,  arg6 )  ;  loc0 . setPlaceName ( arg7 )  ;  loc0 . setImage ( arg8 )  ;  loc0 . setAuthor ( arg9 ,  "unknown" )  ;  loc0 . setCoordinate ( arg10 ,  arg10 )  ;  loc0 . setCreatedTime ( arg11 )  ;  loc0 . persist (  )  ;  } catch  ( Exception loc1 )  { return "Error: " + loc1 . getMessage (  )  ;  } return loc0 . buildFieldJSON (  )  ;  }
void function ( Object arg0 ,  Object arg1 )  { try { LOGGER . debug ( "Getting the resources . " )  ;  loadProperties (  )  ;  setResources ( Arrays . asList (  ( Resource )  arg0 ,   ( Resource )  arg1 )  )  ;  } catch  ( Exception loc0 )  { LOGGER . error ( "Error occurred while getting the resources: " + loc0 . getMessage (  )  )  ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = arg1 ;  try { boolean exists = getString ( arg0 ,  loc0 )  != null ;  return String . valueOf ( exists )  ;  } catch  ( Exception e )  { } return null ;  }
public static ResourceTypeHandler function ( String arg0 )  { try { return ResourceTypeHandler . valueOf ( arg0 )  ;  } catch  ( IllegalArgumentException loc0 )  { return null ;  } }
void function ( Notation arg0 ,  Node arg1 )  { try { unhandled ( arg1 )  ;  } catch  ( Exception e )  { } }
public long function (  )  { long loc0 = 0 ;  long loc1 = 0 ;  try { loc0 = total . get (  )  ;  loc1 = totalElapsed . get (  )  ;  if  ( loc0 == 0 )  { return 0 ;  } return loc1 / loc0 ;  } catch  ( Exception e )  { return 0 ;  } }
void function (  )  { try { setValue ( "" )  ;  setErrorLevel ( 0 )  ;  setWarning ( false )  ;  setKO ( false )  ;  } catch  ( Exception e )  { } }
double arg0 = 45 . 0 ;  RMBTest rmbTest = new RMBTest (  )  ;  rmbTest . setUp (  )  ;  try { rmbTest . rmb . setBearing ( arg0 )  ;  assertTrue ( rmbTest . rmb . getBearing (  )  == arg0 )  ;  } catch  ( IllegalArgumentException e )  { String loc0 = e . getMessage (  )  ;  assertTrue ( loc0 . contains ( "Invalid bearing" )  )  ;  }
public String function ( long arg0 )  { try { AlluxioURI loc0 = mFileSystemMaster . getPath ( arg0 )  ;  return loc0 . toString (  )  ;  } catch  ( Exception e )  { } return null ;  }
public static int function ( byte [  ]  arg0 )  { int loc0 = Arrays . hashCode ( arg0 )  ;  int loc1 = loc0 & 0xFF ;  int loc2 =  ( loc0  >  >  8 )  & 0xFF ;  int loc3 =  ( loc0  >  >  16 )  & 0xFF ;  int loc4 =  ( loc0  >  >  24 )  & 0xFF ;  int loc5 = loc1  <  <  24 | loc2  <  <  16 | loc3  <  <  8 | loc4 ;  return loc5 ;  }
byte function ( Constant arg0 )  { byte loc0 = arg0 . tag ;  return loc0 ;  } Note: This is a concise implementation of the method that simply returns the tag of the given Constant object without any exception handling or additional logic . 
public Block getHeader (  )  { Block loc0 = this . header . cloneAsHeader (  )  ;  loc0 . clearTransactions (  )  ;  return loc0 ;  }
Map < String ,  String >  function (  )  { Map < String ,  String >  loc0 = new HashMap < String ,  String >  (  )  ;  loc0 . putAll ( config . getAdvancedSettings (  )  )  ;  return loc0 ;  }
Difference function (  )  { Difference loc0 = this . additionDifference ;  return loc0 ;  }
public String function (  )  { String loc0 = "" ;  try { loc0 = version ;  } catch  ( Exception e )  { LOG . error ( "Error accessing language version: " + e . getMessage (  )  )  ;  } return loc0 ;  }
void function (  )  { int loc0 = real_stack . elementAt ( real_next )  . parse_state (  )  ;  vstack . push ( loc0 )  ;  int loc1 = real_stack . size (  )  ;  real_next = loc1 - 1 ;  }
void function ( ListenableFuture < ? >  arg0 ,  Object arg1 ,  int arg2 )  { CountDownLatch loc0 = new CountDownLatch ( 1 )  ;  MockFutureListener loc1 = new MockFutureListener ( arg0 ,  loc0 )  ;  arg0 . addListener ( loc1 ,  MoreExecutors . directExecutor (  )  )  ;  try { Assert . assertTrue ( loc0 . await ( arg2 ,  TimeUnit . SECONDS )  )  ;  if  ( arg1 instanceof Throwable )  { loc1 . assertException (  ( Throwable )  arg1 )  ;  } else { Assert . assertEquals ( arg1 ,  arg0 . get (  )  )  ;  } } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  throw new AssertionError ( e )  ;  } catch  ( ExecutionException e )  { throw new AssertionError ( e . getCause (  )  )  ;  } }
void function ( int arg0 )  { try { this . gisticID = arg0 ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while setting the Gistic internal ID: " + e . getMessage (  )  )  ;  } }
long function ( AtomicLongMap < Long >  map ,  Long key ,  long delta )  { try { return map . accumulateAndGet ( key ,  delta ,  Long::sum )  ;  } catch  ( Exception e )  { return 0L ;  // or throw a new exception } }
public static void function ( String [  ]  arg0 )  { try { SshExample loc0 = new SshExample (  )  ;  loc0 . connected ( new SshConnectedEvent (  )  )  ;  loc0 . disconnected ( new SshDisconnectedEvent (  )  )  ;  loc0 . dataReceived ( new SshDataReceivedEvent (  )  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Exception occurred: " + loc1 . getMessage (  )  )  ;  } }
void function ( AbstractPlugin arg0 )  { arg0 . removePluginObserver (  )  ;  singleton . allPlugins . remove ( arg0 )  ;  }
List < String >  function ( String arg0 )  { List < String >  loc0 ;  try { loc0 = Lists . newArrayList (  )  ;  } catch  ( Exception e )  { loc0 = Collections . emptyList (  )  ;  } return loc0 ;  }
public void function ( ServiceID arg0 )  { try { bind ( arg0 )  ;  } catch  ( IOException loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function (  )  { testGetResponseString (  )  ;  System . out . println ( "Test of getResponseStringCsv method ,  of class LogEntryRequest . " )  ;  String loc0 = "srini_string" ;  String loc1 = instance . getResponseStringCsv (  )  ;  assertEquals ( arg0 ,  loc1 )  ;  }
public static TextButton function ( Label arg0 ,  float arg1 ,  float arg2 ,  float arg3 ,  float arg4 )  { Label loc0 = defineLabel ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 )  ;  loc0 . setStyle ( "default" )  ;  loc0 . setFont ( getFont (  )  )  ;  loc0 . setColor ( Color . BLACK )  ;  TextButton loc1 = new TextButton ( loc0 . getText (  )  ,  "default" ,  "default" )  ;  loc1 . setX ( loc0 . getX (  )  )  ;  loc1 . setY ( loc0 . getY (  )  )  ;  loc1 . setWidth ( loc0 . getWidth (  )  )  ;  loc1 . setHeight ( loc0 . getHeight (  )  )  ;  loc1 . setLabel ( loc0 )  ;  return loc1 ;  }
Sha256Hash function (  )  { byte [  ]  concatenatedData = new byte [ 0 ]  ;  for  ( StoredBlock storedBlock : checkpoints . values (  )  )  { byte [  ]  checkpointBytes = storedBlock . getHeader (  )  . bitcoinSerialize (  )  ;  concatenatedData = Arrays . copyOf ( concatenatedData ,  concatenatedData . length + checkpointBytes . length )  ;  System . arraycopy ( checkpointBytes ,  0 ,  concatenatedData ,  concatenatedData . length - checkpointBytes . length ,  checkpointBytes . length )  ;  } return Sha256Hash . hash ( concatenatedData )  ;  }
public void function ( Object value ,  boolean signed )  { checkType ( value )  ;  packLong (  ( long ) value ,  signed )  ;  } private void checkType ( Object obj )  { if  ( obj instanceof Byte )  { addByte (  ( byte ) obj )  ;  } else if  ( obj instanceof Short )  { addShort (  ( short ) obj )  ;  } else if  ( obj instanceof Integer )  { addInt (  ( int ) obj )  ;  } else if  ( obj instanceof Long )  { addLong (  ( long ) obj )  ;  } else if  ( obj instanceof byte [  ]  )  { addByteArray (  ( byte [  ]  ) obj )  ;  } else if  ( obj instanceof String )  { addString (  ( String ) obj )  ;  } else { throw new IllegalArgumentException ( "Unsupported type: " + obj . getClass (  )  . getName (  )  )  ;  } } private void packLong ( long x ,  boolean signed )  { if  ( x  > = 0 )  { packLongUnsigned ( x )  ;  } else if  ( signed )  { packLongSigned ( x )  ;  } else { throw new IllegalArgumentException ( "Unsigned value out of range: " + x )  ;  } } private void packLongSigned ( long x )  { packLongUnsigned (  ( x  <  <  1 )  ^  ( x  >  >  63 )  )  ;  } private void packLongUnsigned ( long x )  { while  (  ( x & ~0x7FL )  != 0L )  { addByte (  ( byte )  (  ( x & 0x7F )  | 0x80 )  )  ;  x  >  >  > = 7 ;  } addByte (  ( byte ) x )  ;  }
void function (  )  { HDMTest hdmTest = new HDMTest (  )  ;  hdmTest . setUp (  )  ;  hdmTest . testSetHeadingTooHigh (  )  ;  assertFalse ( hdmTest . hdm . isTrue (  )  )  ;  hdmTest . testSetHeading (  )  ;  assertTrue ( hdmTest . hdm . isTrue (  )  )  ;  hdmTest . testGetHeading (  )  ;  hdmTest . testSetNegativeHeading (  )  ;  assertFalse ( hdmTest . hdm . isTrue (  )  )  ;  hdmTest . testConstructor (  )  ;  assertTrue ( hdmTest . hdm . isTrue (  )  )  ;  }
void function ( Signature . Visibility .  .  .  arg0 )  { visMask . removeAll ( Arrays . asList ( arg0 )  )  ;  }
String function ( String arg0 )  { System . out . print ( arg0 )  ;  String loc0 = scanner . nextLine (  )  ;  return loc0 ;  }
public static Options function (  )  { Options options = new Options (  )  ;  try { Option sharedOption = Option . builder ( "shared" )  . required ( false )  . hasArg ( false )  . desc ( "shared" )  . build (  )  ;  FileSystem fileSystem = null ;  Option recursiveOption = Option . builder ( "R" )  . required ( false )  . hasArg ( false )  . desc ( "recursive" )  . build (  )  ;  Option forceOption = Option . builder ( "f" )  . required ( false )  . hasArg ( false )  . desc ( "force" )  . build (  )  ;  Option propertyFileOption = Option . builder ( "P" )  . required ( false )  . numberOfArgs ( 1 )  . desc ( "properties file name" )  . build (  )  ;  Option readOnlyOption = Option . builder ( "readonly" )  . required ( false )  . hasArg ( false )  . desc ( "readonly" )  . build (  )  ;  options . addOption ( sharedOption )   . addOption ( recursiveOption )   . addOption ( forceOption )   . addOption ( propertyFileOption )   . addOption ( readOnlyOption )  ;  } catch  ( Exception e )  { } return options ;  }
void function (  )  { double arg0 = 123 . 45 ;  VHWTest testObject = new VHWTest (  )  ;  testObject . setUp (  )  ;  try { testObject . vhw . setHeading ( arg0 )  ;  double loc0 = testObject . vhw . getHeading (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 01 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
Variable function ( Constraint arg0 ,  Variable arg1 )  { List < Variable >  scope = arg0 . getScope (  )  ;  int size = scope . size (  )  ;  if  ( size != 2 )  { return null ;  } if  ( scope . get ( 0 )  . equals ( arg1 )  )  { return scope . get ( 1 )  ;  } else { return scope . get ( 0 )  ;  } }
double function ( LaneData data )  { double occupancy = 0 . 0 ;  try { occupancy = data . getOccupancy (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return occupancy ;  }
public String function ( int arg0 )  { try { if  ( arg0 == SK_INSTANCE . ordinal (  )  )  { return SK_INSTANCE . literalName ;  } else if  ( arg0 == SK_CLASSIFIER . ordinal (  )  )  { return SK_CLASSIFIER . literalName ;  } else { throw new IllegalArgumentException ( "Invalid argument value: " + arg0 )  ;  } } catch  ( Exception loc0 )  { System . err . println ( "Exception caught: " + loc0 . getMessage (  )  )  ;  return null ;  } }
void function ( String arg0 ,  String arg1 )  { panel . setDocument ( arg0 ,  arg1 )  ;  layout ( g2 ,  dim )  ;  render ( g2 )  ;  } Note: It is assumed that the variables g2 ,  dim and panel are already initialized before calling this function . 
String function (  )  { String loc0 = TodoParser . encode ( item . getHeadline (  )  )  ;  return loc0 ;  }
String function (  )  { StringBuilder sb = new StringBuilder (  )  ;  for  ( Customer loc0 : customers )  { sb . append ( format ( loc0 . getNumberOfAccounts (  )  ,  "account" )  )  ;  sb . append ( " for " )  ;  sb . append ( loc0 . getName (  )  )  ;  sb . append ( "\n" )  ;  } return sb . toString (  )  ;  }
double function ( StatsAccumulator statsAccumulator )  { double min = statsAccumulator . max ;  if  ( Double . isNaN ( min )  )  { return Double . NaN ;  } boolean foundFinite = false ;  for  ( double value : statsAccumulator . snapshot (  )  . addAll ( 0 )  . values (  )  )  { if  ( Double . isFinite ( value )  )  { foundFinite = true ;  if  ( value  <  min )  { min = value ;  } } } if  ( !foundFinite )  { if  ( min == Double . POSITIVE_INFINITY )  { return Double . POSITIVE_INFINITY ;  } else { return Double . NaN ;  } } return min ;  }
void function (  )  { setUpClass (  )  ;  setUp (  )  ;  System . out . println ( "Test of getDeviceBlock method ,  of class Device . " )  ;  Object loc0 = dev . getCapabilityBlock (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  tearDown (  )  ;  tearDownClass (  )  ;  fail ( "The test case is a prototype . " )  ;  }
void function (  )  { SpaceXGUI . getInstance (  )  . appendToConsole ( TAG ,  "srini_string" )  ;  cmd . down ( speed )  . doFor ( 1000 )  ;  cmd . hover (  )  . doFor ( hoverTime )  ;  }
void function (  )  { try { bufferSize = 0 ;  buffer = new byte [ INITIAL_BUFFER_CAPACITY ]  ;  } catch  ( Exception e )  { } }
byte [  ]  function ( ECKey arg0 ,  byte [  ]  arg1 ,  byte [  ]  arg2 )  { return arg0 . sign ( arg1 )  . encodeToDER (  )  ;  }
String function ( Uri arg0 )  { E loc0 = getMatcherEntry ( arg0 )  ;  return loc0 . getBaseType (  )  + "/" + loc0 . getType (  )  + " . " + loc0 . getSubType (  )  ;  }
void function ( final short arg0 ,  final OutputStream arg1 )  { arg1 . write (  ( byte )  arg0 )  ;  arg1 . write (  ( byte )   ( arg0  >  >  8 )  )  ;  }
public void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  double gamma ,  DenseMatrix64F u ,  DenseMatrix64F x ,  DenseMatrix64F y )  { int n = arg0 . getNumElements (  )  ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { double val = arg1 . get ( i )  ;  for  ( int j = 0 ;  j  <  n ;  j ++  )  { val += gamma * u . get ( i )  * u . get ( j )  * x . get ( j )  ;  } y . set ( i ,  val )  ;  } }
public static void function ( Repository arg0 ,  String arg1 ,  String arg2 ,  OutputStream arg3 )  { try { CompressionUtils . tar ( CompressorStreamFactory . XZ ,  arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } }
public class SearchConditionBuilder { private String FIQL = DEFAULT_LANGUAGE ;  private static final String DEFAULT_LANGUAGE = "FIQL" ;  public String query (  )  { } public SearchConditionBuilder function ( String arg0 ,  String arg1 )  { try { Map < String ,  String >  loc0 = Collections . emptyMap (  )  ;  SearchConditionBuilder loc1 = instance ( arg0 )  ;  loc1 . FIQL = arg1 ;  return loc1 ;  } catch  ( Exception loc2 )  { throw new RuntimeException ( loc2 )  ;  } } private SearchConditionBuilder instance ( String arg0 )  throws Exception { } }
void function ( Object arg0 ,  Set < Object >  arg1 ,  Class < ? >  clazz )  { arg1 . add ( arg0 )  ;  int loc0 = arg0 . jjtGetNumChildren (  )  ;  for  ( int i = 0 ;  i  <  loc0 ;  i ++  )  { Object loc1 = arg0 . jjtGetChild ( i )  ;  function ( loc1 ,  arg1 ,  clazz )  ;  } if  ( clazz != null && !clazz . equals ( arg0 . getClass (  )  )  )  { arg1 . remove ( arg0 )  ;  } }
boolean function ( MotionEvent arg0 ,  HandwriterView view )  { boolean onlyPenInput = view . getOnlyPenInput (  )  ;  boolean isPenEvent = Hardware . isPenEvent ( arg0 )  ;  return  ( !onlyPenInput && !isPenEvent )  ;  }
public void function ( Object arg0 ,  Object arg1 )  { try { SecurityContext loc0 = getSecurityContext (  )  ;  if  ( loc0 != null && loc0 . isSecure (  )  )  { warning ( "Using insecure transport: HTTP" )  ;  if  ( blockUnsecureRequests )  { throw new OAuthRuntimeException ( "Insecure transport" ,  toBadRequestException (  )  )  ;  } } } catch  ( Exception loc1 )  { LOG . error ( "Error in OAuth service" ,  loc1 )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { try { if  ( xmppConnection != null && xmppConnection . isConnected (  )  )  { xmppConnection . disconnect (  )  ;  } if  ( workerPool != null && !workerPool . isShutdown (  )  )  { workerPool . shutdown (  )  ;  } } catch  ( Exception loc0 )  { log . error ( "Error stopping XMPP listener" ,  loc0 )  ;  } }
String function ( JSONObject arg0 ,  String arg1 )  { Object loc0 = arg0 . get ( arg1 )  ;  return loc0 != null ? loc0 . toString (  )  : null ;  }
void function ( byte [  ]  arg0 ,  int arg1 )  { byte [  ]  loc0 = arg0 ;  int loc1 = arg1 ;  byte [  ]  loc2 = new byte [ loc1 ]  ;  System . arraycopy ( loc0 ,  0 ,  loc2 ,  0 ,  loc1 )  ;  line . write ( loc2 ,  0 ,  loc1 )  ;  ByteData . getData (  )  . clear (  )  ;  }
public int function (  )  { int loc0 = 0 ;  try { if  ( value  < = Integer . MAX_VALUE )  { loc0 = sizeOf (  ( int ) value )  ;  } else { loc0 = sizeOf ( value )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
public void function (  )  { BitcoinSerializer loc0 = new BitcoinSerializer (  )  ;  boolean loc1 = loc0 . isParseLazyMode (  )  ;  loc0 . parseLazy = true ;  Message loc2 = loc0 . makeMessage ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 )  ;  loc0 . serialize ( loc2 ,  arg5 )  ;  }
public void function ( String arg0 )  { runStatus = arg0 ;  } Note: This method sets the value of the "runStatus" member variable to the value of the input argument "arg0" . 
void function (  )  { SpaceXGUI . getInstance (  )  . appendToConsole ( TAG ,  "srini_string" )  ;  cmd . setLedsAnimation ( LEDAnimation . BLINK_RED ,  3 ,   ( spinTime/1000 )  )  ;  cmd . spinRight ( spin90Speed )  . doFor ( spin90Time )  ;  cmd . hover (  )  . doFor ( hoverTime )  ;  }
Map < Long ,  Integer >  function ( ClientDetailsEntityService arg0 )  { Map < Long ,  Integer >  loc0 = new HashMap <  >  (  )  ;  try { for  ( ClientDetailsEntity loc1 : arg0 . getAllClients (  )  )  { loc0 . put ( loc1 . getId (  )  ,  0 )  ;  } } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  } return loc0 ;  }
public Object function ( Object arg0 )  { try { XPathContext loc0 =  ( XPathContext )  arg0 ;  XPathContext loc1 =  ( XPathContext )  loc0 . clone (  )  ;  LinkedList < Level >  loc2 = new LinkedList < Level >  (  )  ;  for  ( Level loc3 : loc1 . children )  { loc2 . addLast (  ( Level )  loc3 . clone (  )  )  ;  } loc1 . children = loc2 ;  loc1 . path = new LinkedList < Level >  (  )  ;  for  ( Level loc4 : loc0 . path )  { loc1 . path . addLast ( loc1 . attributes . get ( loc4 . name )  . clone (  )  )  ;  } return loc1 ;  } catch  ( CloneNotSupportedException e )  { throw new RuntimeException ( e )  ;  } }
byte function ( byte [  ]  arg0 )  { HashFunction loc0 = Hashing . murmur3_32 (  )  ;  try { int loc1 = loc0 . hashBytes ( arg0 )  . asInt (  )  & Integer . MAX_VALUE ;  return  ( byte )   ( loc1 % mNumBuckets )  ;  } catch  ( NullPointerException | IllegalArgumentException e )  { return -1 ;  } }
void function (  )  { String arg0 = "GGA" ;  String arg1 = "XYZ" ;  try { assertTrue ( instance . hasParser ( arg0 )  )  ;  assertFalse ( instance . hasParser ( arg1 )  )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 )  { proxiesHeader = arg0 ;  } String function (  )  { return proxiesHeader ;  } String function ( NettyHttpRequest request )  { String remoteIp = null ;  List < String >  proxyHeaderValues = request . headers (  )  . getAll ( proxiesHeader )  ;  if  ( proxyHeaderValues != null && !proxyHeaderValues . isEmpty (  )  )  { remoteIp = proxyHeaderValues . get ( proxyHeaderValues . size (  )  - 1 )  ;  } return remoteIp ;  }
String function (  )  { String result = "" ;  String xpath = getXPath (  )  ;  Iterator < Level >  iterator = path . descendingIterator (  )  ;  while  ( iterator . hasNext (  )  )  { Level loc0 = iterator . next (  )  ;  if  ( loc0 . type == Node . ATTRIBUTE_NODE )  { result += " @ " + getName ( loc0 . name )  ;  } else if  ( loc0 . type == Node . PROCESSING_INSTRUCTION_NODE )  { result += "processing-instruction (  ) " ;  } else if  ( loc0 . type == Node . TEXT_NODE )  { result += "text (  ) " ;  } else if  ( loc0 . type == Node . COMMENT_NODE )  { result += "comment (  ) " ;  } else { result += getName ( loc0 . name )  ;  } result += loc0 . predicates ;  result += loc0 . getNextSeparator (  )  ;  } if  ( xpath . length (  )   >  0 )  { result += xpath . substring ( 1 )  ;  } return result ;  }
void function ( BigDecimal arg0 )  { BigDecimal loc0 = arg0 ;  runId = loc0 ;  }
int function ( lr_item_core arg0 )  { int loc0 = arg0 . the_production . rhs_length (  )  ;  assert ( arg0 . _dot_pos == loc0 )  ;  return loc0 ;  }
void function (  )  { CompleteFileOptions loc0 = CompleteFileOptions . defaults (  )  ;  try { assertEquals ( 0 ,  loc0 . getUfsLength (  )  )  ;  } catch  ( AssertionError e )  { throw new RuntimeException ( "Test case failure" ,  e )  ;  } }
static Object function ( Object arg0 )  { return Permission . PERMISSIONS . get ( Integer . valueOf (  ( Integer )  arg0 )  )  ;  }
void function (  )  { cancelled = true ;  }
JsonArray function ( JsonObject arg0 ,  String arg1 )  { try { JsonArray loc0 = arg0 . getAsJsonArray ( arg1 )  ;  if  ( loc0 . size (  )  == 0 )  { return null ;  } return loc0 ;  } catch  ( Exception e )  { logger . error ( "Failed to translate set of strings to JSON array" ,  e )  ;  return null ;  } }
void function (  )  { double expected = 1 . 85 ;  double delta = 0 . 0001 ;  try { vhw . setExample ( EXAMPLE )  ;  double actual = vhw . getSpeedKmh (  )  ;  assertEquals ( expected ,  actual ,  delta )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public void function ( RPCMessage arg0 )  { int loc0 = arg0 . getId (  )  ;  if  ( loc0  <  0 || loc0  >  65535 )  { throw new Exception ( "Invalid message ID . " )  ;  } if  ( arg0 . hasPayload (  )  )  { int loc1 = arg0 . getEncodedLength (  )  ;  if  ( loc1  <  0 || loc1  >  16777216 )  { throw new Exception ( "Invalid payload length . " )  ;  } } }
boolean function ( String arg0 )  { boolean loc0 = s1 . hasField ( arg0 )  || s2 . hasField ( arg0 )  ;  return loc0 ;  } String function ( String arg0 ,  String arg1 )  { String loc0 = s1 . getString ( arg0 )  ;  if  ( loc0 == null )  { loc0 = s2 . getString ( arg1 )  ;  } return loc0 ;  } boolean function ( String arg0 ,  Constant arg1 )  { boolean loc0 = s1 . hasField ( arg0 )  && s1 . getVal ( arg0 )  . equals ( arg1 )  ;  if  ( !loc0 )  { loc0 = s2 . hasField ( arg0 )  && s2 . getVal ( arg0 )  . equals ( arg1 )  ;  } return loc0 ;  }
void function ( HttpServletRequest arg0 )  { HttpSession loc0 = arg0 . getSession (  )  ;  loc0 . setAttribute ( "authentication" ,  true )  ;  }
public FullyQualifiedClassType function (  )  { FullyQualifiedClassType loc0 = handlerClass ;  return loc0 ;  }
String function ( String arg0 ,  String arg1 ,  RevisionManagement arg2 )  { String loc0 = arg2 . getRevisionInformation ( arg0 ,  arg1 )  ;  oldRevisionGraphMap . put ( arg0 ,  loc0 )  ;  return loc0 ;  }
int [  ]  function ( int [  ]  [  ]  arg0 ,  int arg1 )  { int [  ]  loc0 = new int [ arg1 ]  ;  for  ( int loc1 = 0 ;  loc1  <  arg1 ;  loc1 ++  )  { loc0 [ loc1 ]  = arg0 [ 0 ]  [ loc1 ]  ;  for  ( int loc2 = 1 ;  loc2  <  arg0 . length ;  loc2 ++  )  { if  ( arg0 [ loc2 ]  [ loc1 ]  != loc0 [ loc1 ]  )  { throw new RuntimeException ( "Number of columns in every row must be the same . " )  ;  } } } return loc0 ;  }
public Spring retrieveControlSpring (  )  { int loc0 = mControlSpringIndex ;  if  ( loc0 == -1 )  { return null ;  } return mSprings . get ( loc0 )  ;  }
String function ( Compiler loc0 ,  String arg0 )  { ExtensionInfo loc1 = new ExtensionInfo ( arg0 )  ;  loc0 . addExtension ( loc1 )  ;  return loc1 . toString (  )  ;  } This function takes a Compiler object and a String argument as input .  It creates an ExtensionInfo object using the input String and adds it to the Compiler object using the addExtension method .  It then returns a String representation of the ExtensionInfo object using the toString method .  Note that no exception handling is included in this implementation . 
void function (  )  { try { RMBSentence loc0 = new RMBSentence (  )  ;  RMBSentence loc1 = new RMBSentence (  )  ;  String loc2 = "$GPRMB , A , 0 . 00 , R ,  , RUSKI , 5536 . 200 , N , 01436 . 500 , E , 432 . 3 , 234 . 9 ,  , V*58" ;  loc0 . setDestination ( loc1 )  ;  loc0 . setStatus ( 'A' )  ;  loc0 . setBearing ( 0 . 0 )  ;  loc0 . setOriginId ( "" )  ;  loc0 . setRange ( 0 . 0 )  ;  loc0 . setCrossTrackError ( 0 . 0 )  ;  loc0 . setVelocity ( 0 . 0 )  ;  loc0 . setSteerTo ( loc1 )  ;  loc0 . getOriginId (  )  ;  loc0 . getDestination (  )  ;  loc0 . getStatus (  )  ;  loc0 . getVelocity (  )  ;  loc0 . getRange (  )  ;  loc0 . getBearing (  )  ;  loc0 . getCrossTrackError (  )  ;  loc0 . getSteerTo (  )  ;  } catch  ( Exception loc3 )  { System . out . println ( loc3 . getMessage (  )  )  ;  } }
void function ( List < OAuthPermission >  arg0 )  { this . scopes = arg0 ;  }
Pageable loc0 = Pageable . unpaged (  )  ;  log . debug ( "Getting all ingredients . " )  ;  return ingredientRepository . findAll ( loc0 )  ; 
public static String function ( String arg0 ,  int arg1 )  { String loc0 = arg0 . trim (  )  ;  try { String [  ]  parts = loc0 . split ( "\t" )  ;  if  ( arg1  <  0 || arg1  > = parts . length )  { return "" ;  } String loc1 = parts [ arg1 ]  . trim (  )  ;  if  ( NA_STRING . equals ( loc1 )  )  { return "" ;  } return loc1 ;  } catch  ( ArrayIndexOutOfBoundsException e )  { throw new RuntimeException ( "Column index " + arg1 + " does not exist in the data line: " + loc0 ,  e )  ;  } }
void function ( int arg0 )  { try { this . timeoutMillis = arg0 ;  resetTimeout (  )  ;  } catch  ( Exception e )  { } }
void function ( BoxFolder arg0 ,  int arg1 )  { String loc0 = "srini_string" ;  for ( BoxItem . Info loc1 : arg0 )  { for ( int loc2 = 0 ;  loc2  <  arg1 ;  loc2 ++  )  { loc0 += INDENT_APPEND ;  } if ( loc1 instanceof BoxFolder . Info )  { BoxFolder loc2 =  ( BoxFolder )  loc1 . getResource (  )  ;  function ( loc2 ,  arg1 + 1 )  ;  } } } This method recursively lists folders in the Box account ,  primarily used for debugging . 
void function (  )  { try { vCloseRequested = true ;  socket . close (  )  ;  } catch  ( IOException loc0 )  { log . error ( "Failed to close socket: {}" ,  loc0 . getMessage (  )  )  ;  } catch  ( RuntimeException loc1 )  { log . error ( "Unexpected error occurred while closing socket: {}" ,  loc1 . getMessage (  )  )  ;  } finally { try { if  ( socket != null && !socket . isClosed (  )  )  { socket . close (  )  ;  } } catch  ( IOException loc2 )  { log . error ( "Failed to close socket in finally block: {}" ,  loc2 . getMessage (  )  )  ;  } finally { StreamParser . connectionClosed (  )  ;  } } }
void function ( MediaMuxerWrapper muxerWrapper ,  MediaFormat format ,  int trackIndex )  { muxerWrapper . mMediaMuxer . addTrack ( format )  ;  muxerWrapper . mEncoderCount ++  ;  if  ( muxerWrapper . mEncoderCount == muxerWrapper . mStatredCount )  { muxerWrapper . mMediaMuxer . start (  )  ;  muxerWrapper . mIsStarted = true ;  } if  ( muxerWrapper . DEBUG )  { Log . i ( muxerWrapper . TAG ,  "assigned track " + trackIndex + " to muxer" )  ;  } if  ( muxerWrapper . mIsStarted && !muxerWrapper . mAudioEncoder . isStarted (  )  && !muxerWrapper . mVideoEncoder . isStarted (  )  )  { throw new IllegalStateException ( "mediamuxer hasn't started" )  ;  } }
float function (  )  { if  ( mFinished )  { return mFinal ;  } float timePassed = timePassed (  )  ;  float distance = mDeltaX * mInterpolator . getInterpolation ( timePassed * mDurationReciprocal )  ;  mCurr = mStart + distance ;  if  (  ( timePassed  <  mDuration )  &&  ( mCurr != mFinal )  )  { return mCurr ;  } else { mFinished = true ;  return mFinal ;  } }
void function ( Map arg0 )  { try { Assert . notEmpty ( arg0 ,  "srini_string" )  ;  } catch  ( IllegalArgumentException e )  { System . err . println ( "Error: " + e . getMessage (  )  )  ;  } }
void function (  )  { notificationController . registerUserSession ( null ,  mockServerMessage )  ;  }
void function ( int arg0 )  { if  ( arg0  < = 0 || arg0  >  step )  { return ;  } int loc0 = arg0 - 1 ;  doAction ( loc0 )  ;  }
public int function ( Tag arg0 )  { int loc0 = this . key . compareTo ( arg0 . key )  ;  if  ( loc0 == 0 )  { return this . value . compareTo ( arg0 . value )  ;  } else { return loc0 ;  } }
float [  ]  function ( float arg0 )  { float [  ]  loc0 = newSpacingResultArray (  )  ;  if  ( !FloatUtil . floatsEqual ( arg0 ,  0 )  )  { for  ( int loc1 = 0 ;  loc1  <  loc0 . length ;  loc1 ++  )  { loc0 [ loc1 ]  = arg0 ;  } } return loc0 ;  }
public static List < URL >  function ( Collection < String >  arg0 ,  String arg1 ,  ClassLoader arg2 )  { List < URL >  resources = new ArrayList <  >  (  )  ;  ClasspathScanner scanner = ClasspathScanner . getClasspathScanner (  )  ;  try { resources = scanner . findResourcesInternal ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( IOException e )  { } return resources ;  }
QName function ( QName arg0 )  { Level loc0 = path . getLast (  )  ;  return loc0 . getName ( arg0 )  ;  attributes . put ( arg0 ,  loc0 )  ;  }
String function ( Message arg0 )  { String contentType = defaultContentTypeProperty ;  for  ( ContentTypeRule loc0 : rules )  { String loc1 = loc0 . getContentType ( arg0 )  ;  if  ( loc1 != null )  { contentType = loc1 ;  break ;  } } return contentType ;  }
GetOfferDetailsResponse . Return . DetailOfferData . FulfillmentPartner function (  )  { GetOfferDetailsResponse . Return . DetailOfferData loc0 = createGetOfferDetailsResponseReturnDetailOfferData (  )  ;  if  ( loc0 != null )  { GetOfferDetailsResponse . Return . DetailOfferData . FulfillmentPartner loc1 = loc0 . getFulfillmentPartner (  )  ;  if  ( loc1 != null )  { return loc1 ;  } } return null ;  }
public void function ( ItemList < T >  arg0 )  { try { this . items = arg0 ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
T function ( T arg0 )  { if  ( mIndex . containsKey ( arg0 )  )  { DirectedAcyclicGraphNode < T >  loc0 = mIndex . get ( arg0 )  ;  if  ( mRoots . contains ( loc0 )  )  { return loc0 . getPayload (  )  ;  } } return null ;  }
long function ( String arg0 )  { long loc0 = 0 ;  try { FileStatus loc1 = getFileStatus ( arg0 )  ;  loc0 = loc1 . getLen (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
List < String >  function (  )  { List < String >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = instance . listParsers (  )  ;  SentenceId [  ]  loc1 = SentenceId . values (  )  ;  assertEquals ( loc1 . length ,  loc0 . size (  )  )  ;  for  ( SentenceId id : loc1 )  { assertTrue ( loc0 . contains ( id . name (  )  )  )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public long function ( long arg0 ,  long arg1 ,  long arg2 ,  int arg3 )  { try { long loc0 = arg0 +  (  ( arg2 - arg1 )  / arg3 )  ;  return loc0 ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while getting the global chromosomal stop: " + e . getMessage (  )  )  ;  return -1 ;  } }
int function (  )  { return mStartCount ;  }
int function (  )  { int loc0 = 0 ;  int loc1 = 0 ;  int loc2 = 0 ;  try { loc0 = arg1 . recordsOutput (  )  ;  loc1 = arg3 . recordsOutput (  )  ;  loc2 = loc0 * loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc2 ;  }
List < String >  function ( String arg0 )  { String loc0 = getMap (  )  . get ( arg0 )  ;  String loc1 = loc0 != null ? loc0 : defaultValue ;  return Arrays . asList ( loc1 . split ( SPACE_DELIMITED )  )  ;  }
void function (  )  { try { events . clear (  )  ;  } catch  ( Exception e )  { } }
public void function (  )  { ClientRWLock loc0 = null ;  Lock loc1 = null ;  Lock loc2 = null ;  try { loc0 = new ClientRWLock (  )  ;  loc1 = loc0 . readLock (  )  ;  loc2 = loc0 . writeLock (  )  ;  } catch  ( Exception e )  { } finally { if  ( loc0 != null )  { loc0 . close (  )  ;  } } }
public void function ( int hour )  { if  ( hour  <  0 || hour  >  23 )  { throw new IllegalArgumentException ( "Invalid hour of day: " + hour )  ;  } this . hour = hour ;  }
public static Object function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 ,  Object arg4 )  { Object evictor = null ;  try { Class < ? >  evictorClass = CommonUtils . createNewClassInstance (  Configuration . getClass ( "spark . storage . memory . Evictor" )  )  ;  BlockMetadataManagerView loc0 =  ( BlockMetadataManagerView )  arg2 ;  Allocator loc1 =  ( Allocator )  arg3 ;  evictor = evictorClass . getConstructor (  long . class ,  BlockStoreLocation . class ,  BlockMetadataManagerView . class ,  Allocator . class ,  Object . class )   . newInstance ( arg0 ,  arg1 ,  loc0 ,  loc1 ,  arg4 )  ;  } catch  ( Exception e )  { throw new RuntimeException ( "Factory for Evictor . " ,  e )  ;  } return evictor ;  }
long function ( Token arg0 )  { try { return arg0 . issuedAt ;  } catch  ( Exception loc0 )  { return -1 ;  } }
import java . util . ArrayList ;  import java . util . Iterator ;  public class Linqy < T ,  F ,  E >  implements Iterator < E >  ,  Iterable < E >  { boolean iterated = false ;  Iterator < T >  i ;  Mapper < ? super F ,  T >  mapper ;  T lookAhead = null ;  E element ;  Predicate < ? super T >  filter ;  ArrayList < E >  function ( Iterable < T >  arg0 )  { ArrayList < E >  loc0 = new ArrayList <  >  (  )  ;  for  ( T loc1 : arg0 )  { loc0 . add ( element )  ;  } return loc0 ;  } }
 @ Override public Collection < String >  function ( final String arg0 )  { if  ( log . isDebugEnabled (  )  )  { log . debug ( "Getting user authorities for username: " + arg0 )  ;  } final Collection < String >  loc0 = getUserAuthorities ( arg0 )  ;  if  ( log . isDebugEnabled (  )  )  { log . debug ( "Found " + loc0 . size (  )  + " authorities for username: " + arg0 )  ;  } return loc0 ;  }
EigenDecomposition < DenseMatrix64F >  function ( int arg0 ,  DenseMatrix64F arg1 )  { SwitchingEigenDecomposition decomp = new SwitchingEigenDecomposition ( arg0 ,  arg0 ,  -1 )  ;  EigenDecomposition < DenseMatrix64F >  loc0 ;  if  ( decomp . inputModified (  )  )  loc0 = decomp . decompose ( arg1 )  ;  else loc0 = decomp . getEigenvalueDecomposition (  )  ;  return loc0 ;  }
public void function ( ComparisonListener arg0 )  { try { compListeners . add ( arg0 )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while adding listener: " + e . getMessage (  )  )  ;  } }
int function ( int arg0 ,  int arg1 )  { int loc0 = -1 ;  try { loc0 = arg0 + arg1 ;  } catch  ( Exception e )  { System . err . println ( "An error occurred: " + e . getMessage (  )  )  ;  } return loc0 ;  }
Matrix function ( int arg0 ,  int arg1 ,  double [  ]  [  ]  arg2 )  { Matrix matrix = new Matrix ( arg0 ,  arg1 )  ;  for  ( int loc0 = 0 ;  loc0  <  arg0 ;  loc0 ++  )  { for  ( int loc1 = 0 ;  loc1  <  arg1 ;  loc1 ++  )  { matrix . setValueAt ( loc0 ,  loc1 ,  arg2 [ loc0 ]  [ loc1 ]  )  ;  } } double det = determinant ( matrix )  ;  if  ( det == 0 )  { return matrix ;  } Matrix cofactor = new Matrix ( arg0 - 1 ,  arg1 - 1 )  ;  for  ( int loc0 = 0 ;  loc0  <  arg0 ;  loc0 ++  )  { for  ( int loc1 = 0 ;  loc1  <  arg1 ;  loc1 ++  )  { double [  ]  [  ]  subMatrix = createSubMatrix ( matrix ,  loc0 ,  loc1 )  . getValues (  )  ;  double sign = changeSign ( loc0 + loc1 )  ;  cofactor . setValueAt ( loc0 ,  loc1 ,  sign * determinant ( new Matrix ( arg0 - 1 ,  arg1 - 1 ,  subMatrix )  )  )  ;  } } Matrix result = transpose ( cofactor )  ;  return result ;  }
void function ( boolean arg0 )  { cacheTokens = arg0 ;  }
static List < String >  function ( String arg0 ,  Pattern arg1 )  { Matcher loc0 = null ;  List < String >  loc1 = new ArrayList <  >  (  )  ;  try { BufferedReader loc2 = new BufferedReader ( new FileReader ( arg0 )  )  ;  String loc3 ;  while  (  ( loc3 = loc2 . readLine (  )  )  != null )  { loc0 = arg1 . matcher ( loc3 )  ;  if  ( loc0 . find (  )  )  { loc1 . add ( loc0 . group ( 1 )  )  ;  } } loc2 . close (  )  ;  } catch  ( IOException e )  { throw new RuntimeException ( "Error reading file: " + arg0 )  ;  } return loc1 ;  }
ServletConfig function (  )  { return this . config ;  }
Schema function (  )  { return sch ;  }
public void function (  )  { try { long loc0 = System . currentTimeMillis (  )  ;  instance . setDuration ( loc0 )  ;  long loc1 = System . currentTimeMillis (  )  - loc0 ;  System . out . println ( "Test of setDuration method ,  of class LogEntryRequest took " + loc1 + " milliseconds . " )  ;  } catch  ( Exception loc2 )  { System . err . println ( "Error while testing setDuration method: " + loc2 . getMessage (  )  )  ;  } }
boolean function (  )  { while  ( s . next (  )  )  { if  ( idx . next (  )  )  { return true ;  } else { ts . moveToRid ( s . getDataRid (  )  )  ;  idx . resetIndex (  )  ;  if  ( idx . next (  )  )  { return true ;  } } } return false ;  }
double function (  )  { checkState (  )  ;  long count = count (  )  ;  double covariance = yStats . sampleCovariance (  )  ;  if  ( count != 0 )  { return ensurePositive ( covariance )  ;  } else { return Double . NaN ;  } }
void function (  )  { try { setUp (  )  ;  zda . setLocalZoneMinutes ( 30 )  ;  assertEquals ( 30 ,  zda . getLocalZoneMinutes (  )  )  ;  } catch  ( Exception e )  { System . out . println ( "Test case failed: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 )  { String loc0 = arg0 ;  setStartTime ( loc0 )  ;  }
public boolean function ( Schema schema ,  String fieldName )  { Collection < String >  fields = schema . fields (  )  ;  if  ( fields . contains ( fieldName )  )  { int fieldType = schema . type ( fieldName )  ;  if  ( fieldType == Schema . TYPE_BOOLEAN || fieldType == Schema . TYPE_FUNCTION || fieldType == Schema . TYPE_STRING )  { return true ;  } } return false ;  }
boolean function ( Object arg0 ,  Object arg1 )  { if  ( arg1 instanceof TtlBucket )  { TtlBucket loc0 =  ( TtlBucket )  arg1 ;  return loc0 . mTtlIntervalStartTimeMs ==  (  ( TtlBucket )  arg0 )  . mTtlIntervalStartTimeMs ;  } return false ;  }
public int function (  )  { int numEigenvalues = 0 ;  try { numEigenvalues = eig . getNumberOfEigenvalues (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return numEigenvalues ;  }
CheckServiceAccessRequest function (  )  { try { return new ObjectFactory (  )  . createCheckServiceAccessRequest (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error creating instance of CheckServiceAccessRequest: " + e . getMessage (  )  )  ;  return null ;  } }
void function ( String arg0 ,  String arg1 ,  String arg2 )  { try { this . feedId = arg0 ;  this . setDestFileName ( arg1 )  ;  this . testId = arg2 ;  } catch  ( Exception e )  { } }
void function (  )  { triggerShutdown (  )  ;  }
double [  ]  function ( BidiagonalDecompositionRow_D64 obj )  { double [  ]  loc0 = null ;  try { loc0 = obj . getGammasU (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public static Bounds function ( Node arg0 )  { Bounds loc0 = arg0 . getBoundsInParent (  )  ;  return loc0 ;  } This method takes a Node object as an argument and returns its physical transformed bounds  ( geom + effect + clip + transform )  without exception handling .  The method name is "function" and the argument name is "arg0" .  The local variable that holds the bounds object is named "loc0" . 
public void function ( MapType arg0 )  { try { setMapType ( arg0 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "An error occurred while setting the mapType property: " + loc0 . getMessage (  )  )  ;  } }
int function ( int arg0 ,  String arg1 )  { try { int result = function ( arg0 ,  arg1 )  ;  if  ( result  <  0 )  { String errorMsg = XLog . format ( "Value for {0} cannot be negative . " ,  arg1 )  ;  throw new IllegalArgumentException ( errorMsg )  ;  } return result ;  } catch  ( IllegalArgumentException e )  { throw e ;  } catch  ( Exception e )  { String errorMsg = XLog . format ( "Error occurred while processing {0}: {1}" ,  arg1 ,  e . getMessage (  )  )  ;  throw new RuntimeException ( errorMsg ,  e )  ;  } }
public void function (  )  { ExpectedException mThrown = ExpectedException . none (  )  ;  mThrown . expect ( IllegalArgumentException . class )  ;  mThrown . expectMessage ( "Invalid class name" )  ;  new CustomAuthenticationProvider ( "invalid_class_name" )  ;  }
void function (  )  { SpringBolt loc0 = new SpringBolt (  )  ;  loc0 . setScatterOutput ( true )  ;  loc0 . run ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  verify ( arg4 )  . ack ( arg2 )  ;  verify ( arg4 )  . emit ( arg3 ,  arg5 )  ;  verifyNoMoreInteractions ( arg4 )  ;  }
Escaper function (  )  { return new PercentEscaper (  "- . _~!$' (  ) * ,  ; &= @ :+" ,  false )  . asEscaper (  )  ;  }
Long function ( TestResultDetailsDTO obj )  { Long loc0 = obj . getSeqNo (  )  ;  return loc0 ;  }
void function ( int value )  { try { ensureCapacity ( 3 )  ;  mBuffer [ mWriter . position (  )  ]  =  ( byte )   (  ( value  >  >  16 )  & 0xFF )  ;  mWriter . putShort (  ( short )   ( value & 0xFFFF )  )  ;  } catch  ( BufferOverflowException e )  { } }
void function ( JdbcUtil loc0 )  { loc0 . closeAll (  )  ;  loc0 . getName (  )  ;  }
public void function ( ClassdiagramNode arg0 )  { try { uplinks . add ( arg0 )  ;  arg0 . addDownlink ( this )  ;  } catch  ( Exception e )  { System . out . println ( "Error occurred while adding uplink: " + e . getMessage (  )  )  ;  } }
void function (  )  { mTestTierView = new StorageTierView ( mTestTier ,  TEST_TIER_LEVEL )  ;  List < String >  expectedDirs = Arrays . asList ( TieredBlockStoreTestUtils . TIER_PATH [ mTestTierView . getTierViewOrdinal (  )  ]  )  ;  Assert . assertEquals ( expectedDirs ,  mTestTierView . getDirViews (  )  )  ;  }
boolean function ( int arg0 ,  List < Integer >  arg1 )  { int loc0 = 0 ;  int loc1 = periodsSumIutilRutil [ arg0 ]  ;  for  ( Element element : periodsElements [ arg0 ]  )  { if  ( arg1 . contains ( element . item )  )  { loc0 += element . sumIutilP ;  } } return loc0  > = loc1 ;  }
boolean function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . toLowerCase (  )  ;  String loc1 = "gitblit" ;  return loc0 . startsWith ( loc1 )  ;  }
public Script function ( ECKey arg0 )  { byte [  ]  loc0 = arg0 . getPubKey (  )  ;  ScriptBuilder loc1 = new ScriptBuilder (  )  ;  loc1 . data ( loc0 )  ;  loc1 . op ( OP_CHECKSIG )  ;  return loc1 . build (  )  ;  }
void function ( Cookie [  ]  arg0 )  { for  ( int i = 0 ;  i  <  arg0 . length ;  i ++  )  { Cookie loc0 = arg0 [ i ]  ;  if  ( !loc0 . isExpired ( new Date (  )  )  )  { cookies . remove ( loc0 )  ;  cookies . add ( loc0 )  ;  } } }
public double function (  )  { double loc0 = this . x ;  return loc0 ;  }
static String function ( List < Object >  arg0 ,  String arg1 )  { StringBuilder loc0 = new StringBuilder (  )  ;  for  ( int loc1 = 0 ;  loc1  <  arg0 . size (  )  ;  loc1 ++  )  { if  ( loc1  >  0 )  { loc0 . append ( arg1 )  ;  } loc0 . append ( arg0 . get ( loc1 )  )  ;  } return loc0 . toString (  )  ;  }
int function (  )  { try { int count = 0 ;  for  ( int i = 0 ;  i  <  _values . length ;  i ++  )  { if  ( _keys [ i ]  != null && _keys [ i ]  != DELETED )  { count ++  ;  } } return count ;  } catch  ( Exception e )  { return -1 ;  } }
public Object [  ]  function (  )  { Object [  ]  result = null ;  try { result = originalMatrix . getItems (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error: " + e . getMessage (  )  )  ;  } return result ;  }
ByteBuffer function ( InetSocketAddress arg0 ,  long arg1 ,  long arg2 ,  long arg3 ,  long arg4 ,  long arg5 )  { if  ( mReadResponse != null )  { ByteBuffer loc0 = mReadResponse . getPayloadDataBuffer (  )  ;  mReadResponse . release (  )  ;  return loc0 ;  } return null ;  }
public boolean function ( EntityLiving entity ,  EntityLivingBase target )  { int loc0 = entity . getEntityId (  )  ;  target . setAttackTarget ( entity )  ;  double loc1 = entity . getDistanceToEntity ( target )  ;  return loc1  < = 64 . 0 ;  } This function takes in two EntityLiving objects ,  "entity" and "target" ,  and sets the target as the entity's attack target .  It then calculates the distance between the two entities and returns whether it is less than or equal to 64 . 0 .  There is no exception handling in this function . 
void function (  )  { function (  )  ;  double loc0 = rand . nextDouble (  )  ;  performImplicitSingleStep ( loc0 ,  true )  ;  }
boolean function ( lalr_item arg0 )  { return _all . containsKey ( arg0 )  ;  }
RemoteBlockWriter function ( InetSocketAddress arg0 ,  long arg1 ,  long arg2 )  { RemoteBlockWriter loc0 = null ;  try { Class < ? >  loc1 = CommonUtils . createNewClassInstance (  Configuration . getClass ( PropertyKey . USER_BLOCK_REMOTE_WRITER_CLASS )  )  ;  loc0 =  ( RemoteBlockWriter )  loc1 . newInstance (  )  ;  loc0 . open ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception loc2 )  { throw Throwables . propagate ( loc2 )  ;  } return loc0 ;  }
class DoubleUtil { static double EPSILON = 0 . 00001 ;  static boolean function ( double arg0 ,  double arg1 )  { double loc0 = Math . abs ( arg0 )  ;  double loc1 = Math . abs ( arg1 )  ;  double diff = Math . abs ( loc0 - loc1 )  ;  return  ( diff  <  EPSILON )  ;  } }
CertificateChainInfo function (  )  { CertificateChainInfo loc0 = this . chain ;  return loc0 ;  }
public int function ( Object arg0 ,  Object arg1 )  { JobExitStatus loc0 =  ( JobExitStatus )  arg0 ;  JobExitStatus loc1 =  ( JobExitStatus )  arg1 ;  return loc0 . toString (  )  . hashCode (  )  == loc1 . toString (  )  . hashCode (  )  ? 1 : 0 ;  } Note: This function takes in two objects and casts them as JobExitStatus objects .  It then calls the toString (  )  method on each object to get their string representation and compares the hash codes of the resulting strings using the hashCode (  )  method .  The function returns 1 if the hash codes are equal and 0 otherwise .  This implementation is used to ensure compatibility with the equals (  )  implementation . 
boolean function ( byte arg0 )  { return arg0 == MinaCodecUtils . SPACE || arg0 == MinaCodecUtils . HT ;  }
public class EaseUI { private static EaseUI instance = null ;  private EaseUI (  )  {} public static EaseUI function ( Context arg0 ,  EMOptions arg1 )  { if ( instance == null )  { instance = new EaseUI (  )  ;  instance . init ( arg0 ,  arg1 )  ;  } return instance ;  } } Explanation: This code defines a class named EaseUI with a private constructor ,  and a static member variable named "instance" of type EaseUI that is initialized to null .  The "function" method is a static method that takes two arguments: "arg0" of type Context and "arg1" of type EMOptions .  Within the "function" method ,  the "instance" variable is checked to see if it is null .  If it is null ,  a new instance of EaseUI is created and initialized using the arguments passed to the function .  The new instance is then assigned to the "instance" variable .  Finally ,  the "instance" variable is returned .  This method ensures that only one instance of EaseUI is created and returns that instance whenever it is called .  The lazy initialization ensures that the instance is only created when it is needed ,  rather than at the time the class is loaded . 
void function ( Hessian2Output arg0 )  { if  ( arg0 != null )  { arg0 . free (  )  ;  _freeHessian2Output . free ( arg0 )  ;  } } This method takes a `Hessian2Output` object as an argument ,  checks if it is not null ,  frees the resources associated with the object using `arg0 . free (  ) ` method ,  and then frees the object itself using `_freeHessian2Output . free ( arg0 ) ` method .  It does not return any value and does not have any exception handling . 
public Date function ( AccessToken arg0 )  { Date loc0 = arg0 . expires ;  return loc0 ;  }
RPCMessage function ( int arg0 ,  int arg1 ,  int arg2 ,  int arg3 ,  int arg4 )  { final RPCMessage loc0 = new RPCBlockReadRequest ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 )  ;  mThrown . expect ( IllegalArgumentException . class )  ;  mThrown . expectMessage ( ExceptionMessage . NO_RPC_HANDLER . getMessage ( loc0 . getType (  )  )  )  ;  try { mHandler . channelRead0 ( mContext ,  loc0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
File function ( String arg0 ,  String arg1 )  { String path = runtimeManager . getFileOrFolder ( arg0 ,  arg1 )  . getPath (  )  ;  if  ( runtimeManager . getSettings (  )  . getBoolean ( Keys . git . cloudService ,  false )  )  { path = StringUtils . replace ( path ,  "/var/opt/gitblit/" ,  "/home/git/" )  ;  } return new File ( path )  ;  }
public Bus function (  )  { Bus loc0 = bus ;  return loc0 . function (  )  ;  }
ELEvaluator function ( Configuration arg0 )  { ELEvaluator loc0 = Services . get ( ELService . class )  . createEvaluator ( null )  ;  setConfigToEval ( loc0 ,  arg0 )  ;  return loc0 ;  }
public Double function ( String arg0 ,  String arg1 )  { ClassMetricKey loc0 = new ClassMetricKey ( arg0 ,  arg1 )  ;  Double loc1 = memo . get ( loc0 )  ;  if  ( loc1 == null )  { loc1 = getCalculator (  )  . computeFor ( operations . get ( new OperationSignature ( arg0 ,  arg1 )  )  )  ;  memo . put ( loc0 ,  loc1 )  ;  } return loc1 ;  }
String function ( SMSMessage loc0 )  { return loc0 . getSender (  )  ;  }
void function ( Repository arg0 ,  RevCommit arg1 )  { try { RepositoryCommit loc0 = new RepositoryCommit ( arg0 ,  arg1 )  ;  if  ( !commits . contains ( loc0 )  )  { addCommit ( loc0 )  ;  } } catch  ( IOException e )  { e . printStackTrace (  )  ;  } }
boolean function ( Object arg0 ,  boolean flag )  { Step stepToCheck = new Step ( arg0 ,  arg1 )  ;  for  ( int i = 0 ;  i  <  steps . getLength (  )  ;  i ++  )  { Step currentStep = steps . getStep ( i )  ;  if  ( flag )  { if  ( currentStep . equals ( stepToCheck )  )  { return true ;  } } else { if  ( currentStep . getX (  )  == stepToCheck . getX (  )  && currentStep . getY (  )  == stepToCheck . getY (  )  )  { return true ;  } } } return false ;  }
void function ( int arg0 )  { format . checkType ( 'I' )  ;  packLong ( arg0 ,  true )  ;  }
void function (  )  { Scheduler scheduler = Services . get (  )  . get ( SchedulerService . class )  . getScheduler (  )  ;  JobKey jobKey = new JobKey ( "PurgeService" ,  "DEFAULT" )  ;  try { scheduler . deleteJob ( jobKey )  ;  } catch  ( SchedulerException e )  { throw new RuntimeException ( "Error deleting job: " + e . getMessage (  )  )  ;  } }
int function ( TBase arg0 ,  byte [  ]  arg1 ,  TFieldIdEnum fieldId )  { TField field = locateField ( arg1 ,  fieldId )  ;  if  ( field != null )  { byte ttype = field . type ;  if  ( ttype == TType . I32 )  { Integer loc0 =  ( Integer )  partialDeserializeField ( ttype ,  arg1 ,  fieldId )  ;  if  ( loc0 != null )  { return loc0 . intValue (  )  ;  } } } return 0 ;  }
void function ( int arg0 )  { taskMode = arg0 ;  } The above method sets the value of the "taskMode" variable to the passed argument "arg0" ,  effectively changing the index of the current task . 
Date function (  )  { Date loc0 = new Date (  )  ;  String loc1 = request . getHeader ( "If-Modified-Since" )  ;  if  ( loc1 != null )  { loc0 . setTime ( request . getDateHeader ( "If-Modified-Since" )  )  ;  } return loc0 ;  }
void function ( Collection < String >  arg0 )  { try { after . addAll ( arg0 )  ;  } catch  ( Exception e )  { } }
void function ( String arg0 )  { try { this . to = arg0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( Entity arg0 ,  double arg1 )  { try { this . source = arg0 ;  this . destinationSet = false ;  Vec3 loc0 = RandomPositionGenerator . findRandomTargetBlockAwayFrom ( this . mob ,  16 ,  7 ,  Vec3 . createVectorHelper ( this . source . posX ,  this . source . posY ,  this . source . posZ )  )  ;  if  ( loc0 == null )  { return ;  } this . destination = loc0 ;  this . runSpeed = arg1 ;  this . setDestination (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { mWriter . close (  )  ;  assertTrue ( mWriter . isClosed (  )  )  ;  assertFalse ( mWriter . isCanceled (  )  )  ;  mThrown . expect ( IllegalStateException . class )  ;  mWriter . close (  )  ;  }
MetadataEditorCompat function ( Object arg0 ,  int arg1 ,  int arg2 )  { RemoteControlClientCompat rcClient =  ( RemoteControlClientCompat )  arg0 ;  RemoteControlClient . MetadataEditor editor = rcClient . editMetadata ( true )  ;  editor . putInt ( arg1 ,  arg2 )  ;  editor . apply (  )  ;  return MetadataEditorCompat . from ( editor )  ;  }
void function ( PersonBlogs arg0 ,  HashMap < String ,  HashMap < String ,  Integer >  >  arg1 )  { for  ( int loc1 = 0 ;  loc1  <  arg0 . getBloggerAgeClass (  )  . getPosts (  )  . size (  )  ;  loc1 ++  )  { String loc2 = arg0 . getBloggerAgeClass (  )  . getPosts (  )  . get ( loc1 )  ;  String [  ]  loc3 = NaiveBayesTrain . cleanPost ( loc2 )  ;  NaiveBayesTrain . updateNaiveBayesMapForSinglePost ( loc3 ,  arg1 ,  arg0 . getBloggerAgeClass (  )  . toString (  )  )  ;  } } This method takes a PersonBlogs object as the first argument ,  a HashMap < String ,  HashMap < String ,  Integer >  >  as the second argument ,  and loops through the posts of the PersonBlogs object .  For each post ,  it cleans the post by removing punctuation marks and updates the HashMap with the cleaned post data using the NaiveBayesTrain . updateNaiveBayesMapForSinglePost (  )  method .  The method does not return any value . 
String function ( long startTime ,  String message )  { long endTime = System . nanoTime (  )  ;  long elapsedTime = endTime - startTime ;  return message + " Elapsed time: " + elapsedTime + " ns . " ;  }
public static void function ( HttpServletRequest arg0 )  { try { String headers = arg0 . getRequestHeaders (  )  ;  System . out . println ( headers )  ;  LOG . debug ( headers )  ;  } catch  ( Exception e )  { } }
void function (  )  { LOG . info ( "Loading journal checkpoint file: {}" ,  mJournal . getName (  )  )  ;  String loc0 = mJournal . getCheckpointFilePath (  )  ;  InputStream loc1 = mJournal . getCheckpointInputStream (  )  ;  processJournalCheckpoint ( loc1 )  ;  long loc2 = getLatestSequenceNumber (  )  ;  LOG . info ( "Journal checkpoint file loaded .  Latest sequence number is: {}" ,  loc2 )  ;  mReader . close (  )  ;  }
long function ( MotionEvent arg0 ,  MotionEvent arg1 )  { long loc0 = arg1 . getEventTime (  )  - arg0 . getEventTime (  )  ;  return loc0 ;  }
void function ( byte [  ]  arg0 )  { try { OutputStream loc0 = clientSession . getSocket (  )  . getOutputStream (  )  ;  doWrite ( arg0 ,  loc0 )  ;  } catch  ( IOException e )  { logger . error ( "Failed to send data asynchronously" ,  e )  ;  } } private void doWrite ( byte [  ]  arg0 ,  OutputStream loc0 )  throws IOException { loc0 . write ( arg0 )  ;  loc0 . flush (  )  ;  }
void function (  )  { String [  ]  loc0 = {"1" ,  "2" ,  "3"} ;  instance . setSatelliteIds ( loc0 )  ;  String [  ]  loc1 = instance . getSatelliteIds (  )  ;  assertEquals ( loc0 . length ,  loc1 . length )  ;  int loc2 = 0 ;  for  ( String loc3 : loc0 )  { assertEquals ( loc3 ,  loc1 [ loc2 ++  ]  )  ;  } }
void function ( String hostname ,  int port )  { UDPEndPoint loc0 = new UDPEndPoint (  )  ;  loc0 . bind (  )  ;  InetAddress loc1 = InetAddress . getByName ( hostname )  ;  UDPEndPoint loc2 = new UDPEndPoint (  )  ;  loc2 . connect ( loc1 ,  port )  ;  loc2 . start (  )  ;  ClientSession loc3 = new ClientSession ( loc2 )  ;  clientEndpoint = loc2 ;  clientSession = loc3 ;  Thread loc4 = new Thread ( new Sender ( clientSession )  )  ;  loc4 . start (  )  ;  }
int function ( long arg0 ,  Coin arg1 ,  byte [  ]  arg2 ,  Sha256Hash arg3 ,  int arg4 ,  boolean arg5 )  { try { StoredTransactionOutput loc0 = new StoredTransactionOutput (  )  ;  loc0 . index = arg0 ;  loc0 . value = arg1 ;  loc0 . scriptBytes = arg2 ;  loc0 . hash = arg3 ;  loc0 . height = arg4 ;  loc0 . coinbase = arg5 ;  return loc0 . index ;  } catch  ( Exception e )  { return -1 ;  } }
Constant function (  )  { Constant loc0 = dataval ;  return loc0 ;  }
void function ( String arg0 ,  TokenReference arg1 )  { String loc0 = arg0 . trim (  )  ;  if  ( !loc0 . isEmpty (  )  )  { arg1 . setWsseValueType ( loc0 )  ;  } }
Map < String ,  String >  function ( Parcel arg0 )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  int loc1 = arg0 . readInt (  )  ;  for  ( int loc2 = 0 ;  loc2  <  loc1 ;  loc2 ++  )  { String loc3 = arg0 . readString (  )  ;  String loc4 = arg0 . readString (  )  ;  loc0 . put ( loc3 ,  loc4 )  ;  } return loc0 ;  }
void function ( DenseMatrix64F arg0 ,  double arg1 )  { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 . numRows ,  arg0 . numCols )  ;  CommonOps . setIdentity ( loc0 )  ;  CommonOps . scale ( arg1 ,  loc0 )  ;  CommonOps . add ( arg0 ,  loc0 ,  A )  ;  }
void function ( ComplexNode arg0 ,  ComplexNode arg1 )  { try { this . singleNestedComplexNode = arg1 ;  } catch  ( Exception e )  { } }
BoxFolder function ( String arg0 )  { try { BoxFolder loc0 = rootFolder . getFolder ( arg0 )  ;  return loc0 ;  } catch  ( BoxAPIException e )  { System . out . println ( MISSING_FOLDER_MESSAGE )  ;  return null ;  } }
public void function ( String arg0 )  { try { this . units = arg0 ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while setting the units of measurement: " + e . getMessage (  )  )  ;  } }
uint32_t function ( ChildNumber arg0 ,  boolean arg1 )  { try { int loc0 = arg0 . getI (  )  ;  if  ( arg1 )  { loc0 |= ChildNumber . HARDENED_BIT ;  } return  ( uint32_t ) loc0 ;  } catch  ( NullPointerException e )  { return 0 ;  } }
void function ( String arg0 )  { try { webEngine . load ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
public void function ( PropertyChangeListener arg0 )  { try { addPropertyChangeListener ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
String function ( String arg0 ,  String arg1 )  { String loc0 = null ;  try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (  )  ;  DocumentBuilder builder = factory . newDocumentBuilder (  )  ;  Document doc = builder . parse ( new File ( arg1 )  )  ;  XPathFactory xPathfactory = XPathFactory . newInstance (  )  ;  XPath xpath = xPathfactory . newXPath (  )  ;  xpath . setNamespaceContext ( new NamespaceContext (  )  { public String getNamespaceURI ( String prefix )  { return "http://www . omg . org/XMI" ;  } public String getPrefix ( String uri )  { return "xmi" ;  } public Iterator < String >  getPrefixes ( String uri )  { return null ;  } } )  ;  String expression = String . format ( "//xmi:Reference [  @ xmi:idref='%s' ] / @ xmi:id" ,  arg0 )  ;  loc0 =  ( String )  xpath . evaluate ( expression ,  doc ,  XPathConstants . STRING )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
boolean function ( ActivityRequest arg0 ,  ActivityResponse arg1 )  { boolean loc0 = false ;  try { loc0 = validateRequest ( arg0 )  ;  } catch  ( Exception loc1 )  { logger . error ( "Error while validating request for mandatory parameters . " ,  loc1 )  ;  arg1 . setStatusCode ( StatusCode . ERROR )  ;  arg1 . setStatusMessage ( "Error while validating request for mandatory parameters . " )  ;  } return loc0 ;  } private boolean validateRequest ( ActivityRequest request )  { }
boolean function (  )  { long loc0 = mUfs . getModificationTimeMs ( mCheckpointPath )  ;  return  ( loc0  < = 0 && mCheckpointRead )  ||  ( loc0  >  0 && mCheckpointLastModifiedTime == loc0 )  ;  }
public void function (  )  { RMCParser empty = new RMCParser (  )  ;  String EXAMPLE = "$GPRMC , 120044 . 567 , A , 6011 . 552 , N , 02501 . 941 , E , 000 . 0 , 360 . 0 , 160705 , 006 . 1 , E , A*0B" ;  RMCParser rmc = new RMCParser ( EXAMPLE )  ;  String loc0 = rmc . getTime (  )  ;  assertNotNull ( loc0 )  ;  assertEquals ( "12" ,  rmc . getHour (  )  )  ;  assertEquals ( "00" ,  rmc . getMinutes (  )  )  ;  assertEquals ( "44" ,  rmc . getSeconds (  )  )  ;  }
void function (  )  { loadState (  )  ;  }
void function (  )  { handleCharacterData (  )  ;  listener . processGroupEnd (  )  ;  }
String function ( String arg0 ,  File arg1 )  { File loc0 = getBackupDir ( arg0 )  ;  backup ( loc0 ,  arg1 )  ;  return null ;  }
public void function ( Constant arg0 ,  RID arg1 )  { beforeFirst ( arg0 )  ;  leaf . insert ( arg1 )  ;  leaf . close (  )  ;  BTreeDir loc0 = new BTreeDir (  )  ;  while  ( loc0 . searchCost ( TableInfo . numblocks ,  TableInfo . recordsPerBlock )   >  tx . blockSize (  )  / 2 )  { loc0 = loc0 . insert ( rootblk ,  dirTi ,  leafTi )  ;  rootblk = loc0 . block (  )  ;  } close (  )  ;  } Note: This implementation assumes that the necessary member variables and constructor are already defined and initialized in the BTreeIndex class .  It also assumes that the insert (  )  method in BTreeDir returns a new BTreeDir object that needs to be assigned to the local variable "loc0" .  Finally ,  this implementation does not handle any exceptions that may occur during the method execution . 
HashMap < Class < ? >  ,  String >  function (  )  { HashMap < Class < ? >  ,  String >  loc0 = new HashMap <  >  (  )  ;  try { loc0 . putAll ( ClassUtil . SHORT_NAMES_BY_TYPE )  ;  return loc0 . asInverseWithShortName (  )  ;  } catch  ( Exception e )  { } }
void function ( boolean arg0 )  { returnEntropy = arg0 ;  }
String function (  )  { String loc0 = request . getMethod (  )  ;  if  ( loc0 . equals ( "GET" )  || loc0 . equals ( "HEAD" )  )  { return request . getRequestURI (  )  ;  } return request . getPathInfo (  )  ;  }
int function (  )  { int loc0 = 0 ;  try { loc0 =  ++ generatedClassSerial ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
int function ( int arg0 )  { int loc0 = 0 ;  if  ( is_non_term (  )  )  { loc0 = arg0 + 1 ;  } else { loc0 = arg0 + 2 ;  } return loc0 ;  }
String function ( String arg0 ,  ArrayList < String >  arg1 ,  String arg2 )  { String loc0 = new String ( arg0 )  ;  ArrayList < String >  loc1 = new ArrayList < String >  ( arg1 )  ;  String loc2 = selectFolder ( loc0 ,  loc1 ,  arg2 )  ;  return loc2 ;  }
String function ( final HttpParams arg0 )  { try { String loc0 =  ( String )  arg0 . getParameter ( CoreProtocolPNames . HTTP_CONTENT_CHARSET )  ;  if  ( loc0 == null )  { loc0 = HTTP . DEFAULT_CONTENT_CHARSET ;  } return loc0 ;  } catch  ( Exception e )  { throw new IllegalArgumentException ( "srini_string" )  ;  } }
void function ( Command arg0 ,  int arg1 ,  boolean arg2 ,  boolean arg3 )  { if  ( arg2 )  { int loc0 = arg1 & 0xff ;  char loc1 =  ( char )  loc0 ;  handler . handleEvent ( new CharacterEvent ( loc1 )  )  ;  } else { int loc2 = arg1 ;  String loc3 = currentEncoding (  )  ;  if  ( loc3 != null )  { String loc4 = m_fontEncodings . get ( loc2 )  ;  if  ( loc4 == null )  { loc4 = loc3 ;  } handler . handleEvent ( new EncodingChangedEvent ( loc4 )  )  ;  } } }
void function ( ServerSession arg0 ,  ServerMessage arg1 )  { try { acitivityController . registerUserSession ( null ,  arg1 )  ;  fail ( "Expected NullPointerException to be thrown . " )  ;  } catch  ( NullPointerException e )  { } }
void function ( MessageWriter arg0 ,  String arg1 )  { try { QName loc0 = SOAP_ENCODING_REF_1_1 ;  arg0 . writeAttribute ( loc0 ,  arg1 )  ;  } catch  ( Exception e )  { throw new RuntimeException ( "Failed to write SOAP 1 . 1 ref attribute . " ,  e )  ;  } }
String function ( String arg0 )  { String loc0 = "" ;  try { URL url = new URL ( arg0 )  ;  HttpURLConnection conn =  ( HttpURLConnection )  url . openConnection (  )  ;  conn . setRequestMethod ( "GET" )  ;  BufferedReader in = new BufferedReader ( new InputStreamReader ( conn . getInputStream (  )  )  )  ;  String inputLine ;  StringBuffer content = new StringBuffer (  )  ;  while  (  ( inputLine = in . readLine (  )  )  != null )  { content . append ( inputLine )  ;  } in . close (  )  ;  loc0 = content . toString (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( Config arg0 )  { Config loc0 = arg0 ;  this . config = loc0 ;  }
String function ( String arg0 )  { String loc0 = _link ;  String loc1 = _rss_link ;  String loc2 = _title ;  Integer loc3 = _id ;  String loc4 = _image ;  String loc5 = _description ;  if  ( arg0 . equals ( "getRSSLink" )  )  { return loc1 ;  } else if  ( arg0 . equals ( "getDescription" )  )  { return loc5 ;  } else if  ( arg0 . equals ( "getLink" )  )  { return loc0 ;  } else if  ( arg0 . equals ( "getTitle" )  )  { return loc2 ;  } else if  ( arg0 . equals ( "getImage" )  )  { return loc4 ;  } else { return null ;  } }
public static BrowseOffersResponse . Return function (  )  { try { BrowseOffersResponse . Return loc0 = new BrowseOffersResponse . Return (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { return null ;  } }
Builder function ( Builder arg0 ,  final String arg1 ) { arg0 . setObjectType ( arg1 )  ;  return arg0 ;  }
public static Script createScriptPubKey ( byte [  ]  scriptHash )  { checkArgument ( scriptHash . length == 20 ,  "Script hash must be 20 bytes" )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . op ( OP_HASH160 )  ;  builder . data ( scriptHash )  ;  builder . op ( OP_EQUAL )  ;  Script scriptPubKey = builder . build (  )  ;  return scriptPubKey ;  }
String function (  )  { String loc0 = getOAuthServerConfiguration (  )  . getOpenIDConnectUserInfoEndpointAccessTokenValidator (  )  ;  return loc0 ;  }
ResourceTypeHandler function ( String arg0 )  { ResourceTypeHandler loc0 = ResourceTypeHandler . FILE ;  try { ResourceTypeHandler loc1 = ResourceTypeHandler . getResourceType ( arg0 )  ;  if  ( loc1 . isValid ( arg0 )  )  { loc0 = loc1 ;  } } catch  ( Exception e )  { } return loc0 ;  }
void function ( Double arg0 )  { mPendingQueue . add ( arg0 )  ;  runIfIdle (  )  ;  }
JPanel function (  )  { JPanel loc0 ;  loc0 = uiStack . getLastElement (  )  . function (  )  ;  uiStack . addPanel ( loc0 )  ;  return loc0 ;  }
import org . ejml . data . DenseMatrix64F ;  import org . ejml . interfaces . linsol . LinearSolver ;  import org . ejml . interfaces . linsol . LinearSolverQrp ;  import org . ejml . interfaces . linsol . QRPDecomposition ;  public class LinearSolverFactory { public static LinearSolver < DenseMatrix64F >  function ( boolean arg0 ,  DenseMatrix64F arg1 )  { QRPDecomposition < DenseMatrix64F >  loc0 = new QRColPivDecompositionHouseholderColumn_D64 (  )  ;  LinearSolverQrp < DenseMatrix64F >  loc1 = null ;  if  ( arg0 )  { loc0 . setComputeNorm2 ( true )  ;  loc1 = new SolvePseudoInverseQrp ( loc0 )  ;  } else { loc1 = new LinearSolverQrpHouseCol ( loc0 )  ;  } loc1 . setA ( arg1 )  ;  return loc1 ;  } }
public List < String >  function (  )  { List < String >  loc0 = new ArrayList <  >  ( acceptedC14nAlgorithms )  ;  if  ( loc0 . isEmpty (  )  )  { loc0 . add ( WSConstants . C14N_EXCL_OMIT_COMMENTS )  ;  } return loc0 ;  }
BigDecimal function (  )  { BigDecimal loc0 = successorId ;  return loc0 ;  }
String function ( DestinationFileExistsDTO dto )  { String loc0 ;  try { loc0 = dto . getFeedId (  )  ;  } catch  ( Exception e )  { loc0 = null ;  } return loc0 ;  }
List < NotationName >  function (  )  { return Collections . unmodifiableList ( notations )  ;  }
byte [  ]  function ( int arg0 ,  byte [  ]  arg1 ,  int arg2 )  { checkType ( PackConstants . TYPE_BYTE_ARRAY )  ;  int loc0 = getByteArrayLength (  )  ;  getByteArrayInternal ( loc0 ,  arg1 ,  arg2 ,  Math . min ( loc0 ,  arg2 . length - arg2 )  )  ;  return arg1 ;  }
boolean function ( Card arg0 )  { Array < Card >  enemyHandCards = getEnemyHandCards (  )  ;  for  ( Card loc0 : enemyHandCards )  { if  ( loc0 . getName (  )  . equals ( arg0 . getName (  )  )  )  { return true ;  } } return false ;  }
String function ( PCLDataUnitEntity arg0 )  { String loc0 = "" ;  try { loc0 = arg0 . getReceiptDateType (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( int attempts ,  long sleepTime )  { Semaphore semaphore = new Semaphore ( 0 )  ;  for  ( int i = 0 ;  i  <  attempts ;  i ++  )  { WaitForAsyncUtils . blockFxThreadWithSemaphore ( semaphore )  ;  try { semaphore . tryAcquire ( 1 ,  sleepTime ,  TimeUnit . MILLISECONDS )  ;  } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  } } WaitForAsyncUtils . sleep ( sleepTime ,  TimeUnit . MILLISECONDS )  ;  }
long function ( TokenRenewerResponse arg0 )  { long loc0 = arg0 . lifetime ;  return loc0 / 1000 ;  }
Object function ( String arg0 ,  Object arg1 ,  Object arg2 )  { if  ( json . has ( arg0 )  )  { Object loc0 = json . get ( arg0 )  ;  if  ( loc0 instanceof Boolean )  { return json . getBoolean ( arg0 )  ;  } else if  ( loc0 instanceof Function )  { return  (  ( Function )  loc0 )  . apply ( arg1 )  ;  } else if  ( loc0 instanceof String )  { return json . getString ( arg0 )  ;  } else { return loc0 ;  } } return arg2 ;  }
void function (  )  { canvas . setForegroundColor ( color )  ;  canvas . fillCircle ( xPosition ,  yPosition ,  diameter )  ;  }
void function (  )  { try { String loc0 = "org . argouml . model . mdr . MDRModelImplementation" ;  initializeModelImplementation ( loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
short function ( int arg0 ,  int arg1 )  { int loc0 = arg0 + salt ;  int loc1 = arg1 + salt ;  int loc2 = loc0 ^ loc1 ^  ( loc0  <  <  16 )  ^  ( loc1  <  <  16 )  ;  return  ( short )  result ( hi16 ( loc2 )  ,  lo16 ( loc2 )  )  ;  } short hi16 ( final int in )  { return  ( short )   ( in  >  >  >  16 )  ;  } short lo16 ( final int in )  { return  ( short )  in ;  } int result ( final short v0 ,  final short v1 )  { int loc0 =  (  ( int )  v0  <  <  16 )  |  (  ( int )  v1 & 0xffff )  ;  return unmix ( loc0 )  ;  } int unmix ( final int in )  { int loc0 = in ;  loc0 =  (  ( loc0  >  >  >  15 )  ^ loc0 )  * 0x2c1b3c6d ;  loc0 =  (  ( loc0  >  >  >  13 )  ^ loc0 )  * 0x297a2d39 ;  loc0 =  (  ( loc0  >  >  >  16 )  ^ loc0 )  ;  return loc0 ;  }
public String function ( String arg0 )  { try { Transform transform = new Transform (  )  ;  transform . setParameter ( "paramName" ,  arg0 )  ;  transform . transform (  )  ;  return transform . getResultString (  )  ;  } catch  ( Exception e )  { System . err . println ( "An exception occurred: " + e . getMessage (  )  )  ;  return null ;  } }
public String function (  )  { String loc0 = createdBy ;  return loc0 ;  } This method simply returns the value of the member variable "createdBy" ,  which is a String that represents the username of the person who created the instance of the "RegPCLTestResultEntity" class . 
boolean function (  )  { return largefarm . isBuilding (  )  || shortmine . isBuilding (  )  || longmine . isBuilding (  )  || smallhouse . isBuilding (  )  || largehouse . isBuilding (  )  ;  }
int function ( ScriptChunk arg0 )  { checkState (  )  ;  if  ( arg0 . isOpCode (  )  )  { int loc0 = Script . decodeFromOpN ( arg0 . opcode )  ;  if  ( loc0  > = 0 && loc0  < = 16 )  { return loc0 ;  } } return -1 ;  }
Book function ( Book arg0 )  { log . debug ( "Saving book: {}" ,  arg0 )  ;  return bookRepository . save ( arg0 )  ;  }
void function (  )  { String arg0 = "mjpeg" ;  String arg1 = this . composeURL ( arg0 )  . toString (  )  ;  URL loc0 = new URL ( arg1 )  ;  URLConnection loc1 = loc0 . openConnection (  )  ;  loc1 . connect (  )  ;  DataInputStream loc2 = new DataInputStream ( new BufferedInputStream ( loc1 . getInputStream (  )  )  )  ;  InputStream loc3 = this . getInputStream (  )  ;  byte [  ]  loc4 = new byte [ 1024 ]  ;  while  ( true )  { int loc5 = loc2 . read ( loc4 )  ;  if  ( loc5  <  0 )  break ;  loc3 . write ( loc4 ,  0 ,  loc5 )  ;  } }
void function ( TreeModel arg0 )  { try { if  ( !rules . contains ( arg0 )  )  { rules . add ( arg0 )  ;  } } catch  ( Exception e )  { System . err . println ( "An error occurred while adding the rule to the perspective: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 )  { resultMessage = arg0 ;  }
long function ( DataServerMessage loc0 )  { loc0 . generateHeader (  )  ;  loc0 . checkReady (  )  ;  return loc0 . mSessionId ;  }
void function (  )  { Mode loc0 = new Mode ( 0644 )  ;  String loc1 = "rw-r -- r -- " ;  assertEquals ( loc1 ,  loc0 . toString (  )  )  ;  Mode loc2 = new Mode ( 0600 )  ;  String loc3 = "rw --  --  -- -" ;  assertEquals ( loc3 ,  loc2 . toString (  )  )  ;  Mode loc4 = new Mode ( 0404 )  ;  String loc5 = "r -- r -- r -- " ;  assertEquals ( loc5 ,  loc4 . toString (  )  )  ;  }
void function ( DenseMatrix64F A ,  double gamma ,  D1Matrix64F u ,  D1Matrix64F w )  { int numElements = A . getNumElements (  )  ;  double [  ]  data = A . data ;  for  ( int i = 0 ;  i  <  numElements ;  i ++  )  { data [ i ]  += gamma * u . get ( i )  * w . get ( i )  ;  } }
void function (  )  { NMEAParser loc0 = instance . createParser (  )  ;  assertNull ( loc0 )  ;  event = new HeadingEvent ( instance ,  arg0 )  ;  instance . providerUpdate ( event )  ;  Sentence loc1 = factory . createParser ( arg0 )  ;  assertNotNull ( loc1 )  ;  assertTrue ( loc1 instanceof HDTSentence )  ;  assertFalse ( instance . isReady (  )  )  ;  instance . providerUpdate ( event )  ;  assertTrue ( instance . isReady (  )  )  ;  assertEquals ( arg0 ,  instance . getDevice (  )  . getSentence (  )  )  ;  }
void function ( String arg0 )  { c14nAlgorithm = WSConstants . C14N_EXCL_OMIT_COMMENTS ;  }
public static Response function ( String message )  { return Response . serverError (  )  . entity ( message )  . build (  )  ;  }
public static  < F ,  T >  Iterable < T >  function ( Iterable < F >  arg0 ,  Mapper < ? super F ,  T >  arg1 )  { try { return Linqy .  < F ,  T > map ( arg0 ,  arg1::apply )  ;  } catch  ( Exception loc0 )  { throw new RuntimeException ( loc0 )  ;  } }
I'm sorry ,  but the prompt you provided is incomplete and appears to be a Java class definition rather than a clear request for a specific method .  Can you please provide me with a clear request for a method that you would like me to write?
public static Sha256Hash function ( byte [  ]  contents )  { try { MessageDigest md = MessageDigest . getInstance ( "SHA-256" )  ;  byte [  ]  hashBytes = md . digest ( contents )  ;  Sha256Hash hashed = new Sha256Hash ( hashBytes )  ;  return hashed ;  } catch  ( NoSuchAlgorithmException e )  { throw new RuntimeException ( "SHA-256 algorithm not available" )  ;  } }
public  < T >  T function ( Class < T >  arg0 )  { return arg0 . cast ( services . get ( arg0 )  )  ;  } Note: This method returns the service object associated with the given public interface class "arg0" .  It assumes that the requested service has been previously registered with the Services object .  If the requested service is not found ,  this method will return null .  It does not handle any exceptions that may occur during the cast operation . 
int function ( int arg0 )  { try { loc0 = getTable (  )  . convertRowIndexToModel ( arg0 )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return -1 ;  }
class AddressFacade { AddressType address ;  String function (  )  { try { return function ( address . getPostalZone (  )  . getValue (  )  ,  null )  ;  } catch  ( NullPointerException e )  { return null ;  } } String function ( String arg0 ,  Object arg1 )  { String loc0 = "Postal zone: " + arg0 ;  String loc1 = "Error: " + arg1 ;  return loc0 != null ? loc0 : loc1 ;  } String getState (  )  { return address . getState (  )  ;  } String getStreet (  )  { return address . getStreet (  )  ;  } String getCity (  )  { return address . getCity (  )  ;  } }
void function ( String arg0 ,  String arg1 ,  Exception arg2 )  { String loc0 = "Popup an SQL error" ;  String loc1 = arg0 + " " + arg1 + " " + arg2 . toString (  )  ;  Popup popup = new Popup (  )  ;  popup . setLogger ( logger )  ;  popup . popupError ( loc0 )  ;  popup . warning ( Inter . get ( loc1 )  )  ;  popup . info ( Inter . get ( loc1 )  )  ;  }
String function ( String arg0 )  { LangCondition loc0 = new LangCondition ( arg0 )  ;  addCondition ( loc0 )  ;  return "" ;  }
public static long function ( JSONObject arg0 ,  String arg1 )  { long loc0 = 0 ;  try { loc0 = arg0 . getLong ( arg1 )  != null ? arg0 . getLong ( arg1 )  : 0 ;  } catch  ( JSONException e )  { } return loc0 ;  }
void function ( String arg0 )  { this . experimentTypes = arg0 ;  }
public PasswordCredentials function (  )  { return this . passwordCredentials ;  }
String function ( FeedConfigResponse obj )  { String loc0 = obj . reason ;  return loc0 ;  }
CheckMatrixMultShape loc0 = new CheckMatrixMultShape (  )  ;  MatrixMatrixMult loc1 = new MatrixMatrixMult (  )  ;  loc1 . invoke ( loc0 . getClass (  )  . getMethod ( "mult" )  ,  1 . 0 ,  new DenseMatrix64F ( 1 ,  1 )  ,  new DenseMatrix64F ( 1 ,  1 )  ,  new DenseMatrix64F ( 1 ,  1 )  )  ;  loc0 . checkAll (  )  ; 
void function (  )  { for  ( int loc0 = 0 ;  loc0  <  PROPS . size (  )  ;  loc0 ++  )  { AbstractSettings loc1 = PROPS . get ( loc0 )  ;  loc1 . revertToDefault (  )  ;  } }
void function ( ArgoDiagramAppearanceEvent arg0 ,  ArgoDiagramAppearanceEventListener arg1 )  { int loc0 = arg0 . getEventType (  )  ;  switch  ( loc0 )  { case ArgoEventTypes . DIAGRAM_FONT_CHANGED: arg1 . diagramFontChanged ( arg0 )  ;  break ;  default: LOG . error ( "Unhandled event type: " + loc0 )  ;  } }
double function ( double arg0 ,  double arg1 )  { try { double loc0 = Math . abs ( arg0 )  ;  double loc1 = Math . abs ( arg1 )  ;  double loc2 = Math . max ( loc0 ,  loc1 )  ;  return loc2  < = UtilEjml . EPS ? 0 . 0 : arg0 / loc2 ;  } catch  ( Exception e )  { return Double . NaN ;  } }
import java . io . * ;  public class S3Sample { public static void main ( String [  ]  args )  { function ( args [ 0 ]  )  ;  } static void function ( String arg0 )  { try { InputStream loc0 = new FileInputStream ( arg0 )  ;  BufferedReader loc1 = new BufferedReader ( new InputStreamReader ( loc0 )  )  ;  String loc2 ;  while  (  ( loc2 = loc1 . readLine (  )  )  != null )  { System . out . println ( loc2 )  ;  } loc1 . close (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } } static File createSampleFile (  )  { return null ;  } }
public static boolean function ( Object arg0 )  { return Boolean . TRUE . equals ( arg0 . get (  )  )  ;  }
void function ( OutputStream arg0 ,  OutputFieldsDeclarer arg1 )  { String [  ]  loc0 = getOutputFields (  )  ;  logger . info ( "Registering output fields: {}" ,  Arrays . toString ( loc0 )  )  ;  arg1 . declareStream ( getOutputStreamId (  )  ,  new Fields ( loc0 )  )  ;  }
for  ( int loc0 = 0 ;  loc0  <  mTestTierView . getTierViewDirs (  )  . size (  )  ;  loc0 ++  )  { StorageDirView loc1 = mTestTierView . getDirView ( loc0 )  ;  assertEquals ( mTestTierView . getTierViewDirs (  )  . get ( loc0 )  ,  loc1 . getDir (  )  )  ;  }
import javax . xml . transform . * ;  import javax . xml . transform . dom . DOMResult ;  import javax . xml . transform . dom . DOMSource ;  import org . w3c . dom . Document ;  public class Transformation { Properties output = new Properties (  )  ;  Source styleSheet ,  source ;  URIResolver uriResolver ;  Map < String , Object >  params = new HashMap < String , Object >  (  )  ;  TransformerFactory factory ;  ErrorListener errorListener ;  void addParameter ( String name ,  Object value )  { params . put ( name ,  value )  ;  } void setStylesheet ( Source s )  { styleSheet = s ;  } void transformTo ( Result r )  throws TransformerException { Transformer t = factory . newTransformer ( styleSheet )  ;  for  ( Map . Entry < String , Object >  entry : params . entrySet (  )  )  { t . setParameter ( entry . getKey (  )  ,  entry . getValue (  )  )  ;  } t . setURIResolver ( uriResolver )  ;  t . setErrorListener ( errorListener )  ;  t . transform ( source ,  r )  ;  } void setErrorListener ( ErrorListener l )  { errorListener = l ;  } void setURIResolver ( URIResolver r )  { uriResolver = r ;  } void clearOutputProperties (  )  { output . clear (  )  ;  } void addOutputProperty ( String name ,  String value )  { output . setProperty ( name ,  value )  ;  } void setSource ( Source s )  { source = s ;  } void setFactory ( TransformerFactory f )  { factory = f ;  } void clearParameters (  )  { params . clear (  )  ;  } String transformToString (  )  throws TransformerException { StringWriter writer = new StringWriter (  )  ;  Result result = new StreamResult ( writer )  ;  transformTo ( result )  ;  return writer . toString (  )  ;  } Document function (  )  throws TransformerException { DOMResult result = new DOMResult (  )  ;  transformTo ( result )  ;  return  ( Document )  result . getNode (  )  ;  } }
URI function ( String arg0 )  { String loc0 = arg0 . replaceAll ( " " ,  "%20" )  ;  String loc1 = uri . toString (  )  + "/" + loc0 + "/data" ;  return URI . create ( loc1 )  ;  }
public T function (  )  { T resource = null ;  try { resource = pool . acquire ( arg0 ,  arg1 ,  TimeUnit . DAYS )  ;  } catch  ( TimeoutException e )  { throw new RuntimeException ( "TimeoutException occurred while acquiring resource from the pool" ,  e )  ;  } catch  ( Throwable t )  { throw new RuntimeException ( "Error occurred while acquiring resource from the pool" ,  t )  ;  } return resource ;  }
void function (  )  { if  ( mIn != null )  { mIn . close (  )  ;  } if  ( mOut != null )  { mOut . close (  )  ;  } }
public static int function ( int arg0 ,  int arg1 ,  ProblemType arg2 ,  String arg3 )  { try { ValidationProblem problem = new ValidationProblem (  )  ;  problem . line = arg0 ;  problem . column = arg1 ;  problem . type = arg2 ;  problem . message = arg3 ;  return problem . column != ValidationProblem . UNKNOWN ? problem . column : ValidationProblem . UNKNOWN ;  } catch  ( Exception loc0 )  { return ValidationProblem . UNKNOWN ;  } }
void function ( byte [  ]  arg0 ,  long arg1 )  { if  ( finalised )  { throw new IllegalArgumentException ( "Generator already finalised" )  ;  } byte [  ]  loc0 = hexToByte ( Long . toHexString ( arg1 )  )  ;  byte [  ]  loc1 = new byte [ 32 ]  ;  for  ( int loc2 = 0 ;  loc2  <  32 ;  loc2 ++  )  { loc1 [ loc2 ]  ^= mixednumber [ ptr ++  ]  ;  ptr %= 32 ;  } byte [  ]  loc3 = hashByteArr ( loc1 )  ;  for  ( int loc4 = 0 ;  loc4  <  32 ;  loc4 ++  )  { mixednumber [ loc4 ]  ^= loc3 [ loc4 ]  ;  } if  ( !Arrays . equals ( loc0 ,  loc3 )  )  { throw new IllegalArgumentException ( "Number verification failed" )  ;  } }
QualifiedName function ( String arg0 ,  OperationSigMask arg1 )  { QualifiedName qname = getQualifiedName ( arg0 )  ;  ClassStats classStats = getClassStats ( qname ,  true )  ;  classStats . compute ( arg1 )  ;  return qname ;  }
void function (  )  { try { YahooImageFactory loc0 = new YahooImageFactory (  )  ;  runTest ( "test . json" ,  loc0 ,  10 )  ;  } catch  ( Exception loc1 )  { LOG . error ( "Error occurred while testing input stream from Yahoo: {}" ,  loc1 . getMessage (  )  )  ;  } }
void function ( String arg0 )  { if  ( LocalCertificateStore . ALIAS_PATTERN . matcher ( arg0 )  . matches (  )  )  { String loc0 = arg0 . substring ( LocalCertificateStore . ALIAS_PREFIX . length (  )  )  ;  if  ( loc0 . length (  )  == 40 )  { LocalCertificateStore . deleteFile ( LocalCertificateStore . FILE_PREFIX + loc0 )  ;  } } }
void function ( AuthType arg0 )  { try { if  ( arg0 == AuthType . SIMPLE || arg0 == AuthType . CUSTOM )  { throw new UnsupportedOperationException ( "Unsupported authentication type" )  ;  } else { System . out . println ( arg0 . getAuthName (  )  )  ;  } } catch  ( Exception e )  { System . out . println ( "Exception caught: " + e . getMessage (  )  )  ;  } }
void function ( MediaRouter arg0 ,  ComponentName arg1 ,  Object arg2 )  { try { arg0 . addRemoteControlClient ( arg1 ,  arg2 )  ;  } catch  ( IllegalArgumentException loc0 )  { loc0 . printStackTrace (  )  ;  } catch  ( IllegalStateException loc1 )  { loc1 . printStackTrace (  )  ;  } }
public void function (  )  { try { InitializeModel model = new InitializeModel (  )  ;  model . initializeDefault (  )  ;  String arg0 = "org . argouml . model . mdr . MDRModelImplementation" ;  model . initializeModelImplementation ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
boolean function (  )  { double loc0 = mob . getPositionVector (  )  . distanceTo ( buildingSpot )  ;  double loc1 = 0 . 5D + mob . width / 2 . 0D ;  return loc0  <  loc1 && !isBuildingDone ;  } This function checks if the entity mob is on the building spot by calculating the distance between the entity's current position and the building spot ,  and comparing it with half the entity's width plus a constant value of 0 . 5 .  If the distance is less than this value and the building is not done ,  it returns true ,  indicating that the entity is on the building spot .  The function does not handle any exceptions . 
public void function ( long arg0 )  { try { long loc0 = k ;  k ++  ;  lastFeedbacktime = System . currentTimeMillis (  )  ;  sequenceNumber = arg0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
int function (  )  { int loc0 = 0 ;  try { loc0 = _size ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public static List < String >  function (  )  { List < String >  abis = new ArrayList <  >  (  )  ;  try { int sdkInt = Build . VERSION . SDK_INT ;  int lollipop = Build . VERSION_CODES . LOLLIPOP ;  String cpuAbi = Build . CPU_ABI ;  String cpuAbi2 = Build . CPU_ABI2 ;  class VersionDependent { List < String >  getSupportedAbis (  )  { return LollipopSysdeps . getSupportedAbis (  )  ;  } } List < String >  supportedAbis = new VersionDependent (  )  . getSupportedAbis (  )  ;  if  ( sdkInt  > = lollipop && supportedAbis != null && supportedAbis . size (  )   >  0 )  { if  ( cpuAbi != null )  { for  ( String abi : supportedAbis )  { if  ( abi . equals ( cpuAbi )  )  { abis . add ( abi )  ;  } } } if  ( cpuAbi2 != null )  { for  ( String abi : supportedAbis )  { if  ( abi . equals ( cpuAbi2 )  )  { abis . add ( abi )  ;  } } } for  ( String abi : supportedAbis )  { if  ( !abis . contains ( abi )  )  { abis . add ( abi )  ;  } } } } catch  ( Throwable t )  { } return abis ;  }
void function (  )  { server . stop (  )  ;  } This method simply calls the "stop (  ) " method of the "server" object ,  which stops the execution of the server without any exception handling . 
Map < String ,  String >  function (  )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  try { for  ( Map . Entry < String ,  List < String >  >  entry : connection . getHeaderFields (  )  . entrySet (  )  )  { if  ( entry . getKey (  )  != null )  { loc0 . put ( entry . getKey (  )  ,  entry . getValue (  )  . get ( 0 )  )  ;  } } } catch  ( IOException e )  { } return loc0 ;  }
void function ( List < String >  arg0 ,  String arg1 )  { Iterator < String >  loc0 = arg0 . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { String loc1 = loc0 . next (  )  ;  if  ( loc1 . equals ( arg1 )  )  { loc0 . remove (  )  ;  break ;  } } }
public static SearchFactory function (  )  { SearchFactory loc0 ;  if ( SearchFactory . instance == null )  { loc0 = new SearchFactory (  )  ;  SearchFactory . instance = loc0 ;  } else { loc0 = SearchFactory . instance ;  } return loc0 ;  } This method returns the instance of the SearchFactory class using lazy instantiation .  It first checks if the instance is null ,  and if it is ,  it creates a new instance and sets the instance variable to it .  If the instance variable is not null ,  it returns the existing instance .  No exception handling is performed in this method . 
void function (  )  { System . out . println ( "Test of listComPorts method ,  of class ComPortController . " )  ;  ComPortController . listComPorts (  )  ;  fail (  )  ;  }
private void function (  )  { String arg0 = "invalid_provider_class_name" ;  ExpectedException loc0 = ExpectedException . none (  )  ;  loc0 . expect ( IllegalArgumentException . class )  ;  loc0 . expectMessage ( "Class " + arg0 + " does not implement AuthenticationProvider" )  ;  new CustomAuthenticationProvider ( arg0 )  ;  }
String function ( String arg0 ,  String arg1 )  { OAuthError error = new OAuthError (  )  ;  error . setErrorDescription ( arg0 )  ;  return error . getErrorDescription (  )  ;  }
boolean function ( String arg0 )  { boolean loc0 = lhsscan . hasField ( arg0 )  ;  boolean loc1 = rhsscan != null && rhsscan . hasField ( arg0 )  ;  return loc0 || loc1 ;  }
List < SinkInfo >  function ( String arg0 )  { List < SinkInfo >  loc0 = findSinkByMethodSignature ( arg0 )  ;  if  ( !isEmpty (  )  )  { } return loc0 ;  }
import java . io . File ;  import org . apache . poi . poifs . filesystem . POIFSFileSystem ;  import org . junit . Assert ;  import com . pff . PSTFile ;  import com . pff . MessageStore ;  public class PasswordTest { public void testPasswordProtected (  )  { File file = new File ( ClassLoader . getSystemResource ( "test . pst" )  . getFile (  )  )  ;  PSTFile pstFile = new PSTFile ( file )  ;  POIFSFileSystem fs = null ;  try { fs = new POIFSFileSystem ( file )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } MessageStore messageStore = pstFile . getMessageStore (  )  ;  boolean isPasswordProtected = messageStore . isPasswordProtected (  )  ;  Assert . assertEquals ( false ,  isPasswordProtected )  ;  } public void function (  )  { File arg0 = new File ( ClassLoader . getSystemResource ( "test . pst" )  . getFile (  )  )  ;  PSTFile loc0 = new PSTFile ( arg0 )  ;  POIFSFileSystem loc1 = null ;  try { loc1 = new POIFSFileSystem ( arg0 )  ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  } MessageStore loc3 = loc0 . getMessageStore (  )  ;  boolean loc4 = loc3 . isPasswordProtected (  )  ;  Assert . assertEquals ( false ,  loc4 )  ;  } }
Point2D function ( String arg0 ,  double arg1 ,  double arg2 )  { Point2D loc0 = new Point2D . Double ( arg1 * Math . cos ( Math . PI / 4 )  ,  arg2 * Math . sin ( Math . PI / 4 )  )  ;  links . addVertex ( arg0 )  ;  locationPositions . put ( arg0 ,  loc0 )  ;  return loc0 ;  }
public static List < String >  function ( DeterministicSeed seed )  { List < String >  mnemonicCode = null ;  try { mnemonicCode = seed . decodeMnemonicCode ( seed . getMnemonicAsBytes (  )  )  ;  } catch  ( Exception e )  { } return mnemonicCode ;  }
public int function ( String fieldName )  { int offset = 0 ;  try { offset = offsets . get ( fieldName )  ;  } catch  ( NullPointerException e )  { } return offset ;  }
class SampleDevicesServiceActivator implements BundleActivator { IEnvironments environments=null ;  HashMap < String , DevicesConnectionFactory >  factories=new HashMap < String , DevicesConnectionFactory >  (  )  ;  AutoSIMDevicesConfig config=null ;  public void start ( BundleContext context )  { } public void function ( BundleContext arg0 )  { for ( AutoSIMDeviceConfig loc0 : config . devices )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } } public void stop ( BundleContext context )  { } }
boolean function ( Map < Long , Lineage >  loc0 ,  long arg0 )  { return loc0 . containsKey ( arg0 )  ;  }
void function ( Object arg0 ,  Object arg1 )  { IFetcherExecutionContext loc0 = fetcherExecutionContextImpl ;  loc0 . captureSourceMetadata (  )  ;  StepContribution loc1 =  ( StepContribution )  arg0 ;  loc1 . setExitStatus ( JobExitStatus . getExitStatus ( RepeatStatus . FINISHED )  )  ;  }
int function ( boolean completelyVisible )  { try { int childCount = recyclerView . getChildCount (  )  ;  View lastVisibleView = findOneVisibleChild ( childCount - 1 ,  -1 ,  completelyVisible ,  false )  ;  int lastVisiblePosition = recyclerView . getChildAdapterPosition ( lastVisibleView )  ;  return lastVisiblePosition ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return -1 ;  } }
String function ( ConfigurationKey arg0 )  { String loc0 = null ;  try { loc0 = config . getString ( arg0 )  ;  } catch  ( ConfigurationException e )  { } return loc0 ;  }
int function ( int arg0 ,  String arg1 ,  String arg2 )  { int loc0 ;  if  ( !isTempBlock ( Buffer . block )  )  { SetStringRecord record = new SetStringRecord ( arg1 ,  arg2 )  ;  loc0 = record . writeToLog (  )  ;  } else { loc0 = -1 ;  } return loc0 ;  }
String function ( String arg0 )  { try { DAOWrapper dao = new DAOWrapper (  )  ;  return dao . builder (  )  . addText ( arg0 )  . setPlace_name ( "Not required" )  . builder (  )  . buildFieldJSON (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred in function: " + e . getMessage (  )  )  ;  return null ;  } }
void function ( Object arg0 ,  Object arg1 )  { DiffBuilder diffBuilder = DiffBuilder . compare ( arg0 )  . withTest ( arg1 )  . ignoreComments ( true )  ;  Source testSource = diffBuilder . getSource ( arg1 )  ;  Source controlSource = diffBuilder . getSource ( arg0 )  ;  Source wrappedTestSource = diffBuilder . wrap ( testSource )  ;  Source wrappedControlSource = diffBuilder . wrap ( controlSource )  ;  diffBuilder = diffBuilder . compare ( wrappedControlSource )  . withTest ( wrappedTestSource )  . ignoreComments ( true )  ;  List < Difference >  differences = diffBuilder . getDifferences (  )  ;  diffBuilder . withDifferenceListeners (  )  . comparisonPerformed ( null ,  ComparisonResult . DIFFERENT )  ;  differences . removeIf ( loc0 - >  loc0 . toString (  )  . contains ( "Comment" )  )  ;  }
ResponseEntity < Void >  function (  @ PathVariable String arg0 )  { log . debug ( "REST request to delete DishCollection with id: {}" ,  arg0 )  ;  dishCollectionService . delete ( arg0 )  ;  return ResponseEntity . ok (  )  . headers ( HeaderUtil . createEntityDeletionAlert ( "DishCollection" ,  arg0 )  )  . build (  )  ;  }
public static Map < Object ,  Double >  function ( BayesianNetwork arg0 ,  RandomVariable [  ]  arg1 ,  AssignmentProposition [  ]  arg2 ,  int arg3 ,  int arg4 )  { Map < Object ,  Double >  W = new HashMap <  >  (  )  ;  for  ( int i = 0 ;  i  <  arg4 ;  i ++  )  { Pair < Map < RandomVariable ,  Object >  ,  Double >  weightedSampleResult = weightedSample ( arg0 ,  arg2 )  ;  Map < RandomVariable ,  Object >  sample = weightedSampleResult . getLeft (  )  ;  double weight = weightedSampleResult . getRight (  )  ;  for  ( RandomVariable X : arg1 )  { if  ( !sample . containsKey ( X )  )  { int index = ProbUtil . indexOf ( X ,  arg1 )  ;  sample . put ( X ,  arg2 [ index ]  . getValue (  )  )  ;  } } boolean consistent = true ;  for  ( AssignmentProposition e : arg2 )  { if  ( !sample . get ( e . getTermVariable (  )  )  . equals ( e . getValue (  )  )  )  { consistent = false ;  break ;  } } if  ( consistent )  { Object value = sample . get ( arg1 [ 0 ]  )  ;  W . put ( value ,  W . getOrDefault ( value ,  0 . 0 )  + weight )  ;  } } return ProbabilityTable . normalize ( W )  ;  }
int function ( Object arg0 ,  int arg1 ,  boolean arg2 )  { int loc0 = hashCode ( arg0 )  & 0x7fffffff ;  // Mask out negative sign int loc1 = loc0 % _prime ;  Object loc2 ;  while  (  ( loc2 = _keys [ loc1 ]  )  != null )  { if  ( loc2 == arg0 || loc0 == hashCode ( loc2 )  && loc2 . equals ( arg0 )  )  { if  ( arg2 )  { _values [ loc1 ]  = arg1 ;  } return loc1 ;  } loc1 =  ( loc1 + 1 )  % _prime ;  } int loc3 = getBiggestPrime ( _size + 1 )  ;  if  ( loc3  >  _prime )  { resize ( loc3 )  ;  loc1 = loc0 % _prime ;  } _keys [ loc1 ]  = arg0 ;  _values [ loc1 ]  = arg1 ;  _size ++  ;  return NULL ;  }
byte [  ]  function (  )  { int loc0 = getByteArrayLength (  )  ;  byte [  ]  loc1 = new byte [ loc0 ]  ;  getByteArrayInternal ( loc0 ,  loc1 ,  0 ,  loc0 )  ;  return loc1 ;  }
SAMLSSOReqValidationResponseDTO function ( String arg0 )  { SAMLSSOReqValidationResponseDTO loc0 = new SAMLSSOReqValidationResponseDTO ( arg0 )  ;  SPInitLogoutRequestProcessor loc1 = new SPInitLogoutRequestProcessor (  )  ;  loc1 . process ( null ,  null ,  null )  ;  return loc0 ;  }
void function ( Object arg0 ,  PropertyChangeListener arg1 )  { try { addElementListener ( arg1 ,  arg0 )  ;  } catch  ( Exception e )  { LOG . error ( "Failed to add element listener" ,  e )  ;  } }
public class Mapping { long qStart ,  tStop ,  tStart ;  int blockSize ;  int getBlockSize (  )  { return blockSize ;  } long getTStop (  )  { return tStop ;  } long getQStart (  )  { return qStart ;  } void function (  )  { } }
RegistrationRequest function (  )  { try { return new ObjectFactory (  )  . createRegistrationRequest (  )  ;  } catch  ( Exception e )  { } }
boolean function ( File arg0 ,  String [  ]  arg1 )  { if  ( arg0 != null && arg0 . getName (  )  != null )  { String filename = arg0 . getName (  )  ;  for  ( int i = 0 ;  i  <  arg1 . length ;  i ++  )  { if  ( filename . endsWith ( arg1 [ i ]  )  )  { return true ;  } } } return false ;  }
String function (  )  { return signatureCrypto ;  }
public void function (  )  { try { instance . maxMemory = 0 ;  } catch  ( Exception e )  { } }
void function ( File arg0 )  { try { setSourceCodeFilename ( arg0 . getAbsolutePath (  )  )  ;  if  ( getSourceCodeFile (  )  == null )  { throw new IllegalArgumentException ( "Source code file cannot be null . " )  ;  } } catch  ( Exception loc0 )  { setIgnoreExceptions ( true )  ;  getReport (  )  . addError ( new AnalysisError ( loc0 . getMessage (  )  )  )  ;  } }
public void function ( Node arg0 )  { try { closed . removeValue ( arg0 )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while removing node from closed list: " + e . getMessage (  )  )  ;  } }
String function (  )  { try { return new String ( _messageBody ,  Charset . forName ( _encoding )  )  ;  } catch  ( Exception e )  { return "rubbish string" ;  } }
void function ( Path arg0 ,  int [  ]  arg1 )  { model . moveCharacter ( arg0 ,  arg1 )  ;  triggerEvent (  )  ;  }
boolean function (  )  { boolean loc0 = ignoreExceptions ;  if  ( getAttribute ( "ignoreExceptions" )  != null )  { loc0 =  ( Boolean )  getAttribute ( "ignoreExceptions" )  ;  } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { StringBuilder loc0 = new StringBuilder (  )  ;  if  ( loc0 . length (  )   >  0 )  { loc0 . append ( " , " )  ;  } loc0 . append ( arg0 )  ;  if  ( loc0 . length (  )   >  0 )  { loc0 . append ( " , " )  ;  } loc0 . append ( arg1 )  ;  return loc0 . toString (  )  ;  }
Map < String ,  SortedSet < String >  >  function ( Map < String ,  SortedSet < String >  >  arg0 ,  String arg1 ,  Collection < String >  arg2 )  { Map < String ,  SortedSet < String >  >  loc0 = new TreeMap <  >  (  )  ;  loc0 . putAll ( arg0 )  ;  SortedSet < String >  loc1 = loc0 . get ( arg1 )  ;  if  ( loc1 == null )  { loc1 = new TreeSet <  >  (  )  ;  loc0 . put ( arg1 ,  loc1 )  ;  } loc1 . addAll ( arg2 )  ;  return loc0 ;  }
int function ( GroupValue obj )  { int hashCode = 0 ;  try { Map < String ,  Constant >  vals = obj . vals (  )  ;  Collection < Constant >  values = vals . values (  )  ;  for  ( Constant val : values )  { hashCode += val . hashCode (  )  ;  } } catch  ( Exception e )  { } return hashCode ;  }
int function ( int arg0 ,  int arg1 )  { return nextAvailableTile ( arg0 ,  arg1 )  ;  }
String function ( String arg0 )  { Element loc0 = getToken (  )  ;  String loc1 = loc0 . getAttribute ( "Id" )  ;  if  ( loc1 == null )  { loc1 = getWsuId (  )  ;  } String loc2 = arg0 + loc1 ;  return loc2 ;  }
void function ( String arg0 )  { try { loadedInCats = arg0 ;  } catch  ( Exception loc0 )  { System . out . println ( "Error setting loaded in cats: " + loc0 . getMessage (  )  )  ;  } }
public int function (  )  { int numDecisions = 0 ;  try { numDecisions = decisions ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting number of decisions: " + e . getMessage (  )  )  ;  } return numDecisions ;  }
String function ( Date arg0 )  { try { DateTimeFormat loc0 = DateTimeFormat . SQL ;  return formatUTC ( arg0 ,  loc0 ,  true )  ;  } catch  ( Exception loc1 )  { } return null ;  }
public int function (  )  { int loc0 = 0 ;  try { loc0 = mSize ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public void function ( double arg0 )  { try { Preferences prefs = Preferences . userRoot (  )  ;  double loc0 = prefs . getDouble ( "lastVersion" ,  0 . 0 )  ;  if  ( loc0 != arg0 )  { prefs . putDouble ( "lastVersion" ,  arg0 )  ;  } } catch  ( Exception e )  { Prefs . LOG . error ( "Failed to set last version" ,  e )  ;  } }
String function (  )  { String loc0 = null ;  try { if  ( server != null && server . getConnectors (  )  != null )  { for  ( Connector loc1 : server . getConnectors (  )  )  { if  ( loc1 instanceof ServerConnector )  { if  ( port == -1 ||  (  ( ServerConnector )  loc1 )  . getPort (  )  == port )  { loc0 =  (  ( ServerConnector )  loc1 )  . getHost (  )  ;  if  ( loc0 == null && host != null )  { loc0 = host ;  } break ;  } } } } } catch  ( Exception e )  { } return loc0 ;  }
void function ( RepositoryCommit commit )  { if  ( !commits . contains ( commit )  )  { commits . add ( commit )  ;  } }  @ Override public boolean equals ( Object obj )  { if  ( this == obj )  { return true ;  } if  ( obj == null || getClass (  )  != obj . getClass (  )  )  { return false ;  } RefLogEntry that =  ( RefLogEntry )  obj ;  return Objects . equals ( commits ,  that . commits )  && Objects . equals ( repository ,  that . repository )  && Objects . equals ( refUpdates ,  that . refUpdates )  && Objects . equals ( user ,  that . user )  && Objects . equals ( date ,  that . date )  && Objects . equals ( refIdChanges ,  that . refIdChanges )  ;  }  @ Override public int hashCode (  )  { return Objects . hash ( commits ,  repository ,  refUpdates ,  user ,  date ,  refIdChanges )  ;  }
void function (  )  { try { int loc0 = cal . get ( Calendar . MONTH )  ;  int loc1 = instance . getMonth (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } catch  ( Exception e )  { } }
TableInfo tableInfo = new TableInfo ( arg0 ,  arg1 )  ;  Schema schema = tableInfo . schema (  )  ;  int recordLength = schema . recordLength (  )  ;  HashIndex hashIndex = new HashIndex ( arg2 )  ;  int searchCost = hashIndex . searchCost ( recordLength )  ;  StatInfo si = tableInfo . getStats (  )  ;  int recordsOutput = si . recordsOutput (  )  ;  int blockSize = BufferManager . getBlockSize (  )  ;  int recordsPerBlock = blockSize / recordLength ;  int indexSize = tableInfo . getNumIndexPages (  )  * blockSize ;  int numIndexRecords = indexSize / recordLength ;  int numBlocks =  ( numIndexRecords + recordsPerBlock - 1 )  / recordsPerBlock ;  int traversalCost = hashIndex . traversalCost ( numBlocks )  ;  return traversalCost + searchCost + recordsOutput ; 
void function ( RuleContext arg0 ,  List < Node >  arg1 ,  Language arg2 )  { RuleChainVisitor loc0 = languageToRuleChainVisitor . get ( arg2 )  ;  loc0 . visitAll ( arg0 ,  arg1 )  ;  }
AddressPair function ( AddressPair arg0 )  { AddressPair . Builder loc0 = AddressPair . builder ( arg0 . getMacAddress (  )  ,  arg0 . getIpAddress (  )  )  ;  return loc0 . fromAddressPair ( arg0 )  . build (  )  ;  }
Element function ( String arg0 ,  String arg1 )  { Element loc0 = document . createElement ( "error" )  ;  Element loc1 = errorElement . getOwnerDocument (  )  . getDocumentElement (  )  ;  loc1 . appendChild ( loc0 )  ;  loc0 . setAttribute ( "code" ,  String . valueOf ( EN_ERROR )  )  ;  loc0 . setAttribute ( "message" ,  arg0 )  ;  if  ( arg1 != null && !arg1 . isEmpty (  )  )  { Element loc2 = document . createElement ( "details" )  ;  loc2 . appendChild ( document . createTextNode ( arg1 )  )  ;  loc0 . appendChild ( loc2 )  ;  } return loc0 ;  }
void function ( String arg0 )  { try { instanceName = arg0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
boolean function ( Combination arg0 )  { boolean loc0 = function ( arg0 )  ;  String loc1 = arg0 . toString (  )  ;  boolean loc2 = configurations . containsKey ( loc1 )  ;  boolean loc3 = configurations . get ( loc1 )  ;  return loc2 ? loc3 : true ;  }
void function ( boolean arg0 )  { progressMonitor . setConsoleModeAndParseShowProgress ( new String [  ] {String . valueOf ( arg0 ) } )  ;  }
String function ( String arg0 ,  String arg1 ,  StringBuilder loc0 )  { String loc1 = HTTPTransportUtils . getRawQueryStringParameter ( arg0 ,  arg1 )  ;  if  ( loc0 . length (  )   >  0 )  { loc0 . append ( "&" )  ;  } loc0 . append ( arg1 )  . append ( "=" )  . append ( loc1 )  ;  return loc1 ;  }
Object function ( String arg0 ,  Scriptable arg1 )  { if  ( "dim" . equals ( arg0 )  )  { return dim ;  } return Scriptable . NOT_FOUND ;  }
List function ( Object arg0 ,  Object arg1 )  { List loc0 = new Vector (  )  ;  try { List loc1 =  (  ( ParseState ) arg0 )  . getNewFeaturesList (  )  ;  List loc2 =  (  ( ParseState ) arg1 )  . getNewFeaturesList (  )  ;  for  ( Object loc3 : loc2 )  { if  ( !loc1 . contains ( loc3 )  )  { loc0 . add ( loc3 )  ;  } } } catch  ( Exception e )  { } return loc0 ;  }
ClassStats function ( String name )  { try { if  ( nestedClasses . containsKey ( name )  )  { return nestedClasses . get ( name )  ;  } } catch  ( Exception e )  { } return null ;  }
void function ( String arg0 )  { gene = arg0 ;  }
void function ( String arg0 )  { if  ( !containsLocation ( arg0 )  )  { addResourceLocation ( arg0 )  ;  } }
public void function ( Entry arg0 )  { try { if  ( mIsClosed )  { throw new IOException ( "Cannot write to a closed journal writer . " )  ;  } Journal . JournalFormatter loc0 = mJournal . getJournalFormatter (  )  ;  Entry . Builder loc1 = arg0 . toBuilder (  )  ;  loc1 . setSequenceNumber ( mNextEntrySequenceNumber )  ;  mNextEntrySequenceNumber ++  ;  loc0 . serialize ( loc1 . build (  )  ,  mDataOutputStream )  ;  mDataOutputStream . flush (  )  ;  mCheckpointOutputStream . flush (  )  ;  } catch  ( IOException e )  { LOG . error ( "Failed to write entry to the checkpoint file: " + e . getMessage (  )  )  ;  } }
boolean function ( byte arg0 )  { boolean [  ]  loc0 = HTTP_CONTROLS ;  return loc0 [ arg0 & 0x7F ]  ;  }
void function ( String arg0 ,  CookieSpecFactory arg1 )  { try { if  ( arg0 == null || arg1 == null )  { throw new IllegalArgumentException ( "Invalid arguments" )  ;  } String loc0 = arg0 . toLowerCase ( Locale . ENGLISH )  ;  registeredSpecs . put ( loc0 ,  arg1 )  ;  } catch  ( Exception e )  { } }
public void function ( BoundingBox arg0 ,  BoundingBox arg1 )  { float lonMax = Math . min ( arg0 . getLonMax (  )  ,  arg1 . getLonMax (  )  )  ;  float latMin = Math . max ( arg0 . getLatMin (  )  ,  arg1 . getLatMin (  )  )  ;  float lonMin = Math . max ( arg0 . getLonMin (  )  ,  arg1 . getLonMin (  )  )  ;  float latMax = Math . min ( arg0 . getLatMax (  )  ,  arg1 . getLatMax (  )  )  ;  arg0 . lonMax = lonMax ;  arg0 . latMin = latMin ;  arg0 . lonMin = lonMin ;  arg0 . latMax = latMax ;  } Note: This implementation assumes that the "BoundingBox" class has appropriate getters and setters for its member variables . 
public ExtensionMechanismsHelper function (  )  { return impl ;  } Note: It's worth mentioning that this method is not adding any new functionality to the class ,  but just exposing the private member variable "impl" . 
public static  < T >  GeneralRange < T >  function ( Comparator < ? super T >  arg0 ,  T arg1 ,  BoundType arg2 ,  T arg3 ,  BoundType arg4 )  { return new GeneralRange <  >  ( arg2 ,  true ,  arg1 ,  true ,  arg3 ,  null ,  arg0 ,  arg4 )  ;  }
void function ( InputStream arg0 ,  RuleSets arg1 ,  RuleContext arg2 )  { try { InputStreamReader loc0 = new InputStreamReader ( arg0 ,  configuration . getSourceEncoding (  )  )  ;  processSource ( loc0 ,  arg1 ,  arg2 )  ;  } catch  ( IOException e )  { throw new PMDException ( e . getMessage (  )  )  ;  } }
void function (  )  { try { String loc0 = "testClient" ;  List < ApprovedSite >  loc1 = new ArrayList <  >  (  )  ;  when ( repository . getByClientId ( loc0 )  )  . thenReturn ( loc1 )  ;  service . setClientId ( loc0 )  ;  service . clearApprovedSitesForClient (  )  ;  verify ( repository ,  never (  )  )  . remove ( any ( ApprovedSite . class )  )  ;  verify ( repository )  . getByClientId ( loc0 )  ;  verify ( statsService )  . recordApprovedSitesRemoved ( loc0 ,  0 )  ;  } catch  ( Exception e )  { fail ( "An exception was thrown: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 ,  String arg1 )  { try { String loc0 = "" ;  String loc1 = "" ;  mapping . put ( arg0 ,  arg1 )  ;  writer . setPrefix ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { throw new RuntimeException ( "Error occurred in function . " ,  e )  ;  } } Note: This method calls the "put" method on the "mapping" map to add a new key-value pair ,  and then it calls the "setPrefix" method on the "writer" XMLStreamWriter to set a namespace prefix .  It catches any exception that might occur during the execution of these methods and throws a new RuntimeException with an error message and the original exception as its cause . 
public class ProxyHelper { private static ProxyHelper HELPER ;  public static ProxyHelper getInstance (  )  { if  ( HELPER == null )  { HELPER = new ProxyHelper (  )  ;  } return HELPER ;  } public boolean canSeeAllInterfaces ( ClassLoader arg0 ,  Class < ? >  [  ]  arg1 )  { } public Object getProxyInternal ( ClassLoader arg0 ,  Class < ? >  [  ]  arg1 ,  InvocationHandler arg2 )  { } public Object getProxy ( ClassLoader arg0 ,  Class < ? >  [  ]  arg1 ,  InvocationHandler arg2 )  { } public ClassLoader function ( ClassLoader arg0 ,  Class < ? >  [  ]  arg1 )  { ClassLoader loc0 = null ;  if  ( canSeeAllInterfaces ( arg0 ,  arg1 )  )  { loc0 = arg0 ;  } else { ProxyClassLoader loc1 = new ProxyClassLoader (  )  ;  for  ( Class < ? >  cls : arg1 )  { loc1 . addLoader ( cls . getClassLoader (  )  )  ;  } loc0 = loc1 . getClassLoader (  )  ;  } return loc0 ;  } }
void function (  )  { try { BlockStoreContext loc0 = BlockStoreContext . get (  )  ;  byte [  ]  loc1 = BufferUtils . getIncreasingByteArray (  ( int ) BLOCK_LENGTH )  ;  mTestStream = new TestBufferedBlockOutStream ( loc0 ,  BLOCK_LENGTH )  ;  mThrown = ExpectedException . none (  )  ;  } catch  ( Exception loc2 )  { } }
public Constant function ( String field )  { Type fieldType = sch . type ( field )  ;  if  ( fieldType == Type . INTEGER )  { int value = rf . getInt ( field )  ;  return new IntConstant ( value )  ;  } else { String value = rf . getString ( field )  ;  return new StringConstant ( value )  ;  } }
NodeVisitor function ( Node arg0 )  { NodeVisitor loc0 = this ;  try { loc0 . enter ( arg0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
ThreadFactory function ( ThreadFactoryBuilder arg0 ,  ThreadFactory arg1 )  { try { Objects . requireNonNull ( arg1 )  ;  } catch  ( NullPointerException e )  { } arg0 . backingThreadFactory = arg1 ;  return arg0 . build (  )  ;  }
List < ClassdiagramNode >  function (  )  { List < ClassdiagramNode >  loc0 = new ArrayList < ClassdiagramNode >  (  )  ;  try { loc0 = new Vector <  >  ( downlinks )  ;  } catch  ( Exception e )  { } return loc0 ;  }
Long function ( TestResultDetailsDTO dto )  { return dto . testId ;  }
String function ( Object arg0 )  { Object loc0 = null ;  Object loc1 = null ;  if  ( arg0 instanceof SomeClass )  { loc0 =  (  ( SomeClass )  arg0 )  . getOwner (  )  ;  if  ( loc0 == null )  { loc0 = arg0 ;  } } else { loc0 = arg0 ;  } if  ( loc0 instanceof AnotherClass )  { loc1 =  (  ( AnotherClass )  loc0 )  . getUUID (  )  ;  } else { loc1 = loc0 ;  } return loc1 . getFacade (  )  . getUUID (  )  ;  }
long function ( String arg0 )  { String loc0 = StringUtils . isEmpty ( arg0 )  ? "0" : arg0 . trim (  )  ;  try { return FileUtils . convertSizeToLong ( loc0 )  ;  } catch  ( Exception e )  { logger . error ( "Failed to convert string to file size: " + loc0 ,  e )  ;  return 0 ;  } }
public String function ( String input )  { StringBuffer result = new StringBuffer (  )  ;  for  ( int i = 0 ;  i  <  input . length (  )  ;  i ++  )  { char ch = input . charAt ( i )  ;  if  (  ( ch  > = 'a' && ch  < = 'z' )  ||  ( ch  > = 'A' && ch  < = 'Z' )  ||  ( ch  > = '0' && ch  < = '9' )  || ch == '-' || ch == '_' || ch == ' . ' || ch == '!' || ch == '~' || ch == '\'' || ch == ' ( ' || ch == ' ) ' )  { result . append ( ch )  ;  } else if  ( ch == ' ' )  { result . append ( "+" )  ;  } else if  ( ch  < = 0x007f )  { result . append ( hex [ ch ]  )  ;  } else if  ( ch  < = 0x07FF )  { result . append ( hex [ 0xc0 |  ( ch  >  >  6 )  ]  )  ;  result . append ( hex [ 0x80 |  ( ch & 0x3F )  ]  )  ;  } else { result . append ( hex [ 0xe0 |  ( ch  >  >  12 )  ]  )  ;  result . append ( hex [ 0x80 |  (  ( ch  >  >  6 )  & 0x3F )  ]  )  ;  result . append ( hex [ 0x80 |  ( ch & 0x3F )  ]  )  ;  } } return result . toString (  )  ;  }
public Timestamp function (  )  { Timestamp loc0 = createdDate ;  return loc0 ;  }
ELEvaluator function ( Date arg0 ,  Configuration arg1 ,  String arg2 ,  Element arg3 )  { ELEvaluator loc0 = createInstancesELEvaluator ( arg0 ,  arg3 ,  arg1 )  ;  setConfigToEval ( loc0 ,  arg1 )  ;  loc0 . setVariable ( "actionId" ,  arg2 )  ;  return loc0 ;  }
QName function (  )  { return qname ;  }
void function ( TransformerFactory arg0 )  { try { factory = arg0 ;  } catch  ( Exception e )  { } }
int function (  )  { int loc0 = gen . getAndIncrement (  )  ;  int loc1 = mix ( salt + loc0 )  ;  return loc1 ;  }
void function ( Object arg0 ,  Object arg1 )  { Message message =  ( Message )  arg0 ;  Conduit conduit =  ( Conduit )  arg1 ;  NullConduitSelector loc0 = NullConduitSelector . this ;  loc0 . prepare ( message )  ;  Endpoint endpoint = loc0 . getEndpoint (  )  ;  conduit . close ( message )  ;  loc0 . setEndpoint ( endpoint )  ;  }
public Executor function (  )  { Executor loc0 = MoreExecutors . newThreadFactory ( serviceName (  )  )  . newThread ( arg0 )  ;  loc0 . start (  )  ;  return loc0 ;  }
public void function (  )  { try { RMBTest testObject = new RMBTest (  )  ;  String arg0 = "testOrigin" ;  testObject . setOriginId ( arg0 )  ;  assertTrue ( testObject . toString (  )  . contains ( arg0 )  )  ;  assertEquals ( arg0 ,  testObject . getOriginId (  )  )  ;  } catch  ( Exception e )  { } }
Object function ( String arg0 )  { Object loc0 = getContext (  )  . getClassifier (  )  ;  Collection loc1 = getFeatures ( "modelElementTag" )  ;  for  ( Object loc2 : loc1 )  { Object loc3 = loc2 . getAttribute ( "value" )  ;  if  ( loc3 != null && arg0 . equals ( loc3 . toString (  )  )  )  { return Model . getFacade (  )  . getName ( loc2 )  ;  } } return null ;  }
void function ( AbstractDosPlugin arg0 )  { AbstractDosPlugin loc0 = arg0 ;  loc0 . getVersion (  )  ;  }
Object function ( Object arg0 ,  String arg1 )  { for  ( Object loc0 : obsoleteFeatures )  { if  ( loc0 . equals ( arg1 )  )  { return null ;  } } Object loc1 = Model . getFacade (  )  . isAAttribute ( arg0 )  ;  if  ( loc1 != null && loc1 . getName (  )  . equals ( arg1 )  )  { return loc1 ;  } return null ;  }
Timestamp function (  )  { return endDate ;  }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 )  { String query = "" ;  try { query = String . format ( "MERGE-WITH GRAPH  < %s >  DEFAULT %s  < %s > " ,  arg0 ,  arg2 ,  arg1 )  ;  } catch  ( Exception e )  { System . out . println ( "Error occurred while creating MERGE-WITH query: " + e . getMessage (  )  )  ;  } return query ;  }
public String function (  )  { try { return this . applicationDescription ;  } catch  ( Exception e )  { return null ;  } }
void function (  )  { setUp (  )  ;  instance . setVerticalDOP ( 1 . 0 )  ;  assertEquals ( 1 . 0 ,  instance . getVerticalDOP (  )  ,  0 . 0 )  ;  }
String function ( String arg0 ,  String arg1 )  { AuthorizationCodeGrant loc0 = new AuthorizationCodeGrant (  )  ;  loc0 . setRedirectUri ( arg0 )  ;  loc0 . setCode ( arg1 )  ;  return loc0 . getType (  )  ;  }
void function (  )  { int arg0 = 30 ;  Time loc0 = new Time ( 10 ,  20 ,  30 )  ;  try { loc0 . setMinutes ( arg0 )  ;  int loc1 = loc0 . getMinutes (  )  ;  assertEquals ( arg0 ,  loc1 )  ;  } catch  ( Exception e )  { fail ( "Exception not expected: " + e . getMessage (  )  )  ;  } }
SignatureProperties function (  )  { return signatureProperties . getSignatureProperties (  )  ;  }
public long function ( K key ,  long x ,  LongBinaryOperator accumulatorFunction )  { Objects . requireNonNull ( key )  ;  Objects . requireNonNull ( accumulatorFunction )  ;  return map . compute ( key ,   ( k ,  v )  - >  v == null ? x : accumulatorFunction . applyAsLong ( v ,  x )  )  ;  }
void function ( Object arg0 ,  Object arg1 )  { Object loc0 = createModelElement ( arg0 )  ;  setElementName ( loc0 ,  arg1 )  ;  initializeModelElement ( loc0 )  ;  }
public static Method function ( Class < ? >  arg0 ,  String arg1 ,  Class < ? >  .  .  .  arg2 )  { try { return arg0 . getMethod ( arg1 ,  arg2 )  ;  } catch  ( NoSuchMethodException loc0 )  { throw new RuntimeException ( loc0 )  ;  } }
void function ( String arg0 ,  Exception arg1 )  { try { String loc0 = getContent ( getCurrentStackTraceElement (  )  )  ;  Log . e ( loc0 ,  arg0 )  ;  String loc1 = arg1 . getMessage (  )  ;  StackTraceElement [  ]  loc2 = arg1 . getStackTrace (  )  ;  arg1 . printStackTrace (  )  ;  } catch  ( Exception loc3 )  { Log . e ( getTagContentPrint (  )  ,  "Failed to send ERROR log message: " + loc3 . getMessage (  )  )  ;  } }
void function ( String arg0 ,  String arg1 )  { OpenTagRegister tagList = new OpenTagRegister (  )  ;  int elmId = 0 ;  ASTElement loc0 = element ( arg0 )  ;  tagList . openTag ( loc0 )  ;  ASTElement loc1 = element ( arg1 )  ;  tagList . openTag ( loc1 )  ;  tagList . closeTag ( loc1 )  ;  tagList . closeTag ( loc0 )  ;  assertFalse ( tagList . isUnclosed (  )  )  ;  assertTrue ( tagList . toString (  )  . isEmpty (  )  )  ;  }
void function ( String arg0 )  { this . srcFileName = arg0 ;  }
IConfigurationFactory function (  )  { return SINGLETON . getConfigurationHandler (  )  ;  }
boolean function (  )  { boolean loc0 = false ;  if  ( s2 . hasField ( "field_name" )  && s1 . hasField ( "field_name" )  )  { String loc1 = s2 . getString ( "field_name" )  ;  Constant loc2 = s1 . getVal ( "field_name" )  ;  if  ( loc2 . getInt (  )   >  0 && loc1 . equals ( "string_value" )  )  { loc0 = true ;  } } if  ( !loc0 )  { s2 . next (  )  ;  if  ( s2 . hasField ( "field_name" )  )  { return function (  )  ;  } else { s2 . beforeFirst (  )  ;  s1 . next (  )  ;  if  ( s1 . hasField ( "field_name" )  )  { s2 . next (  )  ;  return function (  )  ;  } else { return false ;  } } } else { return true ;  } }
public V function (  )  { V value = getValue (  )  ;  return value ;  }
public int function (  )  { try { return xPosition ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting horizontal position: " + e . getMessage (  )  )  ;  return -1 ;  } }
int function ( byte [  ]  arg0 )  { int loc0 = arg0 . length ;  return loc0 ;  }
void function ( Collection arg0 )  { try { if  ( CollectionUtils . exists ( arg0 ,  PredicateUtils . nullPredicate (  )  )  )  { throw new NullPointerException (  )  ;  } } catch  ( Exception e )  { } }
void function (  )  { long loc0 = -22 ;  long loc1 = 11 ;  long loc2 = 33 ;  RPCFileReadRequest req = new RPCFileReadRequest ( loc1 ,  loc0 ,  loc2 )  ;  assertInvalid ( req )  ;  }
boolean function ( char arg0 )  { if  ( tok . ttype == arg0 )  { nextToken (  )  ;  return true ;  } return false ;  }
void function ( boolean arg0 ,  String arg1 )  { try { Assert . isTrue ( arg0 ,  arg1 )  ;  } catch  ( IllegalArgumentException loc0 )  { throw new IllegalArgumentException ( loc0 . getMessage (  )  )  ;  } }
void function (  )  { Whitebox . setInternalState ( LoginUser . class ,  "srini_string" ,   ( String ) null )  ;  }
List < T >  function ( List < T >  arg0 )  { List < T >  loc0 ;  try { loc0 = arg0 != null ? arg0 : Collections . emptyList (  )  ;  } catch  ( NullPointerException e )  { loc0 = Collections . emptyList (  )  ;  } return loc0 ;  }
public static URI function ( URI arg0 ,  HttpHost arg1 )  { URI loc0 = null ;  try { loc0 = URIUtils . rewriteURI ( arg0 ,  arg1 ,  true )  ;  } catch  ( URISyntaxException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function (  )  { try { mListeners . clear (  )  ;  } catch  ( Exception e )  { } }
public static JavascriptRuntime function (  )  { if  ( instance == null )  { JavascriptRuntime loc0 = new JavascriptRuntime (  )  ;  instance = loc0 . runtime ;  } return instance ;  }
Date function (  )  { return serverStatus . bootDate ;  }
public void function ( String arg0 )  { try { name = arg0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { try { double loc0 = hdg . getVariation (  )  ;  assertEquals ( 0 . 0 ,  loc0 ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
StoredPaymentChannelClientStates function ( Wallet arg0 )  { return  ( StoredPaymentChannelClientStates )  arg0 . getExtensions (  )  . get ( StoredPaymentChannelClientStates . class . getName (  )  )  ;  }
void function (  )  { Cache < K ,  V >  loc0 = getOpenIDCache (  )  ;  loc0 . removeAll (  )  ;  }
void function ( String arg0 )  { loginName = arg0 ;  }
void function (  )  { assertEquals ( Datum . WGS84 ,  instance . getDatum (  )  )  ;  }
void function ( Source arg0 )  { arg0 . setSystemId ( arg0 != null && arg0 . getSystemId (  )  != null && arg0 . getSystemId (  )  . length (  )   >  0 ? arg0 . getSystemId (  )  : getDefaultSystemId (  )  )  ;  }
List function ( Object arg0 )  { List loc0 = new ArrayList (  )  ;  List loc1 =  (  ( ParseState ) arg0 )  . getNewFeatures (  )  ;  for  ( Object loc2 : loc1 )  { if  ( ! (  ( ParseState ) arg0 )  . getAssociationEndsList (  )  . contains ( loc2 )  )  { loc0 . add ( loc2 )  ;  } } return loc0 ;  }
void function ( OpenIDRememberMeDO arg0 )  { cache . updateTokenData ( arg0 )  ;  Thread loc0 = new Thread (  )  {  @ Override public void run (  )  { try { dao . updateTokenData ( arg0 )  ;  } catch  ( Exception e )  { log . error ( "srini_string" ,  e )  ;  } } } ;  loc0 . start (  )  ;  }
void function ( ServerSocket serverSocket )  { serverSocket . close (  )  ;  }
public void function ( int arg0 )  { try { setLane_id ( arg0 )  ;  } catch  ( Exception e )  { System . out . println ( "Error setting lane_id: " + e . getMessage (  )  )  ;  } }
void function ( MapNode arg0 )  { try { Long loc0 = arg0 . getId (  )  ;  nodes . put ( loc0 ,  arg0 )  ;  } catch  ( Exception loc1 )  { LOG . warning ( "Error adding node to hashtable: " + loc1 . getMessage (  )  )  ;  } }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 ,  String arg7 ,  String arg8 )  { CommitModel loc0 = new CommitModel ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 ,  arg6 ,  arg7 ,  arg8 )  ;  String loc1 = loc0 . toString (  )  ;  return loc1 ;  }
void function ( String arg0 )  { System . out . println ( "Test method for { @ link com . sqa . em . util . helper . RequestInput#getChar ( java . lang . String ) } . " )  ;  char loc0 = RequestInputTest . getChar ( arg0 )  ;  System . out . println ( loc0 )  ;  }
boolean function ( String arg0 )  { File loc0 = new File ( arg0 )  ;  return config . load ( loc0 )  ;  }
void function ( List < Interceptor < ? extends Message >  >  arg0 )  { inInterceptors = new ModCountCopyOnWriteArrayList <  >  ( arg0 )  ;  }
void function ( ConfigurationKey arg0 ,  boolean arg1 )  { try { getFactory (  )  . getConfigurationHandler (  )  . setBoolean ( arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { } }
String function ( TrustedCertificateEntry arg0 )  { String loc0 = "" ;  try { String subjectPrimary = arg0 . getSubjectPrimary (  )  ;  if  ( subjectPrimary . startsWith ( "O=" )  )  { List < String >  subjectAltNames = arg0 . getSubjectAltNames (  )  ;  for  ( String subjectAltName : subjectAltNames )  { if  ( subjectAltName . startsWith ( "CN=" )  )  { loc0 = subjectAltName . substring ( 3 )  ;  break ;  } else if  ( subjectAltName . startsWith ( "OU=" )  )  { loc0 = subjectAltName . substring ( 3 )  ;  break ;  } } } } catch  ( Exception e )  { } return loc0 ;  }
Object function ( Object arg0 ,  Object arg1 )  { DeadEvent event =  ( DeadEvent )  arg0 ;  return event . source ;  }
class DELETE { void function ( String arg0 ,  int arg1 )  { try { int loc0 = Integer . parseInt ( arg0 )  ;  int result = loc0 * arg1 ;  System . out . println ( "Result: " + result )  ;  } catch  ( Exception e )  { System . out . println ( "Error occurred: " + e . getMessage (  )  )  ;  } } }
void function ( AuthenticationRequest arg0 ,  String arg1 )  { arg0 . setTenantDomain ( arg1 )  ;  }
public void function (  )  { StorageDirView loc0 = new StorageDirView ( mTestDir ,  mTestTierView )  ;  long loc1 = mTestDir . getCapacityBytes (  )  ;  long loc2 = loc0 . getCapacityBytes (  )  ;  assertEquals ( loc1 ,  loc2 )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = PersistenceManager . getInstance (  )  . getProjectBaseName (  )  ;  String loc1 = arg0 . endsWith ( " . " )  ? arg0 . substring ( 0 ,  arg0 . length (  )  - 1 )  : arg0 ;  loc1 = loc1 . substring ( loc1 . lastIndexOf ( "/" )  + 1 )  ;  loc1 = loc1 . substring ( loc1 . lastIndexOf ( "\\" )  + 1 )  ;  loc1 = loc1 . replace ( " " ,  "_" )  ;  loc1 = loc1 . replaceAll ( " [ ^\\w\\d_ ] " ,  "" )  ;  loc1 = loc1 . replaceAll ( " [ ^\\w\\d_ ] " ,  "" )  ;  return loc0 + "_" + loc1 + arg1 ;  }
void function ( int arg0 )  { peakStart = arg0 ;  }
void function ( long arg0 ,  long arg1 ,  BlockLockType arg2 )  { mLockManager . lockBlock ( arg0 ,  arg1 ,  arg2 )  ;  long loc0 = mLockManager . getLockIdForBlock ( arg0 )  ;  long loc1 = mLockManager . getSessionIdForLock ( loc0 )  ;  assertNotEquals ( arg1 ,  loc1 )  ;  }
Here's the modified method: ```java public static String function ( String arg0 )  { int loc0 = arg0 . length (  )  ;  int [  ]  loc1 = new int [  ( loc0  >  >  2 )  +  (  ( loc0 & 3 )  == 0 ? 0 : 1 )  ]  ;  for  ( int loc2 = 0 ;  loc2  <  loc0 ;  loc2 ++  )  { loc1 [ loc2  >  >  2 ]  |=  ( arg0 . charAt ( loc2 )  & 0xFF )   <  <   (  ( 3 -  ( loc2 & 3 )  )   <  <  3 )  ;  } if  (  ( loc0 & 3 )  != 0 )  { loc1 [ loc1 . length - 1 ]  |= 0x80  <  <   (  ( 3 -  ( loc0 & 3 )  )   <  <  3 )  ;  } else { loc1 [ loc1 . length - 1 ]  |= 0x80000000 ;  } int loc2 = loc1 . length ;  int loc3 = 0 ;  int [  ]  loc4 = new int [ 80 ]  ;  int loc5 ,  loc6 ,  loc7 ,  loc8 ,  loc9 ;  int loc10 ,  loc11 ,  loc12 ,  loc13 ,  loc14 ;  int loc15 = 1732584193 ;  int loc16 = -271733879 ;  int loc17 = -1732584194 ;  int loc18 = 271733878 ;  int loc19 = -1009589776 ;  for  (  ;  loc3  <  loc2 ;  loc3 += 16 )  { loc5 = loc15 ;  loc6 = loc16 ;  loc7 = loc17 ;  loc8 = loc18 ;  loc9 = loc19 ;  for  ( loc10 = 0 ;  loc10  <  80 ;  loc10 ++  )  { if  ( loc10  <  16 )  { loc4 [ loc10 ]  = loc1 [ loc3 + loc10 ]  ;  } else { loc4 [ loc10 ]  =  ( loc4 [ loc10 - 3 ]  ^ loc4 [ loc10 - 8 ]  ^ loc4 [ loc10 - 14 ]  ^ loc4 [ loc10 - 16 ]  )  ;  } loc11 =  (  ( loc5  <  <  5 )  |  ( loc5  >  >  >  27 )  )  + loc9 + loc4 [ loc10 ]  +  (  ( loc10  <  20 )  ? 1518500249 +  (  ( loc6 & loc7 )  |  (  ( ~loc6 )  & loc8 )  )  :  ( loc10  <  40 )  ? 1859775393 +  ( loc6 ^ loc7 ^ loc8 )  :  ( loc10  <  60 )  ? -1894007588 +  (  ( loc6 & loc7 )  |  ( loc6 & loc8 )  |  ( loc7 & loc8 )  )  : -899497514 +  ( loc6 ^ loc7 ^ loc8 )  )  ;  loc9 = loc8 ;  loc8 = loc7 ;  loc7 =  (  ( loc6  <  <  30 )  |  ( loc6  >  >  >  2 )  )  ;  loc6 = loc5 ;  loc5 = loc11 ;  } loc15 += loc5 ;  loc16 += loc6 ;  loc17 += loc7 ;  loc18 += loc8 ;  loc19 += loc9 ;  } StringBuilder loc20 = new StringBuilder (  )  ;  for  ( loc3 = 0 ;  loc3  <  4 ;  loc3 ++  )  { loc20 . append ( CHARS [  ( loc15  >  >   (  ( 3 - loc3 )   <  <  3 )  )  & 0xFF ]  )  ;  loc20 . append ( CHARS [  ( loc16  >  >   (  ( 3 - loc3 )   <  <  3 )  )  & 0xFF ]  )  ;  loc20 . append ( CHARS [  ( loc17  >  >   (  ( 3 -
void function (  )  { assertTrue ( arg0 )  ;  assertTrue ( mwv . isTrue (  )  )  ;  mwv . setTrue (  )  ;  assertFalse ( arg1 )  ;  assertFalse ( mwv . isTrue (  )  )  ;  }
int function ( CacheConfig obj )  { return obj . maxUpdateRetries (  )  ;  }
public void function ( int arg0 )  { int [  ]  loc0 ;  if  ( playerList . containsKey ( arg0 )  )  { loc0 = playerList . get ( arg0 )  ;  loc0 [ 0 ]  ++  ;  } else { loc0 = new int [  ] {1} ;  playerList . put ( arg0 ,  loc0 )  ;  } }
void function ( long arg0 ,  RabbitMQMessage message )  { message . setDeliveryTag ( arg0 )  ;  }
StoredClientChannel function ( Sha256Hash arg0 ,  Sha256Hash arg1 )  { lock . lock (  )  ;  try { Set < StoredClientChannel >  loc0 = mapChannels . get ( arg0 )  ;  for  ( StoredClientChannel loc1 : loc0 )  { if  ( loc1 . contract . getHash (  )  . equals ( arg1 )  )  { return loc1 ;  } } return null ;  } finally { lock . unlock (  )  ;  } }
void function ( View arg0 ,  int arg1 ,  Object arg2 )  { try { destroyItem ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception e )  { } }
void function ( ExceptionListener arg0 )  { exceptionListener = arg0 ;  }
void function (  )  { model . triggerEvent (  )  ;  }
String function (  )  { String loc0 = this . caseId ;  return loc0 ;  } Note: This method returns the case ID of the instance of GeneticEventImpl class it is called upon .  It doesn't take any arguments . 
int function ( String path )  { if  ( isWindows (  )  )  { throw new UnsupportedOperationException (  )  ;  } Filestat stat = getFilestat ( path )  ;  return stat . st_mode & 07777 ;  }
String function ( int arg0 )  { String loc0 = new String ( Character . toChars ( arg0 )  )  ;  EaseEmojicon [  ]  loc1 = EaseEmojicon . getEmojicons (  )  ;  for  ( EaseEmojicon loc2 : loc1 )  { if  ( loc2 . getEmojiText (  )  . equals ( loc0 )  )  { return loc2 . getEmojiText (  )  ;  } } return null ;  }
public double [  ]  function ( int arg0 )  { try { if  ( arg0  <  1 || arg0  >  dimension )  { throw new IllegalArgumentException ( "Invalid dimension" )  ;  } double [  ]  loc0 = new double [ arg0 ]  ;  for  ( int i = 0 ;  i  <  arg0 ;  i ++  )  { loc0 [ i ]  = coordinates [ i ]  ;  } return loc0 ;  } catch  ( IllegalArgumentException e )  { System . err . println ( e . getMessage (  )  )  ;  return null ;  } }
void function ( String arg0 )  { try { checksumType = arg0 ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  return "Error setting checksum type" ;  } }
Set < T >  function ( Class < T >  arg0 ,  Set < T >  arg1 )  { Set < T >  loc0 = new HashSet <  >  (  )  ;  for  ( T loc1 : arg1 )  { if  ( loc1 . getClass (  )  . equals ( arg0 )  )  { loc0 . add ( loc1 )  ;  } } return loc0 ;  }
void function (  )  { int arg0 = -1 ;  RTETest rteTest = new RTETest (  )  ;  try { rteTest . setSentenceCount ( arg0 )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException e )  { assertEquals ( "Sentence count cannot be negative" ,  e . getMessage (  )  )  ;  } int loc0 = 5 ;  rteTest . setSentenceCount ( loc0 )  ;  int loc1 = rteTest . getSentenceCount (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  }
void function ( Crypto arg0 )  { this . encryptionCrypto = arg0 ;  }
public int function ( int arg0 ,  int arg1 )  { int utility = 0 ;  try { MatrixPosition position = new MatrixPosition ( arg0 ,  arg1 )  ;  utility = matrixItemUtility ( position )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting utility: " + e . getMessage (  )  )  ;  } return utility ;  } private int matrixItemUtility ( MatrixPosition loc0 )  { int utility = 0 ;  try { int [  ]  itemNames = getItemNames (  )  ;  for  ( int i = 0 ;  i  <  itemNames . length ;  i ++  )  { int remainingUtility = getRemainingUtility ( loc0 . getRow (  )  ,  loc0 . getColumn (  )  )  ;  int localSequenceUtility = getLocalSequenceUtility ( loc0 )  ;  utility += remainingUtility * localSequenceUtility ;  } } catch  ( Exception e )  { System . err . println ( "Error occurred while calculating utility: " + e . getMessage (  )  )  ;  } return utility ;  }
public void function ( String arg0 ,  IndividualStructure arg1 )  { try { if  ( individualStructures . containsKey ( arg0 )  )  { System . out . println ( "Overwriting existing individual structure with identifier: " + arg0 )  ;  } individualStructures . put ( arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Error adding individual structure: " + loc0 . getMessage (  )  )  ;  } }
Context function (  )  { Context loc0 = context . get (  )  ;  loc0 . setFunctions ( evaluator . getFunctions (  )  )  ;  loc0 . setVariables ( vars )  ;  return loc0 ;  }
SDDTripleStateEnum function (  )  { return tripleStateA ;  }
void function ( String domainName ,  PropertyDTO [  ]  properties )  { Map < String ,  String >  userStoreManager = convertArrayToMap ( properties )  ;  userStoreManagers . put ( domainName ,  userStoreManager )  ;  }
void function ( JavaMailSender arg0 )  { mailSender = arg0 ;  } This method sets the member variable "mailSender" to the value passed as the argument "arg0" .  It does not handle any exceptions that may occur during this operation . 
public void function ( Scriptable arg0 ,  ClassCache arg1 )  { arg0 . getParentScope (  )  . associateValue ( ClassCache . AKEY ,  arg1 )  ;  }
void function ( Bus arg0 )  { if  ( arg0 != null )  { bus = arg0 ;  } }
void function (  )  { DenseMatrix64F loc0 = new DenseMatrix64F ( 3 ,  4 )  ;  int loc1 = loc0 . getNumCols (  )  ;  int loc2 = loc0 . getNumRows (  )  ;  assertEquals ( 3 ,  loc1 )  ;  assertEquals ( 4 ,  loc2 )  ;  }
void function (  )  { try { String example = "$GPRMC , 120044 . 567 , A , 6011 . 552 , N , 02501 . 941 , E , 000 . 0 , 360 . 0 , 160705 , 006 . 1 , E , A*0B" ;  RMCParser rmc = new RMCParser ( example )  ;  int loc0 = rmc . getYear (  )  ;  Date loc1 = rmc . getDate (  )  ;  assertEquals ( loc0 ,  loc1 . getYear (  )  + 1900 )  ;  } catch  ( Exception e )  { } }
void function ( String arg0 )  { setName ( arg0 )  ;  }
public List < Role >  function (  )  { List < Role >  loc0 = null ;  try { loc0 = this . roles ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( String arg0 )  { try { referencedRevisionA = arg0 ;  } catch  ( Exception e )  { } }
void function ( IParserEvent arg0 ,  IParserEventHandler arg1 )  { loc0 . handleEvent ( arg0 )  ;  handlerStack . push ( arg1 )  ;  }
BigDecimal function (  )  { return downloadSize ;  }
public void function ( DenseMatrix64F arg0 ,  EigenvalueExtractor arg1 )  { try { DenseMatrix64F H = new DenseMatrix64F ( arg0 . numRows ,  arg0 . numCols )  ;  H . set ( arg0 )  ;  RealEigenvalueSolver_DDRM solver = new RealEigenvalueSolver_DDRM ( H . numRows ,  true )  ;  for  ( int i = 0 ;  i  <  H . numCols - 1 ;  i ++  )  { if  ( H . unsafe_get ( i + 1 ,  i )  == 0 . 0 )  { continue ;  } double [  ]  qr = UnrolledImplicitQr_DDRM . computeShift ( H ,  i ,  arg1 )  ;  double realShift = qr [ 0 ]  ;  double imagShift = qr [ 1 ]  ;  if  ( qr [ 2 ]  == 0 . 0 )  { continue ;  } DenseMatrix64F Q = SpecializedOps_DDRM . identity ( H . numRows )  ;  UnrolledImplicitQr_DDRM . performImplicitSingleStep ( H ,  i ,  realShift ,  imagShift ,  Q ,  0 ,  H . numRows - 1 ,  null )  ;  UnrolledImplicitQr_DDRM . performImplicitSingleStep ( Q ,  i ,  realShift ,  imagShift ,  null ,  0 ,  H . numRows - 1 ,  null )  ;  } process ( H )  ;  double [  ]  eigenvalues = new double [ arg0 . numRows ]  ;  int numEigen = EigenOps_DDRM . extractRealEigenvalues ( H ,  eigenvalues )  ;  if  ( numEigen != arg0 . numRows )  { numCantFindEigenvector ++  ;  } DenseMatrix64F v = new DenseMatrix64F ( arg0 . numRows ,  1 )  ;  for  ( int i = 0 ;  i  <  numEigen ;  i ++  )  { double val = eigenvalues [ i ]  ;  if  ( isAllComplex (  )  && val == 0 . 0 )  { continue ;  } DenseMatrix64F A = new DenseMatrix64F ( arg0 . numRows ,  arg0 . numCols )  ;  CommonOps_DDRM . sub ( arg0 ,  CommonOps_DDRM . identity ( arg0 . numRows ,  arg0 . numCols )  ,  A )  ;  CommonOps_DDRM . scale ( val ,  v )  ;  CommonOps_DDRM . subtract ( A ,  v ,  A )  ;  CommonOps_DDRM . solve ( H ,  A ,  v )  ;  double error = computeError ( A ,  v ,  val )  ;  assertEquals ( 0 ,  error ,  tol )  ;  } } catch  ( Exception e )  { System . err . println ( "Unexpected exception: " + e . getMessage (  )  )  ;  e . printStackTrace (  )  ;  } }
void function ( AbstractSettings arg0 )  { try { PROPS . add ( arg0 )  ;  } catch  ( Exception e )  { } }
void function (  )  { events . removeLast (  )  ;  StringEvent loc0 = new StringEvent (  )  ;  loc0 . getString (  )  ;  events . add ( loc0 )  ;  }
boolean function (  )  { try { Date loc0 = new Date (  )  ;  return loc0 . after ( getTimeoutDate (  )  )  ;  } catch  ( Exception e )  { } return false ;  }
NameValuePair function ( final String arg0 ,  final String arg1 )  { try { return new BasicNameValuePair ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { return null ;  } }
public static String function ( byte [  ]  arg0 ,  String arg1 )  { try { return new String ( arg0 ,  arg1 )  ;  } catch  ( UnsupportedEncodingException loc0 )  { throw new RuntimeException ( "Use this function instead of new String ( byte [  ]  ,  String )  to avoid surprises from non-standard default encodings . " ,  loc0 )  ;  } }
void function ( short arg0 )  { byte loc0 =  ( byte )  arg0 ;  checkType ( 's' )  ;  packLong (  ( long )  loc0 ,  true )  ;  }
EmailTemplateDTO function ( int arg0 )  { try { EmailTemplateDTO loc0 = templates [ arg0 ]  ;  return loc0 . function (  )  ;  } catch  ( IndexOutOfBoundsException e )  { System . out . println ( "This method is used to get the email template to be displayed with the given index . " )  ;  return null ;  } }
public static JSONArray function ( List < JsonWorkflowAction >  actions )  { JSONArray array = new JSONArray (  )  ;  for  ( JsonWorkflowAction action : actions )  { array . add ( action . toJSONObject (  )  )  ;  } return array ;  }
Class < ? >  function ( String arg0 )  { Class < ? >  loc0 = COLLECTION_CLASSES_BY_NAMES . typeFor ( arg0 )  ;  if  ( loc0 != null )  { return loc0 ;  } return COLLECTION_INTERFACES_BY_NAMES . typeFor ( arg0 )  ;  }
EndpointReferenceType function ( QName arg0 )  { EndpointReferenceType loc0 = null ;  for  ( EndpointResolver loc1 : resolvers )  { loc0 = loc1 . resolve ( arg0 )  ;  if  ( loc0 != null )  { break ;  } } return loc0 ;  }
static void function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { checkBoundary ( arg0 ,  arg1 ,  4 )  ;  arg0 [ arg1 ]  =  ( byte )   ( arg2 & 0xff )  ;  arg0 [ arg1 + 1 ]  =  ( byte )   (  ( arg2  >  >  8 )  & 0xff )  ;  arg0 [ arg1 + 2 ]  =  ( byte )   (  ( arg2  >  >  16 )  & 0xff )  ;  arg0 [ arg1 + 3 ]  =  ( byte )   (  ( arg2  >  >  24 )  & 0xff )  ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole ( "Spin 90 Left" )  ;  loc0 . setLedsAnimation ( 1 ,  1 ,  5 )  ;  loc0 . spinLeft (  )  ;  loc0 . doFor ( loc0 . spin90Time )  ;  loc0 . hover (  )  ;  }
Measurements function ( Object arg0 ,  boolean arg1 )  { if  ( singleton == null )  { singleton = new Measurements (  )  ;  singleton . setProperties ( _props )  ;  } return singleton ;  }
public void function ( Marshaller arg0 ,  boolean arg1 )  { marshaller = arg0 ;  userObjectFactory = arg1 ;  }
void function ( List < String >  arg0 )  { acceptedKeyWrapAlgorithms = new ArrayList <  >  ( arg0 )  ;  }
public static boolean function ( String arg0 ,  String arg1 )  { boolean authenticated = false ;  try { UserRealm userRealm = IdentityTenantUtil . getRealm ( null ,  arg0 )  ;  UserStoreManager userStoreManager = userRealm . getUserStoreManager (  )  ;  authenticated = userStoreManager . authenticate ( arg1 . getBytes (  )  )  ;  } catch  ( UserStoreException e )  { log . error ( "Error while verifying user name/password authentication" ,  e )  ;  } return authenticated ;  }
synchronized boolean function ( long arg0 )  { Map < Long ,  Long >  loc0 = mPersistingInProgressFiles . get ( arg0 )  ;  return loc0 != null && !loc0 . isEmpty (  )  ;  }
LinearSolver < AdjLinearSolverQr < DenseMatrix64F >  >  function ( int arg0 ,  boolean arg1 )  { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 ,  arg0 )  ;  return new AdjustableLinearSolver <  >  (  new AdjLinearSolverQr <  >  ( loc0 )  ,  arg1 )  ;  }
class SimpleEndpointImplFactory { private static final EndpointImplFactory singleton = new SimpleEndpointImplFactory (  )  ;  public static EndpointImplFactory function (  )  { return singleton ;  } EndpointImpl newEndpointImpl ( Bus arg0 ,  Service arg1 ,  EndpointInfo arg2 )  { } }
void function (  )  { mThrown . expect ( IndexOutOfBoundsException . class )  ;  mThrown . expectMessage ( "Index: 9999 ,  Size: 1" )  ;  try { int loc0 = 9999 ;  StorageTierView loc1 = mTestTierView . getDirView ( loc0 )  ;  } catch  ( IndexOutOfBoundsException e )  { String [  ]  loc2 = TieredBlockStoreTestUtils . TIER_PATH ;  int loc3 = TEST_TIER_LEVEL ;  String loc4 = loc2 [ loc3 ]  ;  String loc5 = String . format ( "Index: %d ,  Size: %d" ,  9999 ,  1 )  ;  assertEquals ( loc5 ,  e . getMessage (  )  )  ;  } }
int function ( Map < ? ,  ? >  arg0 )  { return arg0 == null || arg0 . size (  )  == 0 ? 1 : 0 ;  }
List < T >  function ( Class < T >  arg0 )  { List < T >  loc0 = new ArrayList <  >  (  )  ;  Node loc1 = jjtGetParent (  )  ;  while  ( loc1 != null )  { if  ( loc1 . getClass (  )  == arg0 )  { loc0 . add (  ( T )  loc1 )  ;  } loc1 = loc1 . jjtGetParent (  )  ;  } return loc0 ;  }
int function ( int arg0 )  { UnsignedInts . checkArgument ( arg0  > = 0 ,  "input is negative: %s" ,  arg0 )  ;  return arg0 ;  }
public void function ( double [  ]  arg0 ,  double [  ]  [  ]  arg1 ,  int n )  { double [  ]  loc0 = new double [ n ]  ;  for  ( int i = n - 1 ;  i  > = 0 ;  i --  )  { double sum = 0 . 0 ;  for  ( int j = i + 1 ;  j  <  n ;  j ++  )  { sum += arg1 [ i ]  [ j ]  * loc0 [ j ]  ;  } loc0 [ i ]  =  ( arg0 [ i ]  - sum )  / arg1 [ i ]  [ i ]  ;  } for  ( int i = 0 ;  i  <  n ;  i ++  )  { arg0 [ i ]  = loc0 [ i ]  ;  } } This function performs a forward substitution to solve a non-singular upper triangular matrix equation of the form Ux = b ,  where U is an n by n matrix and b is a vector .  It takes in two arguments: an array of doubles  ( arg0 )  representing the vector b ,  a two-dimensional array of doubles  ( arg1 )  representing the matrix U ,  and an integer  ( n )  representing the dimension of the matrix and vector .  The function initializes a local double array  ( loc0 )  of length n to store the solution vector .  It then performs a forward substitution by looping through the rows of the matrix U in reverse order .  For each row i ,  it computes the sum of the products of the entries in that row and the corresponding entries in the solution vector loc0 ,  starting from the  ( i+1 ) th column .  It then subtracts this sum from the ith entry in the vector b ,  and divides by the diagonal entry in the ith row of the matrix U to obtain the ith entry in the solution vector .  Finally ,  the function assigns the values in loc0 back to the input array arg0 to update the solution vector . 
boolean function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  return loc0 != null && !loc0 . equals ( "" )  && !loc0 . startsWith ( "//" )  ;  }
public DeterministicKey function ( List < ChildNumber >  arg0 ,  boolean arg1 ,  boolean arg2 )  { return get ( arg0 ,  arg1 ,  arg2 )  ;  }
class TriConsumer < X ,  Y ,  Z >  { private TriConsumer < X ,  Y ,  Z >  after ;  public TriConsumer < T ,  U ,  V >  andThen ( TriConsumer < ? super X ,  ? super Y ,  ? super Z >  after )  { Objects . requireNonNull ( after )  ;  return  ( x ,  y ,  z )  - >  { accept ( x ,  y ,  z )  ;  after . accept ( x ,  y ,  z )  ;  } ;  } public void accept ( X arg0 ,  Y arg1 ,  Z arg2 )  { } public TriConsumer < X ,  Y ,  Z >  function ( TriConsumer < ? super X ,  ? super Y ,  ? super Z >  after )  { Objects . requireNonNull ( after )  ;  return  ( loc0 ,  loc1 ,  loc2 )  - >  { accept ( loc0 ,  loc1 ,  loc2 )  ;  after . accept ( loc0 ,  loc1 ,  loc2 )  ;  } ;  } }
public static Object function ( Object arg0 )  { try { return IdentityFunction . INSTANCE . apply ( arg0 )  ;  } catch  ( Exception loc0 )  { return null ;  } }
void function ( byte [  ]  arg0 )  { this . challenge = arg0 ;  }
void function ( Object arg0 ,  Object arg1 )  { try { Named loc0 =  ( Named )  arg0 ;  String loc1 =  ( String )  arg1 ;  if  ( TOPICS . contains ( loc1 )  )  { if  ( table . containsKey ( loc0 . name (  )  )  )  { throw new InternalCompilerError ( "Duplicate definition of type " + loc0 . name (  )  )  ;  } table . put ( loc0 . name (  )  ,  loc0 )  ;  if  ( Report . should_report ( Report . types ,  2 )  )  { Report . report ( 2 ,  "Added type " + loc0 . name (  )  )  ;  } } else { throw new InternalCompilerError ( "Invalid topic: " + loc1 )  ;  } } catch  ( ClassCastException e )  { throw new InternalCompilerError ( "Invalid arguments: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 )  { HeartbeatScheduler . ScheduledTimer timer = new HeartbeatScheduler . ScheduledTimer ( arg0 )  ;  sLock . lock (  )  ;  try { addTimer ( timer )  ;  schedule ( arg0 )  ;  await ( arg0 )  ;  } finally { clearTimer ( arg0 )  ;  sLock . unlock (  )  ;  } }
import org . hamcrest . Matcher ;  import org . hamcrest . Matchers ;  public class OrderingComparison { public static  < T extends Comparable < T >  >  Matcher < T >  function ( T arg0 ,  T arg1 )  { return Matchers .  < T > usingNaturalOrdering (  )  . lessThan ( arg1 )  ;  } }
void function ( XCommand < ? >  arg0 ,  Map < Long ,  List < XCommand < ? >  >  >  queue )  { try { arg0 . acquireLock (  )  ;  arg0 . verifyPrecondition (  )  ;  List < XCommand < ? >  >  list = queue . computeIfAbsent ( arg0 . getPriority (  )  ,  k - >  new ArrayList <  >  (  )  )  ;  list . add ( arg0 )  ;  } catch  ( Exception e )  { arg0 . releaseLock (  )  ;  arg0 . LOG . error ( "Error queuing command " + arg0 . getEntityKey (  )  + " of type " + arg0 . getType (  )  ,  e )  ;  } }
void function ( String threadName )  { try  ( LockResource loc0 = new LockResource ( sLock )  )  { while  ( !sTimers . containsKey ( threadName )  )  { try { sCondition . await (  )  ;  } catch  ( InterruptedException e )  { e . printStackTrace (  )  ;  } } } }
void function ( Argument arg0 ,  String message )  { arg0 . setInvalidationMessage ( message )  ;  } This method sets the invalidation message of the Argument object passed as the first argument to the message passed as the second argument ,  without any exception handling .  The invalidation message indicates that the value of the argument is invalid ,  and the GUI will be redrawn with a warning displayed in red above the entry widget . 
public static int function ( String arg0 )  { byte [  ]  loc0 = arg0 . getBytes (  )  ;  int loc1 = 5381 ;  for  ( int loc2 = 0 ;  loc2  <  loc0 . length ;  loc2 ++  )  { loc1 =  ( loc1  <  <  5 )  + loc1 + loc0 [ loc2 ]  ;  } return loc1 ;  }
String function (  )  { String loc0 = this . destination ;  return loc0 ;  }
void function ( int arg0 )  { waitFor ( arg0 )  ;  }
String [  ]  function (  )  { String [  ]  loc0 = null ;  try { loc0 = stub . getIssuersOfSAMLServiceProviders (  )  ;  } catch  ( RemoteException loc1 )  { log . error ( "srini_string" ,  loc1 )  ;  throw new AxisFault ( loc1 . getMessage (  )  ,  loc1 )  ;  } return loc0 ;  }
public void function ( String arg0 )  { try { ConcurrentMap < String ,  Object >  loc0 = attributes ;  if  ( loc0 != null )  { loc0 . remove ( arg0 )  ;  } } catch  ( Exception e )  { if  ( !ignoreExceptions )  { Report loc1 = report ;  loc1 . addError ( new ParseError ( sourceCodeFilename ,  e )  )  ;  } } }
void function ( int arg0 )  { int loc0 = getStep (  )  ;  doAction (  )  ;  makePanel ( arg0 )  ;  changed ( loc0 ,  getStep (  )  )  ;  }
public void function ( Object arg0 ,  Object arg1 )  { Date loc0 = new Date (  )  ;  assertTrue ( loc0 . equals ( arg0 )  )  ;  assertTrue ( !loc0 . equals ( arg1 )  )  ;  }
void function ( int arg0 )  { Node loc0 = new Node ( arg0 )  ;  if  ( head == null )  { head = loc0 ;  } else { Node loc1 = head ;  while  ( loc1 . next != null )  { loc1 = loc1 . next ;  } loc1 . next = loc0 ;  } }
Array < Asset >  function (  )  { Array < Asset >  loc0 = new Array <  >  (  )  ;  loc0 . add ( new Asset ( "sound1 . ogg" )  )  ;  loc0 . add ( new Asset ( "sound2 . ogg" )  )  ;  return loc0 ;  }
void function ( State arg0 ,  State arg1 )  { }
double function (  )  { double loc0 = DEFAULT_POWER ;  try { loc0 = power ;  } catch  ( Exception e )  { } return loc0 ;  }
public String function (  )  { String loc0 = "" ;  try { loc0 = getReferencedRevisionLabelB (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
String function ( String arg0 )  { String loc0 = null ;  try { loc0 = graph . toString (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
void function ( SentenceListener arg0 ,  String arg1 )  { listeners . computeIfAbsent ( arg1 ,  k - >  new ArrayList <  >  (  )  )  . add ( arg0 )  ;  } The above method adds a `SentenceListener` to the list of listeners interested in receiving sentences of a certain type .  It first checks if the map `listeners` contains a key that matches the specified sentence type  ( `arg1` )  .  If it does not ,  it adds a new key-value pair to the map ,  where the key is the sentence type and the value is a new ArrayList to hold the listeners .  Then ,  it adds the `SentenceListener` `arg0` to the list of listeners for the specified sentence type . 
import com . google . common . util . concurrent . ListenableFuture ;  import org . bitcoinj . core . Coin ;  import org . bitcoinj . protocols . channels . PaymentChannelClient ;  import org . bitcoinj . protocols . channels . PaymentIncrementAck ;  class PaymentChannelClientConnection { SettableFuture < PaymentChannelClientConnection >  channelOpenFuture = SettableFuture . create (  )  ;  ProtobufParser < Protos . TwoWayChannelMessage >  wireParser ;  PaymentChannelClient channelClient ;  ListenableFuture < PaymentIncrementAck >  function ( Coin arg0 )  { ListenableFuture < PaymentIncrementAck >  loc0 = null ;  try { loc0 = channelClient . incrementPayment ( arg0 ,  null )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  } void disconnectWithoutSettlement (  )  { } void settle (  )  { } PaymentChannelClientState state (  )  { } ListenableFuture < PaymentChannelClientConnection >  getChannelOpenFuture (  )  { } }
String function ( String arg0 )  { String loc0 = "" ;  try { loc0 = arg0 . substring ( 0 ,  arg0 . lastIndexOf ( " . " )  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public void function (  )  { try { String arg0 = "admin" ;  UserInfo loc0 = new UserInfo (  )  ;  loc0 . setAuthorities ( Collections . singleton ( Role . ROLE_ADMIN )  )  ;  Mockito . when ( userInfoRepository . getByUsername ( arg0 )  )  . thenReturn ( loc0 )  ;  UserDetails loc1 = service . getByUsername ( arg0 )  ;  Assert . assertTrue ( loc1 . getAuthorities (  )  . contains ( Role . ROLE_USER )  )  ;  Assert . assertTrue ( loc1 . getAuthorities (  )  . contains ( Role . ROLE_ADMIN )  )  ;  } catch  ( Exception e )  { Assert . fail ( "An exception was thrown: " + e . getMessage (  )  )  ;  } }
boolean function ( Scan arg0 )  { for  ( Term loc0 : terms )  { if  ( !loc0 . isSatisfied ( arg0 )  )  { return false ;  } } return true ;  }
void function ( int arg0 )  { try { INSTANCE . release ( arg0 )  ;  } catch  ( Exception e )  { throw new IllegalStateException ( "srini_string" ,  e )  ;  } }
public XHTMLPanel function (  )  { XHTMLPanel loc0 = panel ;  return loc0 ;  }
Map < String , String >  function ( File arg0 ,  File arg1 ,  File arg2 ,  File arg3 )  { Map < String , String >  loc0 = new HashMap <  >  (  )  ;  List < String >  loc1 = getList ( arg0 )  ;  for  ( String loc2 : loc1 )  { String loc3 = createKey ( loc2 ,  arg1 . getName (  )  )  ;  loc0 . put ( loc3 ,  "" )  ;  } return loc0 ;  }
void function ( long arg0 ,  int arg1 ,  ServiceInfoStat [  ]  arg2 )  { onServiceRemove ( arg0 ,  arg1 ,  arg2 )  ;  }
void function (  )  { try { writer . writeStartElement ( "group" )  ;  } catch  ( XMLStreamException loc0 )  { } }
public static double function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 )  { try { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 . numCols ,  1 )  ;  CommonOps . mult ( arg0 ,  arg1 ,  loc0 )  ;  double numerator = EigenOps . innerProdA ( arg1 ,  loc0 )  ;  double denominator = EigenOps . innerProd ( arg1 ,  arg1 )  ;  return numerator / denominator ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return Double . NaN ;  } }
boolean function ( ActivityRequest arg0 )  { if  ( arg0 == null || arg0 . getDelayerFileAttributesExtractorStrategy (  )  == null || arg0 . getFeedId (  )  == null )  { return false ;  } return arg0 . getConfigProperties (  )  != null ;  }
Properties function ( String arg0 )  { Properties loc0 = getModuleProperties ( arg0 )  ;  List < Subscription >  loc1 = buildSubscriptionList ( arg0 ,  loc0 )  ;  ModuleConfiguration loc2 = getModuleConfigurations ( arg0 )  ;  List < Subscription >  loc3 = loc2 . getSubscriptions (  )  ;  loc3 . addAll ( loc1 )  ;  loc2 . setSubscriptions ( loc3 )  ;  return loc0 ;  }
void function ( Map < String ,  String >  arg0 )  { Map < String ,  String >  loc0 = new HashMap <  >  (  )  ;  loc0 . putAll ( arg0 )  ;  loc0 . put ( Constants . CATEGORY_KEY ,  Constants . PROVIDERS_CATEGORY )  ;  registry . register ( loc0 )  ;  }
BlockPos function ( int arg0 )  { BlockPos loc0 = getNextBlock ( arg0 )  ;  if  ( loc0 == null )  { return new BlockPos ( 9999 ,  9999 ,  9999 )  ;  } double loc1 = Math . sqrt ( mob . getDistanceSqToCenter ( loc0 )  )  ;  return loc1  <  range ? loc0 : new BlockPos ( 9999 ,  9999 ,  9999 )  ;  }
HashMap < Integer , Playlist >  function (  )  { HashMap < Integer , Playlist >  loc0 = new HashMap <  >  (  )  ;  DbConnJaMuz db = getDb (  )  ;  List < Playlist >  loc1 = getPlaylists (  )  ;  for  ( Playlist loc2 : loc1 )  { loc0 . put ( loc2 . getId (  )  ,  loc2 )  ;  } db . close (  )  ;  return loc0 ;  } Note: Please note that removing exception handling may not be a good practice in production code . 
void function ( int arg0 )  { SimpleDB . bufferMgr (  )  . flushAll ( arg0 )  ;  recoveryMgr . recover (  )  ;  }
void function ( String arg0 )  { this . password = arg0 ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = signatureUsername ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
void function ( String arg0 )  { try { log . debug ( "Deleting ingredient with ID: {}" ,  arg0 )  ;  ingredientRepository . delete ( arg0 )  ;  } catch  ( Exception loc0 )  { log . error ( "Failed to delete ingredient with ID: {}" ,  arg0 ,  loc0 )  ;  } }
void function (  )  { try { createTextureAtlas (  )  ;  loadTextureAtlas (  )  ;  loadTextures (  )  ;  loadSounds (  )  ;  loadMaps (  )  ;  } catch  ( IOException e )  { Gdx . app . error ( LOG ,  "Error loading assets" ,  e )  ;  } }
public long function (  )  { long result = 0 ;  try { result = Math . max ( maxDepth ,  Math . max ( children [ 0 ]  . depth (  )  ,  children [ 1 ]  . depth (  )  )  )  ;  } catch  ( NullPointerException e )  { } return result ;  }
public void function ( Object arg0 ,  Object arg1 )  { try { throw new UnsupportedOperationException (  )  ;  } catch  ( UnsupportedOperationException e )  { } }
double [  ]  function ( BidiagonalDecompositionRow_D64 obj )  { double [  ]  loc0 = null ;  try { loc0 = obj . getGammasU (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( String arg0 ,  String arg1 )  { Properties loc0 = new Properties (  )  ;  loc0 . setProperty ( "inputFile" ,  arg0 )  ;  loc0 . setProperty ( "outputFile" ,  arg1 )  ;  engine = new FuriaChanEngine ( loc0 )  ;  engine . start (  )  ;  testAll (  )  ;  closeEngine (  )  ;  }
void function (  )  { if  ( state (  )  != State . NEW )  { return ;  } synchronized  ( this )  { if  ( state (  )  != State . NEW )  { return ;  } state = State . STARTING ;  } loc0 (  )  ;  running (  )  ;  }
ValueHolder function ( Object arg0 )  { return addHolder (  )  . value ( String . valueOf ( arg0 )  )  ;  }
void function (  )  { try { permissionService . createTicket ( rs1 ,  scopes1 )  ;  assertNotNull ( permissionService . createTicket ( rs2 ,  scopes2 )  )  ;  } catch  ( Exception e )  { System . out . println ( "An exception occurred: " + e . getMessage (  )  )  ;  } }
void function (  )  { function (  )  ;  boolean loc0 = snake . isAlive ;  this . gui . setTitle ( "Snake - Score: " + snake . getScore (  )  )  ;  boolean loc1 = border . isAlive ;  int loc2 = gameElements . size (  )  ;  if  ( !loc0 || !loc1 || loc2 == 0 )  { checkGameOver (  )  ;  } }
T function (  )  { Node minNode = extractMinNode (  )  ;  if  ( minNode != null )  { return minNode . key ;  } return null ;  }
void function ( InetSocketAddress arg0 ,  WorkerNetAddress arg1 )  { String loc0 = NetworkAddressUtils . getFqdnHost ( arg0 )  ;  String loc1 = NetworkAddressUtils . getFqdnHost ( arg1 )  ;  assertEquals ( loc0 ,  loc1 )  ;  InetSocketAddress loc2 = new InetSocketAddress ( "localhost" ,  8080 )  ;  NetworkAddressUtils . setHost ( loc2 ,  "127 . 0 . 0 . 1" )  ;  }
double function (  )  { checkState (  )  ;  long count = count (  )  ;  double xMean = xStats . mean (  )  ;  double yMean = yStats . mean (  )  ;  double sumOfProductsOfDeltas = sumOfProductsOfDeltas (  )  ;  double sampleCovariance =  ( sumOfProductsOfDeltas - count * xMean * yMean )  /  ( count - 1 )  ;  return ensurePositive ( sampleCovariance )  ;  }
ArrayList < String >  wordList = new ArrayList < String >  (  )  ;  ArrayList < Integer >  frequencyList = new ArrayList < Integer >  (  )  ;  public void function ( Map < String ,  Integer >  arg0 )  { List < Map . Entry < String ,  Integer >  >  entries = new ArrayList <  >  ( arg0 . entrySet (  )  )  ;  Collections . sort ( entries ,  new Comparator < Map . Entry < String ,  Integer >  >  (  )  { public int compare ( Map . Entry < String ,  Integer >  loc0 ,  Map . Entry < String ,  Integer >  loc1 )  { return loc0 . getValue (  )  . compareTo ( loc1 . getValue (  )  )  ;  } } )  ;  for  ( Map . Entry < String ,  Integer >  entry : entries )  { wordList . add ( entry . getKey (  )  )  ;  frequencyList . add ( entry . getValue (  )  )  ;  } }
void function ( ThreadFactoryBuilder arg0 ,  Integer arg1 )  { arg0 . priority = arg1 ;  arg0 . checkArgument ( arg1  > = Thread . MIN_PRIORITY && arg1  < = Thread . MAX_PRIORITY ,  "Thread priority must be between MIN_PRIORITY and MAX_PRIORITY" )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = getContextURL (  )  ;  if  ( !loc0 . endsWith ( "/" )  )  { loc0 += "/" ;  } return loc0 + arg0 . substring ( arg1 . length (  )  )  ;  }
void function ( String [  ]  arg0 ,  String [  ]  arg1 )  { try { AttributesImpl loc0 = new AttributesImpl (  )  ;  for  ( int i = 0 ;  i  <  arg0 . length ;  i ++  )  { loc0 . addAttribute ( "" ,  arg0 [ i ]  ,  "" ,  "" ,  arg1 [ i ]  )  ;  } this . attributes = loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
Object function ( Context loc0 ,  Scriptable loc1 ,  Object [  ]  loc2 ,  Function loc3 )  { Scriptable start = ScriptRuntime . getTopCallScope ( loc0 )  ;  Object hint = loc2 . length  >  0 ? loc2 [ 0 ]  : null ;  Object defaultValue = loc2 . length  >  1 ? loc2 [ 1 ]  : null ;  if  ( hint instanceof String && "valueOf" . equals ( hint )  )  { hint = null ;  } if  ( hint == null || hint == ScriptRuntime . ScriptableClass || hint == ScriptRuntime . FunctionClass )  { return this ;  } if  ( hint instanceof Scriptable )  { Scriptable scriptable =  ( Scriptable )  hint ;  if  ( ScriptableObject . hasProperty ( scriptable ,  "prototype" )  )  { Scriptable prototype = ScriptableObject . getProperty ( scriptable ,  "prototype" )  ;  if  ( ScriptRuntime . isObjectInstanceOf ( this ,  prototype )  )  { return this ;  } } } Object result = ScriptableObject . getDefaultValue ( start ,  hint )  ;  if  ( result != null )  { return result ;  } if  ( defaultValue != null )  { return defaultValue ;  } return ScriptRuntime . toString ( this )  ;  }
byte [  ]  function (  )  { byte [  ]  locValue = null ;  try { int locLen = getByteArrayLength (  )  ;  locValue = new byte [ locLen ]  ;  getByteArrayInternal ( locLen ,  locValue ,  0 ,  locLen )  ;  } catch  ( Exception e )  { } return locValue ;  }
String function ( String arg0 )  { String loc0 = _uriResolver . resolve ( arg0 )  ;  return loc0 ;  }
public static String function ( ResultEntry arg0 )  { String loc0 = null ;  try { loc0 = arg0 . source ;  } catch  ( NullPointerException e )  { loc0 = "Unknown" ;  } return loc0 ;  }
Document function ( String arg0 ,  String arg1 )  { SimpleXpathEngine loc0 = new SimpleXpathEngine (  )  ;  Document loc1 = DocumentBuilderFactory . newInstance (  )  . newDocumentBuilder (  )  . newDocument (  )  ;  DOMResult loc2 = new DOMResult ( loc1 )  ;  loc0 . performTransform ( loc0 . getCopyTransformation ( arg0 )  ,  loc0 . getXPathResultNode ( arg1 ,  loc1 )  ,  loc2 )  ;  return  ( Document )  loc2 . getNode (  )  ;  }
void function ( String arg0 ,  String arg1 )  { try { FileOutputStream loc0 = new FileOutputStream ( arg0 )  ;  loc0 . write ( graph . getGraph ( dot_source ,  arg1 )  )  ;  loc0 . close (  )  ;  } catch  ( IOException loc1 )  { loc1 . printStackTrace (  )  ;  } }
void function (  )  { try { setUp (  )  ;  testSetMode (  )  ;  testSetModeWhenOmitted (  )  ;  testGetMagneticCourse (  )  ;  testSetTrueCourse (  )  ;  testSetMagneticCourseWithValueGreaterThanAllowed (  )  ;  testGetSpeedKnots (  )  ;  testSetMagneticCourseWithNegativeValue (  )  ;  testSetSpeedKmhWithNegativeValue (  )  ;  testSetSpeedKnotsWithNegativeValue (  )  ;  testSetMagneticCourse (  )  ;  testSetTrueCourseWithNegativeValue (  )  ;  testGetMode (  )  ;  testGetSpeedKmh (  )  ;  testSetTrueCourseWithValueGreaterThanAllowed (  )  ;  testSetSpeedKmh (  )  ;  testSetSpeedKnots (  )  ;  testConstructor (  )  ;  assertEquals ( 360 . 0 ,  vtg . getTrueCourse (  )  ,  0 . 01 )  ;  } catch  ( Exception loc0 )  { fail ( "Unexpected exception: " + loc0 . getMessage (  )  )  ;  } }
int function ( int arg0 ,  TJScalingFactor arg1 )  { int loc0 = arg0 * arg1 . num ;  int loc1 = loc0 / arg1 . denom ;  if  ( loc0 % arg1 . denom != 0 )  { loc1 ++  ;  } return loc1 ;  }
void function ( Object arg0 ,  Object arg1 )  { Scriptable loc0 =  ( Scriptable )  arg0 ;  String loc1 =  ( String )  arg1 ;  loc0 . function ( loc1 )  ;  Kit . codeBug ( "Function did not return a scope" )  ;  }
public static void function ( File arg0 )  { try { XmlResponse response = new XmlResponse (  )  ;  response . setFolders ( arg0 )  ;  response . setFiles ( arg0 )  ;  System . out . println ( response . toString (  )  )  ;  } catch  ( Exception e )  { System . err . println ( "Error while listing folders and files: " + e . getMessage (  )  )  ;  } }
HashMap < String ,  GeneticProfile >  function ( boolean arg0 ,  boolean arg1 )  { HashMap < String ,  GeneticProfile >  loc0 = new HashMap <  >  (  )  ;  try { loc0 = getDefaultGeneticProfileMap ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . trim (  )  ;  String loc1 = arg1 . trim (  )  ;  try { if  ( loc0 . endsWith ( "/" )  || loc0 . endsWith ( "\\" )  )  { loc0 = loc0 . substring ( 0 ,  loc0 . length (  )  - 1 )  ;  } if  ( loc1 . startsWith ( "/" )  || loc1 . startsWith ( "\\" )  )  { loc1 = loc1 . substring ( 1 )  ;  } } catch  ( Exception e )  { LOGGER . error ( "Error while checking and modifying path . " ,  e )  ;  } return loc0 + "/" + loc1 ;  }
Page < DishCollection >  function ( int arg0 ,  int arg1 )  { log . debug ( "Getting all the dishCollections . " )  ;  Pageable loc0 = PageRequest . of ( arg0 ,  arg1 )  ;  return dishCollectionRepository . findAll ( loc0 )  ;  }
GetPrice function ( String arg0 ,  String arg1 ,  double arg2 )  { ObjectFactory loc0 = new ObjectFactory (  )  ;  GetPrice loc1 = loc0 . createGetPrice (  )  ;  loc1 . setArg0 ( arg0 )  ;  loc1 . setArg1 ( arg1 )  ;  loc1 . setArg2 ( arg2 )  ;  return loc1 ;  }
int function ( EncryptionProperties obj )  { int loc0 = 0 ;  try { loc0 = obj . getKeyIdentifierType (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
long function (  )  { long loc0 = 0 ;  try { loc0 = this . getDataUnitId (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting data unit id: " + e . getMessage (  )  )  ;  } return loc0 ;  }
public void function ( BlockMatrix64F arg0 ,  boolean arg1 )  { try { applyQTran ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { System . err . println ( "Error in QRDecompositionHouseholder_B64 . function (  ) : " + e . getMessage (  )  )  ;  } }
void function ( Object arg0 ,  Object arg1 )  { not_null ( arg0 )  ;  _all . remove ( arg1 )  ;  }
TreeNode function ( TreeNode arg0 ,  int arg1 )  { if  ( arg0 == null || arg0 . val == arg1 )  { return arg0 ;  } if  ( arg0 . val  >  arg1 )  { return function ( arg0 . left ,  arg1 )  ;  } return function ( arg0 . right ,  arg1 )  ;  }
double function ( DenseMatrix64F arg0 )  { int loc0 = Math . min ( arg0 . numRows ,  arg0 . numCols )  ;  double loc1 = 1 . 0 ;  for  ( int i = 0 ;  i  <  loc0 ;  i ++  )  { loc1 *= arg0 . unsafe_get ( i ,  i )  ;  } return loc1 ;  }
String function ( BufferedReader arg0 )  { StringBuffer loc0 = new StringBuffer (  )  ;  String loc1 ;  try { while  (  ( loc1 = arg0 . readLine (  )  )  != null )  { loc0 . append ( loc1 )  ;  loc0 . append ( WebFileConnect . NEW_LINE )  ;  } arg0 . close (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 . toString (  )  ;  }
String function ( String arg0 )  { String loc0 = Strings . emptyToNull ( arg0 )  ;  return loc0 ;  }
Expression function ( Object arg0 )  { Expression loc0 = newval ;  return loc0 ;  }
void function ( long arg0 )  { try { put64 ( arg0 )  ;  } catch  ( Exception e )  { } }
String function ( RabbitMQMessage message )  { return message . getContentType (  )  ;  }
boolean function (  )  { ByteBuffer loc0 = ByteBuffer . allocate ( HEADER_LENGTH )  ;  loc0 . order ( ByteOrder . BIG_ENDIAN )  ;  loc0 . put ( params . getPacketMagic (  )  )  ;  loc0 . put ( command . getBytes ( Charset . forName ( "US-ASCII" )  )  )  ;  loc0 . putInt ( size )  ;  loc0 . put ( checksum )  ;  loc1 = loc0 . array (  )  ;  return parseLazy ;  }
public void function ( boolean arg0 )  { validateUseKey = arg0 ;  }
void function ( Long arg0 )  { try { dataSetId = arg0 ;  } catch  ( Exception loc0 )  { System . out . println ( "Error occurred while setting data set id: " + loc0 . getMessage (  )  )  ;  } }
float function (  )  { return dotsPerDeg ;  }
Type arg0 ;  // the object to check for inclusion in the set for  ( Type loc0 : v )  { if  ( loc0 instanceof Subtype && arg0 instanceof Subtype )  { if  (  (  ( Subtype )  arg0 )  . isSubtype ( loc0 ,  ts )  )  { return true ;  } } else if  ( loc0 . equals ( arg0 )  )  { return true ;  } } return false ; 
public void function ( ServiceID arg0 ,  int arg1 ,  int arg2 ,  InetAddress arg3 )  { long xid = System . currentTimeMillis (  )  ;  HostCtrlCallbacks callbacks = new HostCtrlCallbacks (  )  ;  callbacks . onServiceRemove ( xid ,  callbacks . RETVAL_OK ,  new ServiceInfoStat [  ] {} )  ;  callbacks . onServiceRegistration ( arg0 ,  0 ,  arg2 ,  arg3 ,  null )  ;  }
String function (  )  { WorkflowJobBean loc0 = getWorkflow (  )  ;  return loc0 . getUser (  )  ;  }
ProjectActions function (  )  { if  ( loc0 == null )  { loc0 = new ProjectActions (  )  ;  } return loc0 . theInstance ;  }
void function ( O arg0 ,  int arg1 )  { assert arg1  > = 0 ;  DocumentElement < O >  loc0 = data . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = new DocumentElement <  >  ( arg0 )  ;  data . put ( arg0 ,  loc0 )  ;  } wordCountMultiSet -= loc0 . getMultiplicity (  )  ;  loc0 . setMultiplicity ( arg1 )  ;  wordCountMultiSet += loc0 . getMultiplicity (  )  ;  }
public Image function (  )  { if  ( _image . isDisposed (  )  )  { _image = _uac . getImageResource ( _uri )  ;  } return _image . getImage (  )  ;  }
void function (  )  { RMCTest test = new RMCTest (  )  ;  test . setUp (  )  ;  double arg0 = test . rmc . getCourse (  )  ;  double arg1 = test . rmc . getVariation (  )  ;  test . rmc . setVariation ( -10 . 0 )  ;  double loc0 = test . rmc . getCorrectedCourse (  )  ;  assertEquals ( loc0 ,  arg0 - arg1 ,  0 . 001 )  ;  }
public View function ( MenuItemWrapper itemWrapper )  { HoneycombMenuItem loc0 =  ( HoneycombMenuItem )  itemWrapper . mMenuItem ;  return loc0 . getActionView (  )  != null ? loc0 . getActionView (  )  : new View ( null )  ;  } This method takes a MenuItemWrapper object as input and returns a View object .  It first casts the mMenuItem of the input object to a HoneycombMenuItem object .  It then calls the getActionView (  )  method of the HoneycombMenuItem object to get the currently set action view for this menu item .  If the action view is not null ,  it returns the action view .  Otherwise ,  it creates a new View object using the View (  )  constructor with null as the parameter and returns it .  There is no exception handling included in this method . 
final double loc0 = 1 . 5 ;  final GSASentence loc1 = new GSASentence (  )  ;  loc1 . setHorizontalDOP ( loc0 )  ;  assertEquals ( loc0 ,  loc1 . getHorizontalDOP (  )  )  ; 
Character function ( Event arg0 ,  ShadowStruggles arg1 ,  RpgMap arg2 ,  SettingsDAO arg3 )  { Character loc0 = new Character ( arg0 . getX (  )  ,  arg0 . getY (  )  ,  arg0 . getSprite (  )  )  ;  loc0 . setId ( arg0 . getId (  )  )  ;  loc0 . setActions ( arg0 . getActions (  )  )  ;  loc0 . setMap ( arg0 . getMap (  )  )  ;  loc0 . setLayer ( arg0 . getLayer (  )  )  ;  loc0 . setCollidable ( arg0 . isCollidable (  )  )  ;  loc0 . setTriggerType ( arg0 . getConvertedTriggerType (  )  )  ;  Settings loc1 = arg3 . getSettings (  )  ;  loc0 . setSpeed ( loc1 . getCharacterSpeed (  )  )  ;  loc0 . setHp ( loc1 . getCharacterHp (  )  )  ;  TileLayer loc2 = arg2 . getDefaultTileLayer (  )  ;  loc0 . setTileLayer ( loc2 )  ;  return loc0 ;  }
public static String function ( String arg0 )  { int loc0 = 0 ;  int loc1 = arg0 . length (  )  ;  for  ( int i = loc0 ;  i  <  loc1 ;  i ++  )  { char c = arg0 . charAt ( i )  ;  if  ( c == '$' || c == '!' )  { loc0 = i + 1 ;  } else if  ( c == '*' )  { loc1 = i ;  break ;  } } int loc2 = 0 ;  for  ( int i = loc0 ;  i  <  loc1 ;  i ++  )  { loc2 ^= arg0 . charAt ( i )  ;  } try { return String . format ( "%02X" ,  loc2 )  ;  } catch  ( Exception e )  { return "00" ;  } }
void function ( Object arg0 )  { try { add ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( long sleepTimeMs )  { try { Thread . sleep ( sleepTimeMs )  ;  } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  } }
import java . io . ByteArrayInputStream ;  import java . io . DataInputStream ;  import java . io . IOException ;  import org . apache . hadoop . io . Writable ;  public class WritableUtils { private static final String NULL = "||" ;  public static String readStr ( DataInput dataInput )  throws IOException { int length = dataInput . readInt (  )  ;  if  ( length == -1 )  { return null ;  } else if  ( length == 0 )  { return "" ;  } else { byte [  ]  bytes = new byte [ length ]  ;  dataInput . readFully ( bytes )  ;  return new String ( bytes ,  "UTF-8" )  ;  } } public static void writeStr ( DataOutput dataOutput ,  String str )  throws IOException { if  ( str == null )  { dataOutput . writeInt ( -1 )  ;  } else if  ( str . length (  )  == 0 )  { dataOutput . writeInt ( 0 )  ;  } else { byte [  ]  bytes = str . getBytes ( "UTF-8" )  ;  dataOutput . writeInt ( bytes . length )  ;  dataOutput . write ( bytes )  ;  } } public static byte [  ]  toByteArray ( Writable writable )  throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream (  )  ;  DataOutputStream dataOut = new DataOutputStream ( out )  ;  writable . write ( dataOut )  ;  dataOut . close (  )  ;  return out . toByteArray (  )  ;  } public static Writable function ( byte [  ]  arg0 ,  Writable arg1 )  { try { ByteArrayInputStream in = new ByteArrayInputStream ( arg0 )  ;  DataInputStream dataIn = new DataInputStream ( in )  ;  arg1 . readFields ( dataIn )  ;  dataIn . close (  )  ;  in . close (  )  ;  return arg1 ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  return null ;  } } }
public static ConfigurationKey function ( String arg0 ,  String arg1 ,  String arg2 )  { try { String loc0 = new String ( arg0 )  ;  String loc1 = new String ( arg1 )  ;  String loc2 = new String ( arg2 )  ;  return new ConfigurationKeyImpl ( loc0 ,  loc1 ,  loc2 )  ;  } catch  ( Exception e )  { } }
void function (  )  { Collection < ImageResource >  loc0 = _imageCache . values (  )  ;  Iterator < ImageResource >  loc1 = loc0 . iterator (  )  ;  while  ( loc1 . hasNext (  )  )  { ImageResource loc2 = loc1 . next (  )  ;  loc2 . getImage (  )  . dispose (  )  ;  loc1 . remove (  )  ;  } _imageCache . clear (  )  ;  }
void function (  )  { String loc0 = "test" ;  boolean loc1 = true ;  Mockito . when ( mClient . listObjects ( Matchers . any (  )  )  )  . thenThrow ( new ServiceException ( "test" )  )  ;  try { mOSSUnderFileSystem . delete ( loc0 ,  loc1 )  ;  } catch  ( ServiceException e )  { Mockito . verify ( mOSSUnderFileSystem ,  Mockito . times ( 1 )  )  . delete ( loc0 ,  loc1 )  ;  Assert . assertFalse ( mOSSUnderFileSystem . isDirectory ( loc0 )  )  ;  } }
Node function ( String fmt ,  Object .  .  .  subst )  { String source = fmt . replaceAll ( "// . *|/\\* (  . |\\n ) *?\\*/" ,  "" )  ;  QQ qq = new QQ (  )  ;  Node node = qq . parse ( QQ . FILE ,  source ,  subst )  . toArray (  )  [ 0 ]  ;  return node ;  }
public int function ( ByteBuffer arg0 )  { ByteBuffer loc0 = ByteBuffer . allocate ( BUCKET_SIZE_BYTES )  ;  Hasher loc1 = INDEX_HASHER . newHasher (  )  ;  loc1 . putInt ( arg0 . remaining (  )  )  ;  loc0 . put ( arg0 )  ;  loc0 . put (  ( byte )  0 )  ;  loc1 . putBytes ( loc0 . array (  )  )  ;  int loc2 = Math . abs ( loc1 . hash (  )  . asInt (  )  )  % mNumBuckets ;  loc0 . clear (  )  ;  return loc2 ;  }
String function ( FileInfo loc0 )  { return loc0 . relativeFullPath ;  }
boolean function ( Language arg0 )  { for  ( RuleSet loc0 : ruleSets )  { if  ( loc0 . usesTypeResolution ( arg0 )  )  { return true ;  } } return false ;  }
void function ( String arg0 )  { Config config = new Config (  )  ;  config . setBuild ( arg0 )  ;  }
Bitmap function ( Bitmap arg0 ,  int arg1 ,  int arg2 )  { int [  ]  loc0 ;  try { loc0 = getDims ( arg0 . getWidth (  )  ,  arg0 . getHeight (  )  ,  arg1 ,  arg2 )  ;  return Bitmap . createScaledBitmap ( arg0 ,  loc0 [ 0 ]  ,  loc0 [ 1 ]  ,  false )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
JWSAlgorithm function ( JsonObject arg0 ,  String arg1 )  { JsonElement loc0 = arg0 . get ( arg1 )  ;  return loc0 != null ? JWSAlgorithm . parse ( loc0 . getAsString (  )  )  : null ;  }
String function ( List < String >  arg0 ,  String arg1 )  { byte [  ]  entropy = MnemonicCode . toEntropy ( arg0 )  ;  byte [  ]  seed = PBKDF2SHA512 . derive ( arg1 ,  MnemonicCode . BIP39_ENGLISH_SHA256 ,  MnemonicCode . PBKDF2_ROUNDS ,  64 )  ;  return Joiner . on ( ' ' )  . join ( arg0 )  + " " + Hex . encode ( seed )  ;  }
void function ( String arg0 )  { this . testData = arg0 ;  }
void function (  )  { try { m_turnClient . connect (  )  ;  } catch  ( IOException loc0 )  { m_log . error ( "Failed to connect to TURN server" ,  loc0 )  ;  m_offerAnswerListener . onFailure (  )  ;  } }
void function ( Activity arg0 ,  int arg1 ,  String arg2 )  { try { Intent loc0 = makeIntent ( arg2 ,  null )  ;  startForResult ( arg0 ,  arg1 ,  loc0 )  ;  } catch  ( Exception e )  { } }
public void function (  )  { RMBTest rmbTest = new RMBTest (  )  ;  rmbTest . setUp (  )  ;  rmbTest . rmb . setVelocity ( 12 . 5 )  ;  final double loc0 = 12 . 5 ;  assertEquals ( loc0 ,  rmbTest . rmb . getVelocity (  )  ,  0 . 0 )  ;  assertTrue ( rmbTest . rmb . toString (  )  . contains ( "$GPRMB" )  )  ;  }
void function ( Object arg0 ,  Object arg1 )  { BiAdAdapterSwitcher loc0 = new BiAdAdapterSwitcher (  )  ;  loc0 . setDefaultOnRefreshListener (  ( Runnable )  arg0 )  ;  SwipeRefreshLayout loc1 = new SwipeRefreshLayout (  ( Context )  arg1 )  ;  loc1 . setOnRefreshListener ( new SwipeRefreshLayout . OnRefreshListener (  )  {  @ Override public void onRefresh (  )  { Handler loc2 = new Handler (  )  ;  loc2 . postDelayed ( loc0 . refresh_default ,  2000 )  ;  } } )  ;  }
void function (  )  { ImmutableMap < String ,  Long >  expectedCapacityBytes = ImmutableMap . of ( "MEM" ,  100L ,  "DISK" ,  500L )  ;  mBlockStoreMeta = new BlockStoreMeta ( COMMITTED_BLOCKS_NUM ,  TEST_SESSION_ID ,  TEST_BLOCK_SIZE ,  mMetadataManager )  ;  Map < String ,  Long >  actualCapacityBytes = mBlockStoreMeta . getCapacityBytesOnTiers (  )  ;  Assert . assertEquals ( expectedCapacityBytes ,  actualCapacityBytes )  ;  }
Integer function (  )  { return cn . getExitStatus (  )  ;  }
Proxy function ( HTTPClientPolicy arg0 ,  URI arg1 )  { Proxy loc0 = ProxyBuilder . build (  )  ;  Matcher loc1 = Pattern . compile ( System . getProperty ( HTTP_NON_PROXY_HOSTS )  )  . matcher ( arg1 . getHost (  )  )  ;  if  ( !loc1 . matches (  )  )  { loc0 = createProxy ( arg0 ,  arg1 )  ;  } else { loc0 = Proxy . NO_PROXY ;  } return loc0 ;  }
public void function ( TDeserializer deserializer ,  byte [  ]  arg0 ,  TBase arg1 )  { try { deserializer . reset (  )  ;  deserializer . deserialize ( arg1 ,  arg0 )  ;  } catch  ( TException e )  { e . printStackTrace (  )  ;  } finally { deserializer . clear (  )  ;  } }
void function ( String arg0 ,  String arg1 ,  Throwable arg2 )  { StackTraceElement loc0 = getCurrentStackTraceElement (  )  ;  String loc1 = getContent ( loc0 )  ;  try { Log . e ( arg0 ,  arg1 )  ;  } catch  ( Exception loc2 )  { Log . e ( sApplicationTag ,  String . format ( TAG_CONTENT_PRINT ,  "URLogs" ,  "function" ,  "68" ,  loc0 . getLineNumber (  )  )  )  ;  Log . e ( sApplicationTag ,  loc1 )  ;  Log . e ( sApplicationTag ,  loc2 . getMessage (  )  )  ;  for  ( StackTraceElement loc3 : loc2 . getStackTrace (  )  )  { Log . e ( sApplicationTag ,  loc3 . toString (  )  )  ;  } loc2 . printStackTrace (  )  ;  } }
void function (  )  { SAMLRealm realm = new SAMLRealm (  )  ;  String loc0 = realm . signatureAlias ;  System . out . println ( loc0 )  ;  }
public void function (  )  { try { HashMap < String ,  Object >  testEventProperties = new HashMap <  >  (  )  ;  testEventProperties . put ( Notification . NOTIFICATION_KEY_USER ,  "testUser" )  ;  testEventProperties . put ( Notification . NOTIFICATION_KEY_TITLE ,  "testTitle" )  ;  testEventProperties . put ( Notification . NOTIFICATION_KEY_MESSAGE ,  "testMessage" )  ;  testEventProperties . put ( Notification . NOTIFICATION_KEY_TIMESTAMP ,  new Date (  )  )  ;  testEventProperties . put ( Notification . NOTIFICATION_KEY_APPLICATION ,  "" )  ;  notificationController . handleEvent ( new Event ( Notification . TOPIC ,  testEventProperties )  )  ;  } catch  ( IllegalArgumentException e )  { return ;  } fail ( "Expected IllegalArgumentException was not thrown" )  ;  }
String function ( KeyStroke arg0 )  { try { if  ( arg0 != null )  { int loc0 = arg0 . getModifiers (  )  ;  String loc1 = KeyEventUtils . getModifiersText ( loc0 )  ;  String loc2 = KeyEventUtils . getKeyText ( arg0 . getKeyCode (  )  )  ;  String result = loc1 + KeyEventUtils . MODIFIER_JOINER + loc2 + KeyEventUtils . MODIFIER_JOINER + "srini_string" ;  return result ;  } } catch  ( Exception e )  { } return null ;  }
public void callFunction ( String arg0 )  { try { function ( arg0 )  ;  } catch  ( Exception e )  { } }
public static ClientDetailsEntity function ( String arg0 )  { JsonElement loc0 = parser . parse ( arg0 )  ;  return parseRegistered ( loc0 )  ;  }
public static void function ( Builder arg0 ,  String arg1 )  { try { arg0 . portId ( arg1 )  ;  } catch  ( NullPointerException e )  { System . out . println ( "Exception: " + e . getMessage (  )  )  ;  } }
public void function (  )  { RTETest testObj = new RTETest (  )  ;  testObj . setUp (  )  ;  testObj . testSetRouteTypeActive (  )  ;  boolean loc0 = testObj . testIsWorkingRoute (  )  ;  assertTrue ( loc0 )  ;  boolean loc1 = testObj . testIsActiveRoute (  )  ;  assertTrue ( loc1 )  ;  assertTrue ( loc0 && loc1 )  ;  boolean loc2 = testObj . testIsLast (  )  ;  assertFalse ( loc2 )  ;  }
void function ( Array < Condition >  arg0 ,  Array < Action >  arg1 )  { for  ( int loc0 = 0 ;  loc0  <  arg1 . size ;  loc0 ++  )  { Action loc1 = arg1 . get ( loc0 )  ;  loc1 . update (  )  ;  } for  ( Condition loc2 : arg0 )  { loc2 . update (  )  ;  } }
public int function ( Object arg0 )  { int loc0 = 17 ;  int loc1 = 31 ;  try { Difference loc2 =  ( Difference )  arg0 ;  loc0 = loc0 * loc1 + getId (  )  ;  loc0 = loc0 * loc1 +  (  ( getControlNodeDetail (  )  == null )  ? 0 : getControlNodeDetail (  )  . hashCode (  )  )  ;  loc0 = loc0 * loc1 +  (  ( getTestNodeDetail (  )  == null )  ? 0 : getTestNodeDetail (  )  . hashCode (  )  )  ;  loc0 = loc0 * loc1 +  (  ( getDescription (  )  == null )  ? 0 : getDescription (  )  . hashCode (  )  )  ;  loc0 = loc0 * loc1 +  ( isRecoverable (  )  ? 1 : 0 )  ;  } catch  ( ClassCastException e )  { loc0 = super . hashCode (  )  ;  } return loc0 ;  }
public static HexDigest function ( byte [  ]  arg0 )  { TorMessageDigest torMessageDigest = new TorMessageDigest ( true )  ;  torMessageDigest . update ( arg0 )  ;  byte [  ]  loc0 = torMessageDigest . getDigestBytes (  )  ;  return HexDigest . createFromDigestBytes ( loc0 )  ;  }
ProctorResult function ( Identifiers arg0 ,  Map < String ,  Object >  arg1 ,  Map < String ,  Integer >  arg2 )  { TestGroups testGroups = determineTestGroups ( arg0 ,  arg1 ,  arg2 ,  Collections . emptyList (  )  )  ;  return new ProctorResult ( testGroups ,  EMPTY ,  loadResult . getLoadTime (  )  )  ;  }
public static Date function ( String arg0 )  { SimpleDateFormat loc0 = new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ss'Z'" ,  LOCALE )  ;  loc0 . setTimeZone ( TIMEZONE )  ;  try { return loc0 . parse ( arg0 )  ;  } catch  ( ParseException loc1 )  { throw new ParseException ( "Parse a String into a Date according to the ISO 8601 specification  ( 2000-12-31T11:59:00Z )  . " ,  loc1 . getErrorOffset (  )  )  ;  } }
boolean function ( int arg0 )  { int loc0 = getErrorLevel (  )  ;  int loc1 = arg0 ;  return loc0  > = loc1 ;  } Note: This implementation assumes that the method is part of the "FolderInfoResult" class and that the argument "arg0" is an integer that represents the error level threshold to determine if the result is KO .  The function returns true if the error level of the result is greater than or equal to the threshold ,  indicating that the result is KO . 
void function (  )  { ttm . setTimeToCPA ( 10 . 0 )  ;  String str = ttm . toString (  )  ;  boolean contains = str . contains ( "TCPA=10 . 0" )  ;  assertTrue ( contains )  ;  }
static void function ( FileChannel arg0 ,  FileChannel arg1 ,  int bufferSize )  throws IOException { ByteBuffer loc0 = ByteBuffer . allocateDirect ( bufferSize )  ;  while  ( arg0 . read ( loc0 )  != -1 )  { loc0 . flip (  )  ;  arg1 . write ( loc0 )  ;  loc0 . compact (  )  ;  } loc0 . flip (  )  ;  while  ( loc0 . hasRemaining (  )  )  { arg1 . write ( loc0 )  ;  } }
String function ( Object arg0 ,  String arg1 ,  Object arg2 ,  Element arg3 )  { String loc0 = "" ;  Object loc1 = null ;  String loc2 = "" ;  if  ( arg0 != null )  { loc0 = arg1 ;  loc1 = arg2 ;  if  ( loc1 == null )  { loc2 = "" ;  } else { loc2 = loc1 . toString (  )  ;  } if  ( arg3 == null )  { return "" ;  } else { return arg3 . getAttributeValue ( loc0 ,  loc2 )  ;  } } else { return "" ;  } }
void function ( String arg0 )  { this . album = arg0 ;  } Note: This method takes a string argument named "arg0" and assigns its value to the instance variable "album" using the "this" keyword .  It has a void return type ,  meaning it does not return any value .  There is no exception handling in this method . 
FiltersType function (  )  { FiltersType loc0 = cipherSuiteFilters . function (  )  ;  return loc0 ;  }
public static void function (  )  { MemoryLogger instance = MemoryLogger . instance ;  instance . function (  )  ;  }
void function (  )  { try { VTGSentence loc0 = new VTGSentence ( EXAMPLE )  ;  loc0 . setMagneticCourse ( "srini_string" )  ;  fail ( "setMagneticCourse method did not throw expected exception" )  ;  } catch  ( IllegalArgumentException loc1 )  { assertTrue ( loc1 . getMessage (  )  . contains ( "srini_string" )  )  ;  assertEquals ( "Test method for net . sf . marineapi . nmea . parser . VTGParser#setMagneticCourse ( double )  . " ,  loc1 . getMessage (  )  )  ;  } }
boolean function ( Map < String ,  Object >  arg0 ,  String arg1 )  { Object loc0 = arg0 . get ( arg1 )  ;  if  ( loc0 == null )  { return false ;  } if  ( loc0 instanceof Boolean )  { return  ( Boolean )  loc0 ;  } if  ( loc0 instanceof String )  { String loc1 =  (  ( String )  loc0 )  . toLowerCase (  )  ;  return !loc1 . equals ( "false" )  && !loc1 . equals ( "no" )  && !loc1 . equals ( "0" )  ;  } return true ;  }
void function (  )  { XMLUnit . setIgnoreWhitespace ( true )  ;  XMLUnit . setNormalize ( true )  ;  Config . readConfig ( "srini_string" )  ;  }
String function (  )  { String unwrappedString = val . trim (  )  ;  return unwrappedString ;  }
void function ( String arg0 ,  String arg1 )  { Properties loc0 = PROPS != null ? PROPS : DEFAULT_PROPS ;  loc0 . put ( KEY ,  arg1 )  ;  loadValue ( arg1 )  ;  }
String function ( Fig arg0 )  { Fig loc0 = arg0 . getEnclosingFig (  )  ;  String loc1 = getId ( loc0 )  ;  return loc1 ;  }
Sha256Hash function ( File arg0 )  { FileInputStream loc0 = null ;  try { loc0 = new FileInputStream ( arg0 )  ;  byte [  ]  loc1 = ByteStreams . toByteArray ( loc0 )  ;  return Sha256Hash . create ( loc1 )  ;  } catch  ( IOException e )  { throw new RuntimeException ( "Error reading file" ,  e )  ;  } finally { if  ( loc0 != null )  { try { loc0 . close (  )  ;  } catch  ( IOException e )  { } } } }
String function ( Connection arg0 )  throws SQLException { DatabaseMetaData loc0 = arg0 . getMetaData (  )  ;  String loc1 = loc0 . getDriverName (  )  . toLowerCase (  )  ;  return loc1 . contains ( "mysql" )  ? loc0 . getDriverName (  )  : "" ;  }
public Class < ? extends Service >  function (  )  { return UUIDService . class ;  }
void function (  )  { System . out . println ( "Method calling to use the direct connection . " )  ;  HTTPDirectConnection directConn = new HTTPDirectConnection (  )  ;  URLConnection loc0 = directConn . getURLConnection (  )  ;  }
Date function ( String arg0 )  { DateTime loc0 = new DateTime (  )  ;  return loc0 . parseUTC ( arg0 ,  DateTimeFormat . SQL )  ;  }
public void function ( String arg0 )  { try { setName ( arg0 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "An error occurred while setting the name: " + loc0 . getMessage (  )  )  ;  } }
void function (  )  { before (  )  ;  byte [  ]  arg0 = new byte [ 10 ]  ;  mStream . write ( arg0 )  ;  mStream . close (  )  ;  Mockito . verify ( mLocalOutputStream )  . write ( arg0 )  ;  }
void function (  )  { String arg0 = "$GPRMC" ;  String arg1 = "some_random_string" ;  String arg2 = "" ;  String arg3 = "$GPGGA , 123519 , 4807 . 038 , N , 01131 . 000 , E , 1 , 08 , 0 . 9 , 545 . 4 , M , 46 . 9 , M ,  , " ;  String arg4 = "!" ;  String arg5 = null ;  String arg6 = "invalid_sentence" ;  Object loc0 = instance . createParser ( arg0 )  ;  assertNotNull ( loc0 )  ;  assertTrue ( loc0 instanceof Sentence )  ;  assertEquals ( arg0 ,   (  ( Sentence )  loc0 )  . getSentenceId (  )  )  ;  toSentence (  ( Sentence )  loc0 )  ;  Object loc1 = instance . createParser ( arg1 )  ;  assertNull ( loc1 )  ;  Object loc2 = instance . createParser ( arg2 )  ;  assertNull ( loc2 )  ;  Object loc3 = instance . createParser ( arg3 )  ;  assertNotNull ( loc3 )  ;  assertTrue ( loc3 instanceof GGASentence )  ;  toSentence (  ( Sentence )  loc3 )  ;  instance . registerParser ( new AlternativeBeginCharParser ( arg4 )  )  ;  Object loc4 = instance . createParser ( "$GNTXT , 01 , 01 , 02 , u-blox AG - www . u-blox . com*50" )  ;  assertNotNull ( loc4 )  ;  assertTrue ( loc4 instanceof UBXTxtSentence )  ;  toSentence (  ( Sentence )  loc4 )  ;  Object loc5 = instance . createParser ( arg5 )  ;  assertNull ( loc5 )  ;  Object loc6 = instance . createParser ( arg6 )  ;  assertNull ( loc6 )  ;  }
void function ( StateListener listener )  { try { listeners . add ( listener )  ;  } catch  ( Exception e )  { System . out . println ( "Add listener error: " + e . getMessage (  )  )  ;  } }
void function ( Project arg0 )  { if ( currentProject == null )  { arg0 . remove (  )  ;  } }
boolean function (  )  { try { String loc0 = "Read timed out" ;  String loc1 = Metric . getContent (  )  ;  return StringUtils . contains ( loc1 ,  loc0 )  ;  } catch  ( Exception e )  { return false ;  } }
HashMap < CacheKey ,  ReplacedElement >  function ( Element arg0 ,  ImageResourceLoader arg1 ,  int arg2 ,  int arg3 )  { CacheKey loc0 = new CacheKey ( arg0 . getOwnerDocument (  )  . getDocumentURI (  )  ,  arg0 . getAttribute ( "src" )  ,  arg2 ,  arg3 )  ;  ReplacedElement loc1 = arg1 . createImage ( arg0 . getAttribute ( "src" )  ,  arg2 ,  arg3 )  ;  HashMap < CacheKey ,  ReplacedElement >  loc2 = new HashMap <  >  (  )  ;  loc2 . put ( loc0 ,  loc1 )  ;  return loc2 ;  }
void function ( String arg0 )  { errorMsg = arg0 ;  }
List < String >  function (  )  { List < String >  loc0 = new ArrayList <  >  ( federationRegistrations . values (  )  )  ;  for  ( FederationModel loc1 : federationRegistrations )  { String loc2 = getFederationToken ( loc1 . token )  ;  if  ( loc2 != null )  { loc0 . add ( loc2 )  ;  } } return repositoryManager . getStrings ( IStoredSettings . Keys . git . federation . allowedTokens ,  loc0 )  ;  }
public void function ( EaseUser contact )  { try { SuperWeChatDBManager loc0 = SuperWeChatDBManager . getInstance (  )  ;  loc0 . saveContact ( contact )  ;  } catch  ( Exception e )  { } }
public static byte function ( String arg0 )  { BigInteger loc0 = BigInteger . ZERO ;  for  ( int loc1 = 0 ;  loc1  <  arg0 . length (  )  ;  loc1 ++  )  { loc0 = loc0 . multiply ( BigInteger . valueOf ( 58 )  )  ;  int loc2 = NetworkParameters . BASE_58 . indexOf ( arg0 . charAt ( loc1 )  )  ;  if  ( loc2 == -1 )  { throw new IllegalArgumentException ( "Invalid character for Base58Check" )  ;  } loc0 = loc0 . add ( BigInteger . valueOf ( loc2 )  )  ;  } byte [  ]  loc3 = loc0 . toByteArray (  )  ;  if  ( loc3 . length  <  2 )  { return 0 ;  } byte [  ]  loc4 = new byte [ loc3 . length - 1 ]  ;  System . arraycopy ( loc3 ,  0 ,  loc4 ,  0 ,  loc3 . length - 1 )  ;  byte loc5 = 0 ;  for  ( int loc6 = 0 ;  loc6  <  loc4 . length ;  loc6 ++  )  { if  ( loc4 [ loc6 ]  != 0 )  { loc5 = loc4 [ loc6 ]  ;  break ;  } } return loc5 ;  }
public int function ( int arg0 )  { Step loc0 = steps . get ( arg0 )  ;  return loc0 . getY (  )  ;  }
List < String >  function (  )  { try { List < String >  loc0 = Collections . unmodifiableList ( Arrays . asList ( new String [  ] {AuthPolicy . SPNEGO ,  AuthPolicy . NTLM ,  AuthPolicy . DIGEST ,  AuthPolicy . BASIC} )  )  ;  return loc0 ;  } catch  ( Exception e )  { } }
public void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { try { LogManager . shutdown (  )  ;  XLog . Info . reset (  )  ;  XLogStreamer . Filter . reset (  )  ;  } catch  ( Exception loc0 )  { } }
DirectionsResult function ( LatLng arg0 ,  LatLng arg1 ,  TravelMode arg2 )  { DirectionsApiRequest request = DirectionsApi . newRequest ( mapsClient . getContext (  )  )  ;  request . origin ( arg0 )  ;  request . destination ( arg1 )  ;  request . mode ( arg2 )  ;  return request . await (  )  ;  }
public String function (  )  { String loc0 = "" ;  try { loc0 = getCSSName (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
import javax . xml . ws . handler . MessageContext ;  import javax . xml . ws . handler . MessageContext . Scope ;  import javax . xml . ws . handler . MessageContext . Type ;  import javax . xml . ws . handler . soap . SOAPMessageContext ;  public Message function ( Message arg0 )  { SOAPMessageContext soapMessageContext =  ( SOAPMessageContext )  arg0 . get ( MessageContext . class )  ;  soapMessageContext . put ( "SomeProperty" ,  "SomeValue" )  ;  return arg0 ;  }
Filters function ( GameRequestContent arg0 )  { Filters loc0 = arg0 . filters ;  return loc0 ;  }
String function ( String arg0 ,  Document arg1 )  { try { JAXPXPathEngine engine = new JAXPXPathEngine (  )  ;  engine . setNamespaceContext ( new NamespaceContext (  )  )  ;  NodeList loc0 = engine . getMatchingNodes ( arg0 ,  arg1 )  ;  if  ( loc0 . getLength (  )   >  0 )  { Node loc1 = loc0 . item ( 0 )  ;  return engine . evaluate ( arg0 ,  new DOMSource ( loc1 )  )  . toString (  )  ;  } return null ;  } catch  ( XMLUnitException | XPathException e )  { throw new RuntimeException ( e )  ;  } }
void function (  )  { try { links . clear (  )  ;  } catch  ( UnsupportedOperationException e )  { System . err . println ( "Unable to clear links" )  ;  } catch  ( Exception e )  { System . err . println ( "Error while clearing links: " + e . getMessage (  )  )  ;  } }
ChangeableKind function ( String arg0 ,  String arg1 )  { try { ChangeableKindEnum loc0 = ChangeableKindEnum . forName ( arg0 )  ;  return loc0 . getMessage ( arg1 )  ;  } catch  ( Exception loc1 )  { } }
void function ( String arg0 ,  DifferenceGroup arg1 )  { try { differenceGroups . put ( arg0 ,  arg1 )  ;  } catch ( Exception loc0 )  { } }
void function ( Object arg0 )  { beforeValue (  )  ;  mWriter . write ( JSON . LSQUARE )  ;  mStack . push ( new State ( ARRAY )  )  ;  return this ;  }
void function (  )  { setUp (  )  ;  instance = new GSASentence ( EXAMPLE )  ;  double loc0 = instance . getHorizontalDOP (  )  ;  assertEquals ( loc0 ,  1 . 0 )  ;  } Note: This method assumes that the setUp (  )  method properly sets up the necessary test environment and that the expected value for horizontal DOP is 1 . 0 .  If the expected value is different ,  it should be updated accordingly in the assertEquals (  )  statement .  Also ,  the import statements for the necessary classes  ( e . g .  GSASentence ,  assertEquals )  are assumed to be present in the code . 
void function ( ResourceBundle arg0 )  { HashSet < String >  loc0 = new HashSet < String >  (  )  ;  Enumeration < String >  loc1 = arg0 . getKeys (  )  ;  while  ( loc1 . hasMoreElements (  )  )  { String loc2 = loc1 . nextElement (  )  ;  Assert . assertTrue ( "Duplicate key found: " + loc2 ,  !loc0 . contains ( loc2 )  )  ;  loc0 . add ( loc2 )  ;  } }
String function ( String arg0 )  { String loc0 = "" ;  try { File loc1 = new File ( arg0 )  ;  if  ( loc1 . isDirectory (  )  && loc1 . canWrite (  )  )  { loc0 = arg0 + "/logs" ;  File loc2 = new File ( loc0 )  ;  if  ( !loc2 . exists (  )  )  { loc2 . mkdir (  )  ;  } } else { loc0 = System . getProperty ( "user . dir" )  ;  } } catch  ( Exception e )  { getLogger (  )  . log ( Level . SEVERE ,  "Failed to get application LOG path" ,  e )  ;  } return loc0 ;  }
import java . io . OutputStream ;  public class Hex { Encoder encoder = new HexEncoder (  )  ;  int function ( String arg0 ,  OutputStream arg1 )  { byte [  ]  loc0 = arg0 . replaceAll ( "\\s" ,  "" )  . getBytes (  )  ;  return encoder . decode ( loc0 ,  0 ,  loc0 . length ,  arg1 )  ;  } }
public static boolean function ( Object arg0 ,  Object arg1 )  { try { if  ( arg0 == null || arg1 == null )  { return false ;  } else { String loc0 = arg0 . toString (  )  ;  String loc1 = arg1 . toString (  )  ;  if  ( loc1 . equalsIgnoreCase ( "false" )  || loc1 . equals ( Boolean . FALSE . toString (  )  )  )  { return false ;  } else { return loc0 . equals ( loc1 )  ;  } } } catch  ( Exception e )  { return false ;  } }
int function (  )  { int size = 0 ;  try { size = _all . size (  )  ;  } catch  ( Exception e )  { } return size ;  }
void function (  )  { try { flushEvents (  )  ;  clientFlushedEvents (  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
Thread function (  )  { Thread loc0 = this . waiter ;  this . waiter = null ;  return loc0 ;  }
void function ( InputStream arg0 )  { if  ( arg0 != null )  { try { arg0 . close (  )  ;  } catch  ( IOException loc0 )  { System . err . println ( "Input Stream management not safe: " + loc0 . getMessage (  )  )  ;  } } }
void function (  )  { long loc0 = -1 ;  long loc1 = 11 ;  ByteBuf loc2 = null ;  long loc3 = 0 ;  RPCFileWriteRequestTest test = new RPCFileWriteRequestTest (  )  ;  test . before (  )  ;  test . mBuffer = loc2 ;  test . OFFSET = loc0 ;  test . TEMP_UFS_FILE_ID = loc1 ;  test . LENGTH = loc3 ;  RPCFileWriteRequest req = new RPCFileWriteRequest ( loc0 ,  loc1 ,  loc2 ,  loc3 )  ;  test . assertInvalid ( req )  ;  } Note: This method calls the "before (  ) " method of the "RPCFileWriteRequestTest" class before setting the values of member variables and creating an instance of the "RPCFileWriteRequest" class .  It then calls the "assertInvalid (  ) " method of the "RPCFileWriteRequestTest" class to test the constructor with a negative offset . 
public static String function ( AggregationKindEnum arg0 )  { try { Class < ? extends AggregationKindEnum >  loc0 = arg0 . getClass (  )  ;  Package loc1 = loc0 . getPackage (  )  ;  String loc2 =  ( loc1 != null )  ? loc1 . getName (  )  + " . " : "" ;  String loc3 = loc0 . getSimpleName (  )  ;  return loc2 + loc3 ;  } catch  ( Exception e )  { return null ;  } }
BufferedImage function ( int arg0 ,  int arg1 )  { BufferedImage loc0 = ImageUtil . createCompatibleBufferedImage ( arg0 ,  arg1 ,  BufferedImage . TYPE_INT_RGB )  ;  ImageUtil . clearImage ( loc0 )  ;  return loc0 ;  }
import java . io . File ;  import java . io . IOException ;  import java . util . logging . Logger ;  public class TempFileUtils { private static final Logger LOG = Logger . getLogger ( TempFileUtils . class . getName (  )  )  ;  public static void function (  )  { try { File tempDir = File . createTempFile ( "temp" ,  Long . toString ( System . nanoTime (  )  )  )  ;  tempDir . delete (  )  ;  tempDir . mkdir (  )  ;  } catch  ( IOException e )  { LOG . warning ( "Failed to create temporary directory: " + e . getMessage (  )  )  ;  } } }
public void function ( Date arg0 )  { try { setFetcherStartTimeStamp ( arg0 )  ;  } catch  ( Exception e )  { } }
float function ( int arg0 ,  int arg1 )  { float loc0 = 0 . 0f ;  try { loc0 =  ( float ) arg1 /  ( float ) arg0 ;  } catch  ( ArithmeticException e )  { loc0 = 0 . 0f ;  } return loc0 ;  }
public int function (  )  { try { return yPosition ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  return -1 ;  } }
class SatelliteInfo { String id ;  int elevation ;  int noise ;  int azimuth ;  void setNoise ( int noise )  { this . noise = noise ;  } String getId (  )  { return id ;  } int getNoise (  )  { return noise ;  } int getElevation (  )  { return elevation ;  } void setAzimuth ( int azimuth )  { this . azimuth = azimuth ;  } int getAzimuth (  )  { return azimuth ;  } void setElevation ( int elevation )  { this . elevation = elevation ;  } void function ( String arg0 )  { try { String loc0 = arg0 ;  setId ( loc0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } void setId ( String arg0 )  { this . id = arg0 ;  } }
boolean function ( T arg0 )  { return nodePosition . containsKey ( arg0 )  ;  }
InetSocketAddress function ( SipMessage arg0 )  { String viaValue = arg0 . getFirstHeaderValue ( SipHeader . VIA )  . getBaseValue (  )  ;  String sentBy = StringUtils . substringAfterLast ( viaValue ,  "sent-by=" )  ;  String host = StringUtils . substringBefore ( sentBy ,  " ; " )  . trim (  )  ;  return new InetSocketAddress ( InetAddress . getByName ( host )  ,  5060 )  ;  }
String function ( MyComplexStruct obj )  { String loc0 = obj . elem2 ;  return loc0 ;  }
public void function (  )  { Time loc0 = new Time ( 12 ,  0 ,  45 . 0 )  ;  instance . setTime ( loc0 )  ;  assertTrue ( instance . getTime (  )  . toString (  )  . equals ( "12:00:45 . 0" )  )  ;  }
static boolean function ( final ByteBuffer arg0 )  { final int loc0 = arg0 . position (  )  ;  final UInt loc1 = arg0 . getUInt (  )  ;  arg0 . position ( loc0 )  ;  arg0 . putUInt ( UIntImpl . from ( 0 )  )  ;  final UInt loc2 = getChecksum ( arg0 )  ;  arg0 . position ( loc0 )  ;  return loc1 . equals ( loc2 )  ;  }
List < Vertice >  function ( Grafo arg0 )  { List < Vertice >  loc0 = new ArrayList <  >  ( arg0 . getVertices (  )  )  ;  Collections . sort ( loc0 )  ;  return loc0 ;  } Note: This function receives a { @ link Grafo} and returns a { @ link List} with its vertices sorted . 
void function ( Item arg0 )  { try { ItemStack loc0 = new ItemStack ( arg0 )  ;  this . mob . setCurrentItemOrArmor ( 0 ,  loc0 )  ;  } catch  ( Exception e )  { } }
void function ( LoadMetadataType arg0 )  { mLoadMetadataType = arg0 ;  }
AbstractPlugin function ( String arg0 )  { for  ( int loc0 = 0 ;  loc0  <  plugins . size (  )  ;  loc0 ++  )  { AbstractPlugin loc1 = plugins . getByIndex ( loc0 )  ;  if  ( loc1 . getName (  )  . equals ( arg0 )  )  { return loc1 ;  } } return null ;  }
public void function ( boolean arg0 )  { long loc0 = System . currentTimeMillis (  )  ;  if  ( arg0 )  { exclusive_time -= loc0 - inclusive_time ;  inclusive_time = loc0 ;  } else { exclusive_time += loc0 - inclusive_time ;  inclusive_time = loc0 ;  } }
public void function (  )  { mThrown . expect ( BlockDoesNotExistException . class )  ;  mThrown . expectMessage ( "Failed to get block" )  ;  try { BlockMeta loc0 = mMetaManagerView . getBlockMeta ( TEST_BLOCK_ID )  ;  } catch  ( BlockDoesNotExistException e )  { } }
Mode function ( Mode arg0 )  { Mode loc0 = FILE_UMASK . applyUMask ( arg0 )  ;  return loc0 . getUMask (  )  ;  }
public String function ( String arg0 ,  Charset arg1 )  { try { String encoded = URLEncoder . encode ( arg0 ,  arg1 )   . replace ( "+" ,  "%20" )   . replace ( "*" ,  "%2A" )   . replace ( "%7E" ,  "~" )  ;  return encoded ;  } catch  ( UnsupportedEncodingException e )  { System . err . println ( "Error encoding string: " + e . getMessage (  )  )  ;  return null ;  } }
public static void function ( String arg0 )  { try { File loc0 = new File ( arg0 )  ;  Files . createParentDirs ( loc0 )  ;  loc0 . createNewFile (  )  ;  } catch  ( IOException e )  { LOG . error ( "Error creating file: {}" ,  e . getMessage (  )  )  ;  } }
public void function (  )  { setUp (  )  ;  rmc . parse ( EXAMPLE )  ;  assertEquals ( 16 ,  rmc . getDate (  )  . getMonth (  )  )  ;  }
void function ( Document arg0 )  { doc = arg0 ;  eval (  )  ;  }
USAddress function (  )  { return billTo ;  }
void function (  )  { OutputStream loc0 = null ;  try { loc0 = mHttpConMock . getOutputStream (  )  ;  mThrown . thenThrow ( new IOException (  )  )  ;  mThrown . expect ( IOException . class )  ;  mThrown . expectMessage ( "IOException" )  ;  loc0 . close (  )  ;  } catch  ( IOException e )  { } }
public void function (  )  { createSymmetricKey (  )  ;  byte [  ]  loc0 = secret ;  LOG . info ( "Secret key generated successfully . " )  ;  }
public symbol function (  )  { symbol loc0 = _on_symbol ;  return loc0 ;  } Note: This method simply returns the symbol on which the transition is made ,  without any error handling or additional logic .  The method name ,  argument names ,  and variable names have been changed as per the instructions ,  but it is important to note that these changes may not be optimal for readability or clarity . 
void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { String loc0 = "Process the OPTIONS method . " ;  arg0 . setHeader ( "Allow" ,  "GET ,  POST ,  PUT ,  DELETE" )  ;  arg0 . getContentType (  )  ;  arg0 . setStatus ( 200 )  ;  }
public static boolean function ( Decision arg0 ,  Object arg1 )  { if  ( arg0 == arg1 )  { return true ;  } if  ( ! ( arg1 instanceof Decision )  )  { return false ;  } Decision loc0 = arg0 ;  Decision loc1 =  ( Decision )  arg1 ;  return loc0 . getName (  )  . equals ( loc1 . getName (  )  )  ;  }
import org . apache . cxf . message . Message ;  import org . apache . cxf . ws . addressing . ContextUtils ;  import org . apache . cxf . ws . addressing . MAPAggregator ;  public class RMContextUtils { public static void function ( Message arg0 ,  boolean arg1 )  { MAPAggregator loc0 = ContextUtils . retrieveMAPs ( arg0 )  ;  } }
GetOfferDetailsResponse . Return . DetailOfferData . Products . Product function (  )  { GetOfferDetailsResponse . Return . DetailOfferData . Products loc0 = createGetOfferDetailsResponseReturnDetailOfferDataProducts (  )  ;  List < GetOfferDetailsResponse . Return . DetailOfferData . Products . Product >  loc1 = loc0 . getProduct (  )  ;  return loc1 . get ( 0 )  ;  }
void function ( ServerSession arg0 ,  ServerMessage arg1 )  { loc0 = mock ( ServerSession . class )  ;  loc1 = mock ( ServerMessage . class )  ;  loc2 = new ActivityController (  )  ;  loc2 . deregisterUserSession ( arg0 ,  arg1 )  ;  }
void function (  )  { function (  )  ;  wireParser . closeConnection (  )  ;  } Note: The above method calls itself recursively without any exit condition ,  so it will result in a stack overflow error at runtime .  Also ,  it's not clear how the member variables and functions of the PaymentChannelClientConnection class are being used in this method . 
 @ Override public boolean hasPermission ( Authentication arg0 ,  Object arg1 ,  Object arg2 )  { try { throw new UnsupportedOperationException ( "We do not support this method call . " )  ;  } catch  ( UnsupportedOperationException loc0 )  { log . error ( "Error in hasPermission method: " + loc0 . getMessage (  )  )  ;  } return false ;  }
void function ( String [  ]  args )  { try { UIManager . setLookAndFeel ( UIManager . getSystemLookAndFeelClassName (  )  )  ;  } catch  ( Exception e )  { } OsmViewerPlusApp app = new OsmViewerPlusApp (  )  ;  MapViewFrame frame = app . getFrame (  )  ;  frame . readMap ( app . getULMFileResource (  )  )  ;  for  ( String arg : args )  { if  ( arg . startsWith ( "-screenwidth=" )  )  { String value = arg . substring ( "-screenwidth=" . length (  )  )  ;  int width = Integer . parseInt ( value )  ;  frame . setDefault ( width )  ;  } else if  ( arg . startsWith ( "-screensize=" )  )  { String value = arg . substring ( "-screensize=" . length (  )  )  ;  double size = Double . parseDouble ( value )  ;  frame . setDefault (  ( int )   ( size * 2 . 54 / Math . sqrt ( 2 )  )  )  ;  } } app . showFrame (  )  ;  }
void function (  )  { try { setUp (  )  ;  TTMParser loc0 = new TTMParser ( EXAMPLE )  ;  double loc1 = 7 . 0 ;  loc0 . setSpeed ( loc1 )  ;  double loc2 = loc0 . getSpeed (  )  ;  assertEquals ( loc1 ,  loc2 ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception was thrown: " + e . getMessage (  )  )  ;  } }
void function (  )  { try { ArrayList loc0 = dev . getCapabilities (  )  ;  System . out . println ( "Test of getCapabilities method ,  of class Device . " )  ;  assertEquals ( arg0 ,  loc0 . size (  )  )  ;  } catch  ( Exception loc1 )  { fail ( "The test case is a prototype . " ,  loc1 )  ;  } }
public static Position function ( Position arg0 ,  Position arg1 )  { return arg0 . isComparable ( arg0 . endLine ,  arg1 . endLine ,  arg0 . endColumn ,  arg1 . endColumn )  ?  ( arg0 . endLine  >  arg1 . endLine ||  ( arg0 . endLine == arg1 . endLine && arg0 . endColumn  > = arg1 . endColumn )  ? arg0 : arg1 )  : null ;  }
public void function ( String transformedTokenIdentifier ,  Object arg0 )  { try { setTransformedTokenIdentifier ( transformedTokenIdentifier )  ;  } catch  ( Exception loc0 )  { } }
List < VertexLabelType >  function (  )  { List < VertexLabelType >  loc0 = new ArrayList <  >  (  )  ;  try { for  ( VertexLabelType loc1 : vertexLabels )  { loc0 . add ( loc1 )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { RTETest testObj = new RTETest (  )  ;  testObj . setUp (  )  ;  testObj . rte . setRouteTypeWorking (  )  ;  testObj . assertTrue ( testObj . rte . isActiveRoute (  )  )  ;  }
float function (  )  { try { double lat1 = Math . toRadians (  ( double ) latMax )  ;  double lat2 = Math . toRadians (  ( double ) latMin )  ;  double lon1 = Math . toRadians (  ( double ) lonMax )  ;  double lon2 = Math . toRadians (  ( double ) lonMin )  ;  double dLon = lon2 - lon1 ;  double dLat = lat2 - lat1 ;  double a = Math . pow ( Math . sin ( dLat / 2 )  ,  2 )  + Math . cos ( lat1 )  * Math . cos ( lat2 )  * Math . pow ( Math . sin ( dLon / 2 )  ,  2 )  ;  double c = 2 * Math . atan2 ( Math . sqrt ( a )  ,  Math . sqrt ( 1 - a )  )  ;  double radius = 6371 ;  // Earth's radius in kilometers return  ( float )  ( radius * c )  ;  } catch  ( Exception loc0 )  { System . err . println ( "Error calculating distance: " + loc0 . getMessage (  )  )  ;  return 0 . 0f ;  } }
void function (  )  { final double loc0 = 10 . 0 ;  HDGTest test = new HDGTest (  )  ;  try { test . hdg . setDeviation ( loc0 )  ;  fail ( "Expected IllegalArgumentException was not thrown . " )  ;  } catch  ( IllegalArgumentException e )  { String message = e . getMessage (  )  ;  assertTrue ( message . contains ( "Deviation value" )  )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception was thrown: " + e . getMessage (  )  )  ;  } }
boolean function (  )  { if  ( mConnected )  { return true ;  } if  ( mClosed )  { return false ;  } synchronized  ( this )  { if  ( mConnected )  { return true ;  } if  ( mClosed )  { return false ;  } try { mProtocol . getTransport (  )  . open (  )  ;  mConnected = true ;  afterConnect (  )  ;  return true ;  } catch  ( TTransportException loc0 )  { LOG . warn ( String . format ( "Failed to connect to %s" ,  mAddress )  ,  loc0 )  ;  mConnected = false ;  return false ;  } } }
import java . util . Calendar ;  import java . util . TimeZone ;  public class DateUtils { public static Calendar function ( Date arg0 )  { TimeZone loc0 = TimeZone . getTimeZone ( "UTC" )  ;  Calendar loc1 = Calendar . getInstance ( loc0 )  ;  loc1 . setTime ( arg0 )  ;  return loc1 ;  } }
void function (  )  { DataNettyBuffer dataNettyBuffer = new DataNettyBuffer ( mBuffer )  ;  Assert . assertEquals ( LENGTH ,  dataNettyBuffer . getLength (  )  )  ;  }
void function ( String arg0 )  { this . testId = arg0 ;  }
void function (  )  { try { HDGTest test = new HDGTest (  )  ;  test . setUp (  )  ;  double loc0 = test . hdg . getDeviation (  )  ;  assertEquals ( 1 . 2 ,  loc0 ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
void function (  )  { LogEntryInterval loc0 = new LogEntryInterval (  )  ;  loc0 . setNumberRequests ( 5 )  ;  System . out . println ( "Test of getNumberRequests method ,  of class LogEntryInterval . " )  ;  assertEquals ( 5 ,  loc0 . getNumberRequests (  )  )  ;  }
char [  ]  function ( char [  ]  arg0 )  { int loc0 = 0 ;  int loc1 = arg0 . length - 1 ;  while  ( loc0  <  loc1 )  { char temp = arg0 [ loc0 ]  ;  arg0 [ loc0 ]  = arg0 [ loc1 ]  ;  arg0 [ loc1 ]  = temp ;  loc0 ++  ;  loc1 --  ;  } return arg0 ;  }
void function (  )  { Mode . Bits loc0 = Mode . Bits . WRITE_EXECUTE ;  Mode . Bits loc1 = Mode . Bits . WRITE ;  Mode . Bits loc2 = Mode . Bits . EXECUTE ;  Mode . Bits loc3 = Mode . Bits . READ_EXECUTE ;  Mode . Bits loc4 = Mode . Bits . READ ;  Mode . Bits loc5 = Mode . Bits . READ_WRITE ;  loc0 . or ( loc1 )  ;  Assert . assertEquals ( loc0 ,  Mode . Bits . WRITE_EXECUTE . or ( Mode . Bits . WRITE )  )  ;  loc1 . or ( loc2 )  ;  Assert . assertEquals ( loc1 ,  Mode . Bits . WRITE . or ( Mode . Bits . EXECUTE )  )  ;  loc2 . or ( loc3 )  ;  Assert . assertEquals ( loc2 ,  Mode . Bits . EXECUTE . or ( Mode . Bits . READ_EXECUTE )  )  ;  loc3 . or ( loc4 )  ;  Assert . assertEquals ( loc3 ,  Mode . Bits . READ_EXECUTE . or ( Mode . Bits . READ )  )  ;  loc4 . or ( loc5 )  ;  Assert . assertEquals ( loc4 ,  Mode . Bits . READ . or ( Mode . Bits . READ_WRITE )  )  ;  loc5 . or ( loc0 )  ;  Assert . assertEquals ( loc5 ,  Mode . Bits . READ_WRITE . or ( Mode . Bits . WRITE_EXECUTE )  )  ;  }
private void function ( Intent arg0 ,  int arg1 ,  Activity arg2 )  { try { arg2 . startActivityForResult ( arg0 ,  arg1 )  ;  } catch  ( ActivityNotFoundException loc0 )  { AlertDialog loc1 = new AlertDialog . Builder ( arg2 )   . setTitle ( TITLE )   . setMessage ( MESSAGE )   . setPositiveButton ( DEFAULT_YES ,  null )   . create (  )  ;  loc1 . show (  )  ;  } }
double function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  DenseMatrix64F arg2 )  { compute ( arg0 ,  arg1 ,  arg2 )  ;  double loc0 = diffNormF (  )  ;  return loc0 * loc0 / arg1 . numRows (  )  ;  }
DAVResource function ( URI arg0 )  { URI loc0 = arg0 ;  if  ( !loc0 . isAbsolute (  )  )  { loc0 = root . toURI (  )  . resolve ( loc0 )  ;  } URI loc1 = loc0 . normalize (  )  ;  DAVResource loc2 = factory . getResource ( loc1 )  ;  File loc3 = loc2 . getFile (  )  ;  File loc4 = loc3 . getAbsoluteFile (  )  ;  return loc2 ;  }
void function ( boolean arg0 )  { progressMonitor . isRunningOnServer (  )  ;  progressMonitor . showProgress = arg0 ;  progressMonitor . log . append ( "Logs a Message . " )  ;  System . out . println (  )  ;  }
static boolean function ( Pattern arg0 ,  String arg1 )  { Matcher loc0 = arg0 . matcher ( arg1 )  ;  return loc0 . find (  )  ;  }
boolean function ( UserModel arg0 )  { try { return userService . updateUserModel ( arg0 )  ;  } catch  ( Exception loc0 )  { logger . error ( "Error updating user model: " + arg0 . getUsername (  )  ,  loc0 )  ;  return false ;  } }
void function ( String arg0 )  { UnderFileSystemUtils . deleteDir ( arg0 )  ;  }
String function ( String arg0 )  { File loc0 = new File ( arg0 )  ;  BufferedReader loc1 = new BufferedReader ( new FileReader ( loc0 )  )  ;  String loc2 = readFile ( loc1 )  ;  String [  ]  [  ]  loc3 = prepareMatrix ( loc2 )  ;  return loc3 ;  }
public void function (  )  { try { Event loc0 = new Event ( "testEvent" ,  new HashMap < String , Object >  (  )  {{ put ( ActivityEvent . ID_KEY ,  "" )  ;  }} )  ;  acitivityController . handleEvent ( loc0 )  ;  } catch  ( IllegalArgumentException e )  { } }
String function ( Class < ? >  loc0 )  { String loc1 = ClassUtil . SHORT_NAMES_BY_TYPE . get ( loc0 )  ;  if  ( loc1 == null )  { loc1 = loc0 . getName (  )  ;  } return loc1 ;  }
public static Object function ( AccessibilityEvent arg0 ,  int arg1 )  { Object loc0 = null ;  try { loc0 = AccessibilityRecordCompat . IMPL . getRecord ( arg0 ,  arg1 )  ;  } catch  ( IndexOutOfBoundsException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
QRDecomposition < DenseMatrix64F >  function ( int arg0 ,  int arg1 )  { QRDecompositionHouseholderColumn_D64 qr = new QRDecompositionHouseholderColumn_D64 (  )  ;  qr . setExpectedMaxSize ( arg0 ,  arg1 )  ;  return qr ;  }
void function ( byte [  ]  arg0 ,  String arg1 )  { try { byte [  ]  loc0 = arg0 ;  String loc1 = arg1 ;  setBodyAsString ( loc1 )  ;  setEncoding ( _utf8 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public void function ( MenuItem arg0 ,  final OnClickListener arg1 )  { try { arg0 . setOnMenuItemClickListener ( new MenuItem . OnMenuItemClickListener (  )  {  @ Override public boolean onMenuItemClick ( MenuItem loc0 )  { arg1 . onClick ( loc0 . getActionView (  )  )  ;  return true ;  } } )  ;  } catch  ( Exception loc1 )  { } }
public void function (  )  { String arg0 = "$VWVHW , 000 . 0 , T , 001 . 5 , M , 1 . 0 , N , 1 . 85 , K" ;  VHWParser loc0 = new VHWParser ( arg0 )  ;  assertTrue ( loc0 . getTalkerId (  )  . equals ( "VW" )  )  ;  assertTrue ( loc0 . getSentenceId (  )  . equals ( "VHW" )  )  ;  assertTrue ( loc0 . valueOf ( "SPEED_KNOTS" )  == 0 . 0 )  ;  assertTrue ( loc0 . valueOf ( "MAGNETIC_HEADING" )  == 1 . 5 )  ;  }
void function (  )  { LOG . trace ( "Processing internal buffer" )  ;  m_protocolHandler . handleMessages (  )  ;  m_readBuffer . clear (  )  ;  }
double function (  )  { checkState ( count  >  1 )  ;  double loc0 = sumOfSquaresOfDeltas -  (  ( sum * sum )  / count )  ;  ensureNonNegative ( loc0 )  ;  loc0 /=  ( count - 1 )  ;  return isNaN ( loc0 )  ? Double . NaN : loc0 ;  } Note: This implementation calculates the unbiased sample variance using the formula: variance =  ( sumOfSquaresOfDeltas -  ( sum * sum / count )  )  /  ( count - 1 )  and ensures that the result is non-negative .  If there are any non-finite values in the dataset ,  the method returns Double . NaN .  The checkState (  )  method ensures that the count is greater than 1 before computing the variance . 
Object function (  )  { Object loc0 = getClassifier (  )  ;  Object [  ]  loc1 = loc0 . getClass (  )  . getMethods (  )  ;  for  ( Object loc2 : loc1 )  { if  ( loc2 . getName (  )  . equals ( arg0 )  && isAMethod ( loc2 )  )  { return loc2 ;  } } return null ;  }
void function ( HttpParams arg0 ,  boolean arg1 )  { try { setBooleanParameter ( arg0 ,  CoreConnectionPNames . TCP_NODELAY ,  arg1 )  ;  } catch  ( Throwable loc0 )  { } }
boolean function ( HttpServletRequest arg0 )  { String loc0 = arg0 . getHeader ( "User-Agent" )  ;  return  ( arg0 == null )  ? false : check ( loc0 )  ;  }
void function ( int arg0 ,  AbstractReportNode arg1 )  { try { childNodes . add ( arg0 ,  arg1 )  ;  arg1 . setParentNode ( this )  ;  } catch  ( IndexOutOfBoundsException loc0 )  { loc0 . printStackTrace (  )  ;  } }
boolean function (  )  { return bufferSize == 0 ;  }
public static  < T >  Function < Object ,  T >  function ( Supplier < T >  arg0 )  { return  ( arg1 )  - >  arg0 . get (  )  ;  }
void function (  )  { try { setUp (  )  ;  double arg0 = 100 . 0 ;  hdg . setHeading ( arg0 )  ;  double loc0 = hdg . getHeading (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
int function ( String arg0 )  { int loc0 = mAliasToTierViews . get ( arg0 )  . getTierViewOrdinal (  )  ;  int loc1 = mTierViews . size (  )  ;  StorageTierView loc2 = mTierViews . get (  ( loc0 + 1 )  % loc1 )  ;  return loc2 . getTierViewOrdinal (  )  ;  }
void function ( final String arg0 ,  final RestSearcher < YouTubeGDataVideo >  arg1 )  { arg1 . delete (  )  ;  final FileOutputStream loc0 = new FileOutputStream ( arg0 )  ;  final StringReader loc1 = new StringReader ( arg1 . toString (  )  )  ;  IOUtils . copy ( loc1 ,  loc0 )  ;  loc0 . flush (  )  ;  loc0 . close (  )  ;  }
void function ( THashSet < String >  arg0 )  { try { mWhitelist . addAll ( arg0 )  ;  } catch  ( Exception e )  { } }
int function ( String arg0 ,  Plan arg1 ,  String arg2 ,  Plan arg3 )  { Schema schema = new Schema (  )  ;  MergeJoinPlan mergeJoinPlan = new MergeJoinPlan ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  schema )  ;  boolean hasField1 = arg1 . schema (  )  . hasField ( arg0 )  ;  boolean hasField2 = arg3 . schema (  )  . hasField ( arg2 )  ;  int distinctValues = 0 ;  if  ( hasField1 && hasField2 )  { int distinctValues1 = arg1 . distinctValues ( arg0 )  ;  int distinctValues2 = arg3 . distinctValues ( arg2 )  ;  distinctValues = Math . min ( distinctValues1 ,  distinctValues2 )  ;  } return distinctValues ;  }
public static String function ( File arg0 )  { String result = null ;  try { result = arg0 . getCanonicalFile (  )  . getPath (  )  ;  } catch  ( IOException loc0 )  { result = arg0 . getAbsoluteFile (  )  . getPath (  )  ;  } return result ;  }
public int function ( DHGexParameters obj )  { int loc0 = obj . getPref_group_len (  )  ;  if  ( loc0  <  obj . getMin_group_len (  )  || loc0  >  obj . getMax_group_len (  )  )  { throw new IllegalArgumentException ( "Invalid preferred group length" )  ;  } return loc0 ;  }
double function ( DenseMatrix64F arg0 ,  double arg1 )  { double loc0 = 0 . 0 ;  for  ( int i = 0 ;  i  <  arg0 . getNumElements (  )  ;  i ++  )  { loc0 += arg0 . get ( i )  * arg0 . get ( i )  ;  } return Math . sqrt ( loc0 )  ;  }
public static double function ( D1Matrix64F arg0 )  { int loc0 = arg0 . getNumElements (  )  ;  double loc1 = 0 ;  for  ( int i = 0 ;  i  <  loc0 ;  i ++  )  { double loc2 = arg0 . get ( i )  ;  loc1 += loc2 * loc2 ;  } return loc1 ;  }
boolean function ( Object arg0 ,  Object arg1 )  { Object loc0 = getContextualProperty (  ( Message )  arg0 ,  "MessageDirection" ,  "unknown" )  ;  Object loc1 = getContextualProperty (  ( Message )  arg0 ,  "javax . xml . ws . binding . soap . message" ,  null )  ;  boolean loc2 = false ;  if  ( loc1 != null )  { loc2 =  (  ( Boolean )  loc1 )  . booleanValue (  )  ;  } else if  ( "Outbound" . equals ( loc0 )  )  { loc2 = true ;  } return loc2 ;  }
Expression function (  )  { Expression loc0 = null ;  try { loc0 = newValue (  )  ;  } catch  ( Exception loc1 )  { System . err . println ( "Error occurred while getting new value: " + loc1 . getMessage (  )  )  ;  } Predicate loc2 = pred (  )  ;  String loc3 = tableName (  )  ;  System . out . println ( "Field to be modified: " + fldname )  ;  return new Column ( loc3 ,  fldname )  ;  }
List < File >  function ( List < String >  arg0 ,  String arg1 )  { List < File >  loc0 = new ArrayList <  >  (  )  ;  for  ( String loc1 : arg0 )  { File loc2 = new File ( loc1 )  ;  loc0 . add ( loc2 )  ;  } StateImageSaver stateImageSaver = new StateImageSaver (  )  ;  stateImageSaver . suffix = arg1 ;  stateImageSaver . saveFiles ( "renamed" ,  "" ,  loc0 )  ;  return loc0 ;  }
boolean function ( ActivityRequest arg0 )  { boolean result = false ;  try { String loc0 = arg0 . getFeedId (  )  ;  Properties loc1 = arg0 . getConfigProperties (  )  ;  if  ( loc0 != null && loc1 != null && !loc1 . isEmpty (  )  )  { result = true ;  } } catch  ( Exception e )  { System . err . println ( "Error validating incoming request for mandatory parameters: " + e . getMessage (  )  )  ;  } return result ;  }
public byte [  ]  function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { byte [  ]  loc0 = new byte [ arg2 ]  ;  try { LZ4SafeDecompressor decompressor = new LZ4SafeDecompressor (  )  ;  decompressor . decompress ( arg0 ,  arg1 ,  loc0 ,  0 ,  arg2 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public static Map < String ,  Integer >  function ( String arg0 )  { String [  ]  loc0 = arg0 . replaceAll ( " ( ?s )  < ! --  . *? --  > " ,  "" )  . toLowerCase (  )  . split ( "\\W+" )  ;  Map < String ,  Integer >  loc1 = new HashMap <  >  (  )  ;  for  ( String loc2 : loc0 )  { loc1 . put ( loc2 ,  loc1 . getOrDefault ( loc2 ,  0 )  + 1 )  ;  } return loc1 ;  }
public AdaptableHeuristicFunction function ( Object arg0 ,  Map arg1 )  { try { AdaptableHeuristicFunction loc0 = new AdaptableHeuristicFunction (  )  ;  loc0 . setGoal ( arg0 )  ;  loc0 . setMap ( arg1 )  ;  return loc0 ;  } catch ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
int function ( int arg0 ,  int arg1 )  { int loc0 = 0 ;  try { loc0 = arg0 . emptyAnnotationRejects ;  } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { TestBufferedBlockOutStream loc0 = new TestBufferedBlockOutStream (  )  ;  byte [  ]  loc1 = INCREASING_BYTES . clone (  )  ;  loc0 . write ( loc1 ,  0 ,  loc1 . length )  ;  loc0 . flush (  )  ;  loc0 . setWrittenBytes ( BLOCK_LENGTH )  ;  assertEquals ( 0 ,  loc0 . remaining (  )  )  ;  loc0 . write ( loc1 ,  0 ,  loc1 . length )  ;  assertEquals ( BLOCK_LENGTH ,  loc0 . remaining (  )  )  ;  loc0 . flush (  )  ;  assertEquals ( BLOCK_LENGTH ,  loc0 . remaining (  )  )  ;  }
List < StorageTierView >  function ( String arg0 )  { int loc0 = mAliasToTierViews . get ( arg0 )  . getTierViewOrdinal (  )  ;  if  ( loc0 == 0 )  { return new ArrayList <  >  (  )  ;  } return mTierViews . subList ( 0 ,  loc0 )  . stream (  )   . map ( StorageTierView::getTierView )   . collect ( Collectors . toList (  )  )  ;  }
public DeterministicKey function ( DeterministicKey key )  { if  ( !key . hasPrivate (  )  )  { return key ;  } DeterministicKey parent = key . getParent (  )  ;  byte [  ]  chainCode = key . getChainCode (  )  ;  ImmutableList < ChildNumber >  childNumberPath = key . getChildNumberPath (  )  ;  ECPoint pubPoint = key . getPubPoint (  )  ;  return new DeterministicKey ( childNumberPath ,  pubPoint ,  parent ,  chainCode )  ;  }
Future < Void >  function (  )  { try { RecomputePlan loc0 = mPlan ;  if  ( loc0 . isEmpty (  )  )  { return Futures . immediateFuture ( null )  ;  } List < Callable < Void >  >  loc1 = mPlanner . plan ( loc0 )  ;  for  ( Callable < Void >  loc2 : loc1 )  { mRecomputeLauncherService . submit ( loc2 )  ;  } return Futures . immediateFuture ( null )  ;  } catch  ( Exception e )  { LOG . error ( "Failed to execute recompute plan" ,  e )  ;  return Futures . immediateFailedFuture ( e )  ;  } }
void function ( final String arg0 ,  final PropertyChangeListener arg1 )  { try { this . m_PropertyChangeSupport . removePropertyChangeListener ( arg0 ,  arg1 )  ;  } catch  ( final Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
String function (  )  { try { return transformation . withExceptionHandling (  new Trans < String >  (  )  { public String transform (  )  { return transformation . transformToString (  )  ;  } } )  . transform (  )  ;  } catch  ( Exception loc0 )  { return null ;  } }
ArrayList function (  )  { ArrayList loc0 = parameters ;  return loc0 ;  }
BigDecimal function ( PCLDataSetEntity arg0 )  { BigDecimal loc0 = null ;  try { loc0 = arg0 . getFileSize (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
HashMap < String , String >  function ( String arg0 ,  String arg1 ,  Component arg2 )  { HashMap < String , String >  loc0 = arg2 . getProperties (  )  ;  switch ( arg0 )  { case "background-color": if ( addBackgroundColor ( arg1 )  )  { loc0 . put ( arg0 ,  arg1 )  ;  } break ;  case "width": if ( addWidth ( arg1 )  )  { loc0 . put ( arg0 ,  arg1 )  ;  } break ;  } return loc0 ;  }
StatSource function ( int arg0 )  { StatSource loc0 = this . statSources . get ( arg0 )  ;  if  ( loc0 != null )  { return loc0 ;  } return null ;  }
void function ( Object arg0 ,  Object arg1 )  { Object loc0 = arg0 ;  Object loc1 = arg1 ;  }
void function ( Node arg0 )  { List < Node >  loc0 = nodeNameToNodes . get ( arg0 . toString (  )  )  ;  loc0 . add ( arg0 )  ;  }
public long function (  )  { try { return this . getTestId (  )  ;  } catch  ( Exception loc0 )  { System . out . println ( "An exception occurred: " + loc0 . getMessage (  )  )  ;  return -1 ;  } }
void function ( short arg0 )  { checkType ( 'S' )  ;  packLong (  ( long ) arg0 ,  true )  ;  } Note: It is assumed that the method checkType ( 'S' )  validates that the stream can accept a short value and throws an exception otherwise .  Also ,  the 'true' parameter in packLong method indicates that the value is signed . 
public TransactionOutputChanges function (  )  { TransactionOutputChanges loc0 = null ;  if  ( txOutChanges != null )  { loc0 = txOutChanges ;  } return loc0 ;  }
void function ( String arg0 )  { try { this . callbackHandlerClass = arg0 ;  LOG . fine ( "srini_string" + arg0 )  ;  } catch  ( Exception e )  { } }
public int function ( int arg0 ,  int arg1 )  { int loc0 = arg1 - arg0 ;  return loc0  <  0 ? -loc0 : loc0 ;  }
MTDFragmentAST function ( String arg0 )  { MTDFragmentAST loc0 = parseTree ( arg0 )  ;  HashMap < MTDFragmentAST ,  Tuple >  loc1 = new HashMap <  >  (  )  ;  IntegerHolder loc2 = new IntegerHolder (  )  ;  decorate ( loc0 ,  loc2 )  ;  return loc0 ;  }
void function ( THashSet < String >  arg0 )  { try { mBlacklist . addAll ( arg0 )  ;  System . out . println ( "Blacklist added to this hosts file . " )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while adding the blacklist to this hosts file: " + e . getMessage (  )  )  ;  } }
public BigDecimal function (  )  { BigDecimal loc0 = arg0 . getExpDataSetId (  )  ;  return loc0 ;  }
void function ( Long arg0 ,  String arg1 ,  Date arg2 ,  Long arg3 ,  String arg4 ,  Date arg5 ,  Date arg6 ,  Long arg7 ,  Date arg8 ,  List < TestResultDetailsDTO >  arg9 ,  OutcomeType arg10 ,  RunStatusType arg11 ,  Date arg12 )  { TestResultDTO loc0 = new TestResultDTO (  )  ;  loc0 . setFeedId ( arg0 )  ;  loc0 . setCreatedBy ( arg1 )  ;  loc0 . setFetcherStartTimeStamp ( arg2 )  ;  loc0 . setRunId ( arg3 )  ;  loc0 . setErrorMsg ( arg4 )  ;  loc0 . setLastModifiedTimeStamp ( arg5 )  ;  loc0 . setCreateTimeStamp ( arg6 )  ;  loc0 . setTestId ( arg7 )  ;  loc0 . setFetcherEndTimeStamp ( arg8 )  ;  loc0 . setRegTestResultDetailsLst ( arg9 )  ;  loc0 . setOutcome ( arg10 )  ;  loc0 . setRunStatus ( arg11 )  ;  loc0 . setLastModifiedTimeStamp ( arg12 )  ;  }
MetadataEditorCompat function ( Bitmap arg0 )  { MetadataEditorCompat loc0 = editMetadata ( true )  ;  loc0 . putBitmap ( RemoteControlClientCompat . METADATA_KEY_ARTWORK ,  arg0 )  ;  return loc0 ;  }
String function ( String arg0 )  { WorkflowJobBean loc0 = getWorkflow (  )  ;  WorkflowInstance loc1 = getWorkflowInstance (  )  ;  String loc2 = getVar ( arg0 )  ;  String loc3 = WorkflowInstance . NODE_VAR_SEPARATOR + ACTION_EXTERNAL_ID ;  return loc1 . getRecoveryId (  )  + loc3 + loc2 ;  }
String function ( ConfigurationKey arg0 )  { String loc0 = null ;  try { loc0 = config . getConfigurationHandler (  )  . getString ( arg0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
int function ( PackInputStream obj )  { try { int available = obj . format . available (  )  ;  int length ;  if  ( available  > = 0 )  { length = available ;  } else { length = obj . unpackInt ( true )  ;  } return length ;  } catch  ( IOException e )  { return -1 ;  } }
public String function ( int num )  { String result = "" ;  try { String [  ]  classNames = {"Class1" ,  "Class2" ,  "Class3"} ;  result = classNames [ num ]  ;  } catch  ( ArrayIndexOutOfBoundsException loc0 )  { System . out . println ( "Invalid class number!" )  ;  } return result ;  }
public void function (  )  { try { HDMTest hdmTest = new HDMTest (  )  ;  double arg0 = 45 . 0 ;  hdmTest . hdm . setHeading ( arg0 )  ;  double loc0 = hdmTest . hdm . getHeading (  )  ;  double arg1 = arg0 ;  double loc1 = loc0 ;  double arg2 = 0 . 001 ;  assertEquals ( arg1 ,  loc1 ,  arg2 )  ;  double arg3 = 360 . 0 ;  hdmTest . hdm . setHeading ( arg3 )  ;  double loc2 = hdmTest . hdm . getHeading (  )  ;  double arg4 = loc0 ;  double loc3 = loc2 ;  double arg5 = arg2 ;  assertEquals ( arg4 ,  loc3 ,  arg5 )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception was thrown: " + e . getMessage (  )  )  ;  } }
void function ( T arg0 )  { if ( position  > = max )  { position = 0 ;  haveOverflow = true ;  } circularArray . remove ( position )  ;  circularArray . add ( position ,  arg0 )  ;  position ++  ;  }
void function (  )  { try { mAlluxioMaster . start (  )  ;  } catch  ( Exception e )  { LOG . error ( "Failed to start Alluxio master" ,  e )  ;  throw new RuntimeException ( e )  ;  } }
void function ( String arg0 )  { identifier = arg0 ;  }
public static void function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { try { if  ( arg1  <  0 || arg1 + arg2  >  arg0 . length )  { throw new ArrayIndexOutOfBoundsException (  )  ;  } } catch  ( ArrayIndexOutOfBoundsException e )  { e . printStackTrace (  )  ;  } }
void function (  )  { try { mWriteLock . lockInterruptibly (  )  ;  mClientRWLock . referenceCounting (  )  ;  mClientRWLock . before (  )  ;  boolean loc0 = mClientRWLock . tryLock (  )  ;  assertFalse ( loc0 )  ;  mClientRWLock . notSameLock (  )  ;  mClientRWLock . unlock (  )  ;  mWriteLock . unlock (  )  ;  } catch  ( InterruptedException e )  { throw new RuntimeException ( e )  ;  } }
Long function ( TestResultDTO arg0 )  { Long loc0 = arg0 . getTestId (  )  ;  return loc0 ;  }
List < String >  function (  )  { List < String >  loc0 = new ArrayList < String >  (  )  ;  loc0 . addAll ( log )  ;  return loc0 ;  }
void function (  )  { try { RMCParser loc0 = new RMCParser ( EXAMPLE )  ;  loc0 . setDirectionOfVariation ( 'E' )  ;  loc0 . setVariation ( 4 . 5 )  ;  assertEquals ( 4 . 5 ,  loc0 . getVariation (  )  ,  0 . 01 )  ;  } catch  ( Exception loc1 )  { fail ( "Exception thrown: " + loc1 . getMessage (  )  )  ;  } }
public int function ( Date arg0 )  { long loc0 = System . currentTimeMillis (  )  - arg0 . getTime (  )  ;  int loc1 =  ( int )   ( loc0 / TimeUtils . MIN )  ;  return loc1 ;  }
File function ( Context arg0 )  { File loc0 = null ;  try { loc0 = new SysUtil (  )  . getLibsDirectory ( arg0 )  ;  if  ( !loc0 . isDirectory (  )  && !loc0 . mkdirs (  )  )  { throw new RuntimeException ( "Failed to create directory: " + loc0 )  ;  } } catch  ( Exception loc1 )  { throw new RuntimeException ( "Failed to get or create directory for native libraries" ,  loc1 )  ;  } return loc0 ;  }
Set < String >  function ( ResourceTypeHandler arg0 )  { Set < String >  loc0 = new HashSet <  >  (  )  ;  try { loc0 = extensionsDenied . get ( arg0 )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  }
void function (  )  { RPCFileReadResponse loc0 = new RPCFileReadResponse ( TEMP_UFS_FILE_ID ,  OFFSET ,  LENGTH ,  STATUS ,  mBuffer )  ;  int loc1 = loc0 . getEncodedLength (  )  ;  ByteBuf loc2 = loc0 . encode (  )  ;  Assert . assertEquals ( loc0 ,  RPCFileReadResponse . decode ( loc2 )  ,  "Encoded and decoded responses do not match" )  ;  }
String function ( Object .  .  .  args )  { String template = "Format the template with args ,  only supports the placeholder %s . " ;  return String . format ( Locale . ROOT ,  template ,  args )  ;  }
public static  < T >  List < T >  function ( T arg0 ,  T arg1 ,  T arg2 )  { List < T >  loc0 = new ArrayList <  >  ( 3 )  ;  loc0 . add ( arg0 )  ;  loc0 . add ( arg1 )  ;  loc0 . add ( arg2 )  ;  return loc0 ;  }
void function ( Class < ? ,  ? >  arg0 ,  Object arg1 )  { Assert . isInstanceOf ( arg0 ,  arg1 ,  "srini_string" )  ;  }
public static Definition function ( String arg0 ,  String arg1 )  { WSDLServiceFactory factory = WSDLServiceFactory . newInstance (  )  ;  WSDLServiceBuilder builder = factory . newWSDLServiceBuilder (  )  ;  ServiceEndpoint endpoint = builder . getEndpoint ( arg0 )  ;  Service service = endpoint . getService (  )  ;  List < ServiceInfo >  serviceInfos = service . getServiceInfos (  )  ;  builder . setUseSchemaImports ( true )  ;  Definition definition = builder . build ( serviceInfos . get ( 0 )  )  ;  return definition ;  }
String function ( String arg0 ,  int index )  { try { List < String >  loc0 = getList ( arg0 )  ;  String loc1 = loc0 . get ( index )  ;  return loc1 ;  } catch  ( Exception e )  { System . out . println ( NO_DATA_FOUND )  ;  return null ;  } }
long function (  )  { long loc0 = System . currentTimeMillis (  )  ;  long loc1 = getTimeStamp (  )  ;  boolean loc2 = isValid (  )  ;  if  ( loc2 )  { List < Sentence >  sentences = getSentences (  )  ;  for  ( Sentence sentence : sentences )  { long age = loc0 - sentence . getTimestamp (  )  ;  if  ( age  >  loc1 )  { loc2 = false ;  break ;  } } } return loc2 ;  }
void function (  )  { NoFileAssertListener (  )  ;  setCpdListener (  )  ;  add ( arg0 )  ;  File loc0 = new File ( BASE_TEST_RESOURCE_PATH + arg1 )  ;  loc0 . deleteOnExit (  )  ;  addedFile ( files ++  ,  loc0 )  ;  verify (  )  ;  }
public static Method function ( Class clazz ,  Method method )  { try { return ReflectionUtils . findMethod ( clazz ,  method . getName (  )  ,  method . getParameterTypes (  )  )  ;  } catch  ( Throwable t )  { return null ;  } }
void function ( Parcel arg0 ,  Map < ? extends Parcelable ,  ? extends Parcelable >  arg1 )  { arg0 . writeInt ( arg1 . size (  )  )  ;  for  ( Map . Entry < ? extends Parcelable ,  ? extends Parcelable >  loc0 : arg1 . entrySet (  )  )  { arg0 . writeParcelable ( loc0 . getKey (  )  ,  0 )  ;  arg0 . writeParcelable ( loc0 . getValue (  )  ,  0 )  ;  } }
String function ( StylesheetInfo arg0 )  { try { return arg0 . getTitle (  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  return null ;  } }
void function ( Timestamp arg0 )  { try { setModifiedDate ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
T function ( T arg0 ,  long arg1 ,  TimeUnit arg2 )  { if  ( done )  { return value ;  } else { synchronized  ( this )  { while  ( !done )  { try { if  ( arg1 == 0 )  { wait (  )  ;  } else { wait ( arg2 . toMillis ( arg1 )  )  ;  } } catch  ( InterruptedException loc0 )  { Thread . currentThread (  )  . interrupt (  )  ;  throw new RuntimeException ( loc0 )  ;  } } } return value ;  } }
boolean function ( Map map ,  Object key )  { boolean loc0 = map . containsKey ( key )  ;  Object loc1 = loc0 ? map . get ( key )  : null ;  return loc1 instanceof Boolean &&  (  ( Boolean )  loc1 )  . booleanValue (  )  ;  }
SettableFuture < PaymentChannelClientConnection >  channelOpenFuture (  )  { SettableFuture < PaymentChannelClientConnection >  loc0 = SettableFuture . create (  )  ;  channelOpenFuture . addListener (  (  )  - >  { PaymentChannelClientState state = state (  )  ;  switch  ( state )  { case NEW: loc0 . setException ( new IllegalStateException ( "Failed to open channel: " + state )  )  ;  break ;  case CHANNEL_OPEN: loc0 . set ( this )  ;  break ;  case CHANNEL_CLOSED: loc0 . setException ( new ClosedChannelException (  )  )  ;  break ;  default: throw new IllegalStateException ( "Unrecognized state: " + state )  ;  } } ,  loc1 - >  { loc0 . setException ( loc1 )  ;  } )  ;  return loc0 ;  }
String function (  )  { GraphViz graphViz = new GraphViz (  )  ;  graphViz . add ( "Hello" )  ;  graphViz . add ( "World" )  ;  String dotSource = graphViz . getDotSource (  )  ;  byte [  ]  img = graphViz . getGraph ( dotSource ,  "png" )  ;  graphViz . writeGraphToFile ( img ,  new File ( "/path/to/file . png" )  )  ;  return graphViz . end_graph (  )  ;  }
Timestamp function (  )  { Timestamp loc0 = this . modifiedDate ;  return loc0 ;  }
void function ( final int arg0 ,  final byte [  ]  arg1 ,  final int arg2 )  { arg1 [ arg2 ]  =  ( byte )  arg0 ;  arg1 [ arg2 + 1 ]  =  ( byte )   ( arg0  >  >  8 )  ;  arg1 [ arg2 + 2 ]  =  ( byte )   ( arg0  >  >  16 )  ;  arg1 [ arg2 + 3 ]  =  ( byte )   ( arg0  >  >  24 )  ;  }
void function ( String arg0 ,  Bundle arg1 ,  RequestListener arg2 ,  final Object arg3 )  { AsyncFacebookRunner runner = new AsyncFacebookRunner ( fb )  ;  runner . request ( arg0 ,  arg1 ,  "GET" ,  arg2 ,  arg3 )  ;  }
public void function ( OutputStream arg0 ,  String arg1 ,  SignatureType arg2 ,  String arg3 ,  String arg4 ,  Api arg5 ,  String arg6 )  { ServiceBuilder builder = new ServiceBuilder (  )   . debugStream ( arg0 )   . scope ( arg1 )   . signatureType ( arg2 )   . callback ( arg3 )   . apiSecret ( arg4 )   . api ( arg5 )   . apiKey ( arg6 )  ;  Class < ? extends Api >  loc0 = arg5 . getClass (  )  ;  Api loc1 = builder . createApi ( loc0 )  ;  }
boolean function ( CSSValue arg0 )  { short loc0 = arg0 . getPrimitiveType (  )  ;  if  ( isAbsoluteUnit ( loc0 )  )  { return true ;  } return false ;  }
public static boolean function (  )  { String loc0 = System . getProperty ( "os . name" )  ;  return loc0 != null && loc0 . toLowerCase (  )  . contains ( "mac" )  ;  }
public void function (  )  { try { Position loc0 = new Position ( 45 . 0 ,  -122 . 0 )  ;  double loc1 = loc0 . getLongitude (  )  ;  assertEquals ( -122 . 0 ,  loc1 ,  0 . 0 )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception: " + e . getMessage (  )  )  ;  } }
void function ( long arg0 ,  long arg1 ,  long arg2 )  { RPCFileReadRequest req = new RPCFileReadRequest ( arg0 ,  arg1 ,  arg2 )  ;  assertValid ( arg1 ,  arg0 ,  arg2 ,  req )  ;  } Note: This method creates an instance of the RPCFileReadRequest class using the provided arguments and then calls the assertValid method to check if the instance is valid without any exceptions being thrown . 
boolean function ( StoredBlock arg0 ,  StoredBlock arg1 )  { return arg0 . getChainWork (  )  . compareTo ( arg1 . getChainWork (  )  )   >  0 ;  }
void function ( IFetcherTesterDataUnitVerifier arg0 ,  Map < String , Field >  arg1 ,  IFetcherContext arg2 )  { this . fetcherRegDataUnitVerifier = arg0 ;  this . dataSetFieldColumnMapping = new HashMap <  >  ( arg1 )  ;  this . fetcherContext = arg2 ;  PCLDataSetEntity loc0 = new PCLDataSetEntity (  )  ;  List < String >  loc1 = this . fetcherRegDataUnitVerifier . buildFieldAndColumnMapping ( loc0 )  ;  for  ( String loc2 : loc1 )  { if  ( !this . dataSetFieldColumnMapping . containsKey ( loc2 )  )  { String loc3 = "The expected dataset doesn't contain the column: " + loc2 ;  this . LOGGER . warn ( loc3 )  ;  } } }
void function (  )  { try { if  ( connection != null && connection . isOpen (  )  )  { connection . close (  )  ;  } } catch  ( Exception loc0 )  { handleException ( "Error occurred while closing RabbitMQ connection" ,  loc0 )  ;  } finally { connection = null ;  } }
public Sha256Hash function (  )  { byte [  ]  loc0 = new byte [ arg2 . length + 1 ]  ;  System . arraycopy ( arg2 ,  0 ,  loc0 ,  0 ,  arg2 . length )  ;  loc0 [ loc0 . length - 1 ]  =  ( byte )  arg3 ;  return new Sha256Hash ( Utils . reverseBytes ( Sha256Hash . hashTwice ( loc0 )  )  )  ;  }
void function ( String arg0 ,  String arg1 ,  String arg2 )  { ASTElement loc0 = element ( arg0 )  ;  ASTElement loc1 = element ( arg1 )  ;  ASTElement loc2 = element ( arg2 )  ;  tagList . openTag ( loc0 )  ;  tagList . openTag ( loc1 )  ;  tagList . openTag ( loc2 )  ;  tagList . closeTag ( loc1 )  ;  tagList . closeTag ( loc0 )  ;  assertFalse ( loc0 . isUnclosed (  )  )  ;  assertFalse ( loc1 . isUnclosed (  )  )  ;  assertTrue ( loc2 . isUnclosed (  )  )  ;  }
void function ( char [  ]  arg0 ,  int arg1 ,  int arg2 )  { try { if  ( !inCDATA )  { String data = new String ( arg0 ,  arg1 ,  arg2 )  ;  data = data . replaceAll ( " < ! --  . *? --  > " ,  "" )  ;  char [  ]  newData = data . toCharArray (  )  ;  writer . writeCharacters ( newData ,  0 ,  newData . length )  ;  } } catch  ( XMLStreamException e )  { throw new SAXException ( e )  ;  } }
int function ( Object .  .  .  args )  { HashCodeBuilder builder = new HashCodeBuilder ( 17 ,  37 )  ;  for  ( Object arg : args )  { builder . append ( arg )  ;  } return builder . toHashCode (  )  ;  }
void function ( String arg0 )  { try { setFilepath ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
void function (  )  { _sharedContext . flushFonts (  )  ;  _sharedContext . getReplacedElementFactory (  )  . clean ( _sharedContext )  ;  _sharedContext . getUac (  )  . clean (  )  ;  _sharedContext . getCss (  )  . disposeCache (  )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = "" ;  try { loc0 = getZipFileExtension (  )  ;  if  ( uniqueName . endsWith ( loc0 )  )  { loc0 = uniqueName . substring ( 0 ,  uniqueName . length (  )  - loc0 . length (  )  )  ;  } else { loc0 = uniqueName ;  } loc0 += loc0 ;  } catch  ( Exception e )  { } return loc0 ;  }
long function (  )  { try { return getValue (  )  *  ( long ) Math . pow ( 10 ,  SMALLEST_UNIT_EXPONENT )  ;  } catch  ( Exception e )  { } return 0 ;  }
boolean function ( String arg0 )  { String loc0 = "this" ;  String loc1 = "super" ;  return  ( arg0 . equals ( loc0 )  || arg0 . equals ( loc1 )  )  ;  }
void function (  )  { TTMParser empty = new TTMParser (  )  ;  String EXAMPLE = "$RATTM , 11 , 25 . 3 , 13 . 7 , T , 7 . 0 , 20 . 0 , T , 10 . 1 , 20 . 2 , N , NAME , Q ,  , 175550 . 24 , A*34" ;  TTMParser ttm = new TTMParser (  )  ;  ttm . parse ( EXAMPLE )  ;  Date loc0 = ttm . getTime (  )  ;  assertNotNull ( loc0 )  ;  assertEquals ( 11 ,  loc0 . getHours (  )  )  ;  assertEquals ( 25 ,  loc0 . getMinutes (  )  )  ;  assertEquals ( 50 ,  loc0 . getSeconds (  )  )  ;  }
public class Echo { private String string1 ;  public void setString1 ( String value )  { this . string1 = value ;  } public String function (  )  { String result = "" ;  try { result = this . string1 ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  } return result ;  } }
void function ( String arg0 )  { this . userName = arg0 ;  }
void function (  )  { m_markedForRemoval = true ;  m_removed = true ;  }
boolean function ( Object arg0 )  { boolean loc0 = isLink ( arg0 )  ;  if  ( loc0 )  { Object loc1 = uac . isVisited (  )  ;  String loc2 = nsh . getLinkUri (  )  ;  } return loc0 ;  }
public Object function ( String command ,  Object .  .  .  args )  { try { return webEngine . executeScript ( command ,  args )  ;  } catch  ( Exception loc0 )  { return null ;  } }
Result function ( ResultLevel arg0 )  { Result loc0 = new Result (  )  ;  for  ( ResultEntry loc1 : this . log )  { if  ( loc1 . getLevel (  )  . compareTo ( arg0 )   > = 0 )  { loc0 . add ( loc1 )  ;  } } return loc0 ;  }
class Metrics { PackageStats TOP_LEVEL_PACKAGE = new PackageStats (  )  ;  OperationMetric calculator ;  PackageStats getTopLevelPackageStats (  )  { return TOP_LEVEL_PACKAGE ;  } ClassMetric getCalculator (  )  { return calculator ;  } OperationMetric getCalculator (  )  { return calculator ;  } void function ( String code ,  OperationAST node )  { OperationMetric loc0 = getCalculator (  )  ;  Metric loc1 = loc0 . getMetric ( code )  ;  loc1 . addToTotal ( node )  ;  TOP_LEVEL_PACKAGE . compute (  )  ;  } }
void function ( PropertyChangeListener arg0 ,  Object arg1 ,  PropertyChangeEvent arg2 )  { removeAllElementListeners ( arg0 )  ;  if  ( isRemoved ( arg1 )  )  { LOG . warn ( "Object has been removed . " )  ;  return ;  } initialiseListener ( arg0 ,  arg1 )  ;  }
LinearSolver < DenseMatrix64F >  function ( int arg0 ,  int arg1 )  { LinearSolverFactory factory = new LinearSolverFactory (  )  ;  LinearSolver < DenseMatrix64F >  solver = factory . linear ( arg0 )  ;  if  ( arg1  >  arg0 )  { solver = factory . leastSquares ( arg0 ,  arg1 )  ;  } return solver ;  }
long function (  )  { return dataSetId ;  }
void function ( Timestamp arg0 )  { try { this . modifiedDate = arg0 ;  } catch  ( Exception e )  { } }
void function ( String arg0 )  { try { initInternal ( arg0 )  ;  } catch  ( Exception loc0 )  { LOG . error ( "Error initializing Translator: " + loc0 . getMessage (  )  ,  loc0 )  ;  } }
long function ( byte [  ]  arg0 ,  int arg1 )  { long loc0 = 0 ;  for  ( int loc1 = 7 ;  loc1  > = 0 ;  loc1 --  )  { loc0 =  ( loc0  <  <  8 )  |  ( arg0 [ arg1 + loc1 ]  & 0xff )  ;  } return loc0 ;  }
int function ( ConfigurationKey arg0 )  { int loc0 = 0 ;  try { loc0 = getFactory (  )  . getConfigurationHandler (  )  . getInteger ( arg0 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { progressMonitor . setCurValue ( progressMonitor . getCurValue (  )  + 1 )  ;  }
Collection < Edge >  function ( Node arg0 )  { Collection < Edge >  loc0 = null ;  try { loc0 = graph . getIncidentEdges ( arg0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
String function (  )  { String address = null ;  try { HttpHost host = new HttpHost (  )  ;  InetAddress loc0 = localServer . getServiceAddress (  )  ;  String hostName = loc0 . getHostName (  )  ;  int port = loc0 . getPort (  )  ;  host = new HttpHost ( hostName ,  port )  ;  address = host . toString (  )  ;  } catch  ( Exception e )  { } return address ;  }
String function ( RMProperties props )  { String loc0 = props . namespaceURI ;  if  ( loc0 == null )  { SequenceType loc1 = props . getSequence (  )  ;  loc0 = loc1 . getNamespaceURI (  )  ;  } return loc0 ;  }
void function ( long arg0 )  { repository . delete ( arg0 )  ;  } Note: Please make sure to handle exceptions appropriately in your actual code . 
int function (  )  { try { StatInfo loc0 = ti . stats (  )  ;  int loc1 = loc0 . distinctValues ( arg0 )  ;  return loc1 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return -1 ;  } }
void function ( long targetSequenceNumber )  { while  ( !session . isShutdown (  )  && !haveAcknowledgementFor ( targetSequenceNumber )  )  { CountDownLatch waitLatch = new CountDownLatch ( 1 )  ;  synchronized  ( sendLock )  { sendBuffer . computeIfAbsent ( targetSequenceNumber ,  k - >  null )  ;  waitForAckLatch . set ( waitLatch )  ;  } try { waitLatch . await ( 50L ,  TimeUnit . MILLISECONDS )  ;  } catch  ( InterruptedException e )  { Thread . currentThread (  )  . interrupt (  )  ;  } } }
void function (  )  { try { long loc0 = 22 ;  long loc1 = 11 ;  ByteBuf loc2 = null ;  long loc3 = 0 ;  RPCFileWriteRequest req = new RPCFileWriteRequest ( loc0 ,  loc1 ,  loc2 ,  loc3 )  ;  int expectedLength = req . getPayloadDataBuffer (  )  . readableBytes (  )  ;  ByteBuf encoded = req . encode (  )  ;  int encodedLength = encoded . readableBytes (  )  ;  Assert . assertEquals ( expectedLength ,  req . getEncodedLength (  )  )  ;  Assert . assertEquals ( expectedLength ,  encodedLength )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
SpringChain function (  )  { try { SpringChain springChain = new SpringChain (  )  ;  springChain . registry . addSpringConfig ( DEFAULT_MAIN_TENSION ,  DEFAULT_MAIN_FRICTION )  ;  springChain . registry . addSpringConfig ( DEFAULT_ATTACHMENT_TENSION ,  DEFAULT_ATTACHMENT_FRICTION )  ;  springChain . mMainSpringConfig = springChain . registry . getSpringConfig ( DEFAULT_MAIN_TENSION ,  DEFAULT_MAIN_FRICTION )  ;  springChain . mAttachmentSpringConfig = springChain . registry . getSpringConfig ( DEFAULT_ATTACHMENT_TENSION ,  DEFAULT_ATTACHMENT_FRICTION )  ;  springChain . id = springChain . mSpringSystem . registerSpringChain ( springChain )  ;  return springChain ;  } catch  ( Exception loc0 )  { return null ;  } }
boolean function ( File loc0 )  { return loc0 . exists (  )  ;  }
String function ( PCLDataSetEntity arg0 )  { String loc0 = "" ;  try { loc0 = arg0 . getChecksumType (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public void function ( AbstractDosPlugin arg0 )  { arg0 . setUp (  )  ;  arg0 . setUpClass (  )  ;  String loc0 = arg0 . getName (  )  ;  assertTrue ( loc0 . length (  )   >  0 )  ;  arg0 . tearDownClass (  )  ;  arg0 . tearDown (  )  ;  }
public Long function (  )  { Long loc0 ;  try { loc0 =  ( arg0 != null && arg0 . getInactivityTimeout (  )  != null )  ? arg0 . getInactivityTimeout (  )  : arg1 . get ( 5000L )  ;  } catch  ( Exception loc1 )  { loc0 = null ;  } return loc0 ;  }
public ELEvaluator function ( Element arg0 ,  Date arg1 ,  Configuration arg2 )  { Element loc0 = arg0 . getChild ( "sla:info" ,  arg0 . getNamespace (  )  )  ;  String loc1 = loc0 . getAttributeValue ( "nominal-time" )  ;  Date loc2 = CoordELFunctions . evalAndWrap ( loc1 ,  arg1 ,  Date . class )  ;  ELEvaluator loc3 = CoordELFunctions . createEvaluator (  )  ;  CoordELFunctions . setConfigToEval ( loc3 ,  arg2 )  ;  loc3 . setVariable ( CoordELConstants . NOMINAL_TIME_EL ,  loc2 )  ;  CoordELFunctions . configureEvaluator ( loc3 ,  loc0 )  ;  return loc3 ;  }
Sentence function ( String arg0 ,  String arg1 )  { try { SentenceId loc0 = SentenceId . parseStr ( arg0 )  ;  Class < ? extends SentenceParser >  loc1 = parsers . get ( loc0 . toString (  )  )  ;  if  ( loc1 == null )  { throw new RuntimeException ( "No parser registered for: " + loc0 )  ;  } Sentence loc2 = instance . createParserImpl ( loc0 . toString (  )  ,  arg1 )  ;  if  ( !loc1 . isInstance ( loc2 )  )  { throw new RuntimeException ( "Parser returned unexpected type: " + loc2 . getClass (  )  )  ;  } return  ( Sentence )  loc2 ;  } catch  ( Exception e )  { throw new RuntimeException ( "Failed to create parser for: " + arg0 ,  e )  ;  } }
TimestampService function (  )  { try { TimestampService loc0 = new TimestampServiceImpl (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { return null ;  } }
void function ( String version )  { try { lastVersion = version ;  SharedPreferences prefs = context . getSharedPreferences ( TAG ,  Context . MODE_PRIVATE )  ;  SharedPreferences . Editor editor = prefs . edit (  )  ;  editor . putString ( VERSION_KEY ,  version )  ;  editor . commit (  )  ;  } catch  ( Exception e )  { Log . e ( TAG ,  "Error setting last version" ,  e )  ;  } }
void function ( InputStream arg0 )  { _buffer = new byte [ 16 ]  ;  resolver = null ;  setRef ( 0 ,  arg0 )  ;  startCall (  )  ;  writeMethod ( "HessianInput" )  ;  completeCall (  )  ;  InputStream loc0 =  ( InputStream )  readObject (  )  ;  setRef ( 0 ,  loc0 )  ;  }
void function ( boolean arg0 )  { verifyProofOfPossession = arg0 ;  }
public PolicyPublisher function (  )  { return policyPublisher ;  }
Options function (  )  { Options loc0 = getOptions (  )  ;  return loc0 ;  }
void function ( ARDrone arg0 ,  CommandManager cmd )  { drone = arg0 ;  ourInstance . cmd = cmd ;  ourInstance . TAG = "GMC" ;  ourInstance . hoverTime = 2000 ;  ourInstance . speed = 10 ;  ourInstance . batLvl = 0 ;  ourInstance . threadTimer = 0 ;  ourInstance . spinSpeed = 2 ;  ourInstance . spin90Speed = 50 ;  ourInstance . spinTime = 50 ;  ourInstance . spin90Time = 3000 ;  }
void function ( T arg0 ,  String arg1 ,  BitmapDisplayConfig arg2 ,  BitmapLoadCallBack arg3 )  { arg3 . onPreLoad ( arg0 ,  arg1 ,  arg2 )  ;  arg3 . onLoadStarted ( arg0 ,  arg1 ,  arg2 )  ;  try { Bitmap loc0 = loadImage ( arg1 ,  arg2 )  ;  arg3 . onLoadCompleted ( arg0 ,  arg1 ,  loc0 ,  arg2 ,  BitmapLoadFrom . NETWORK )  ;  arg3 . setBitmap ( arg0 ,  loc0 )  ;  } catch  ( IOException loc1 )  { Drawable loc2 = arg3 . getDrawable ( arg0 )  ;  arg3 . onLoadFailed ( arg0 ,  arg1 ,  loc2 )  ;  arg3 . setDrawable ( arg0 ,  loc2 )  ;  } } Note: This is just a rough implementation of the function without proper exception handling .  It assumes that there is a method called "loadImage" that loads the image from a given URI and returns a Bitmap object . 
void function ( ErrorQueue arg0 ,  Report arg1 )  { arg1 . setQueue ( arg0 )  ;  }
void function ( Stylesheet arg0 )  { stylesheet = arg0 ;  } The function sets the "stylesheet" attribute of the "StylesheetInfo" object to the input parameter "arg0" .  No exception handling is done in this method . 
public Auth function (  )  { Auth loc0 = this . auth ;  return loc0 ;  }
public static void function ( JSONObject arg0 ,  String arg1 ,  Object arg2 )  { try { arg0 . put ( arg1 ,  arg2 )  ;  } catch  ( JSONException e )  { String loc0 = "Error adding key/value pair to JSON object: " + arg1 + "/" + arg2 ;  LOG . warn ( loc0 ,  e )  ;  } }
boolean function ( View arg0 ,  AccessibilityEvent arg1 )  { return IMPL . dispatchPopulateAccessibilityEvent ( DEFAULT_DELEGATE ,  arg0 ,  arg1 )  ;  }
String function ( String arg0 )  { int loc0 = Integer . parseInt ( arg0 ,  16 )  ;  int loc1 =  ( loc0 & 0xFF0000 )   >  >  16 ;  int loc2 =  ( loc0 & 0xFF00 )   >  >  8 ;  int loc3 = loc0 & 0xFF ;  Color loc4 = new Color ( loc1 ,  loc2 ,  loc3 )  ;  return getClosestNamedColor ( loc4 )  ;  }
Schema function (  )  { Schema loc0 = new Schema (  )  ;  loc0 . addAll ( p1 . schema (  )  )  ;  loc0 . addAll ( p2 . schema (  )  )  ;  return loc0 ;  }
Long function (  )  { return arg0 . batchId ;  }
void function ( String arg0 ,  String arg1 ,  Double arg2 )  { links . set ( arg0 ,  arg1 ,  arg2 )  ;  }
void function ( String arg0 ,  int arg1 )  { try { addField ( arg0 ,  Types . VARCHAR ,  arg1 )  ;  } catch  ( Exception e )  { } }
public static void function ( Collection < ? >  arg0 ,  String arg1 )  { try { Assert . notNull ( arg0 ,  "Collection must not be null" )  ;  if ( CollectionUtils . isEmpty ( arg0 )  )  { throw new IllegalArgumentException ( arg1 )  ;  } } catch ( IllegalArgumentException loc0 )  { throw loc0 ;  } }
void function (  )  { AmazonS3Client loc0 = Mockito . mock ( AmazonS3Client . class )  ;  TransferManager loc1 = Mockito . mock ( TransferManager . class )  ;  S3AUnderFileSystem loc2 = new S3AUnderFileSystem ( new AlluxioURI ( "srini_string" )  ,  loc0 ,  BUCKET_NAME ,  BUCKET_PREFIX ,  BUCKET_MODE ,  ACCOUNT_OWNER ,  loc1 )  ;  }
public class Mapping { int blockSize ;  long tStart ;  long qStart ;  long tStop ;  long getTStart (  )  { return tStart ;  } long getTStop (  )  { return tStop ;  } long getQStart (  )  { return qStart ;  } void function (  )  { try { blockSize = someMethodThatGetsTheBlockSize ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred: " + e . getMessage (  )  )  ;  } } }
boolean function ( Object arg0 )  { String loc0 =  ( String )  arg0 ;  return cascadedProperties . containsKey ( loc0 )  ;  }
boolean function ( SPResponse spResponse )  { Integer loc0 = spResponse . getErrorCode (  )  ;  return loc0 != 0 ;  }
OutputStream function (  )  { try { if  ( this . getStatus (  )  == -1 )  { this . setStatus ( HttpServletResponse . SC_OK )  ;  } this . response . setContentType ( "text/xml ;  charset=\"utf-8\"" )  ;  OutputStream loc0 = this . response . getOutputStream (  )  ;  return loc0 ;  } catch  ( Exception e )  { throw new RuntimeException ( e )  ;  } }
String function (  )  { StringBuilder builder = new StringBuilder (  )  ;  for  ( String loc0 : log )  { builder . append ( loc0 )  ;  } String result = builder . toString (  )  . trim (  )  ;  try { return result ;  } catch  ( Exception loc1 )  { return null ;  } }
 @ Override public int hashCode (  )  { int hash = 8 * y + x ;  return hash ;  }
void function ( Scan arg0 ,  Constant arg1 ,  String arg2 )  { Constant loc0 = arg0 . getVal ( arg2 )  ;  if  ( loc0 . compareTo ( arg1 )   >  0 )  { arg1 = loc0 ;  } }
import org . apache . commons . lang3 . StringUtils ;  public class Metric { public boolean function ( String arg0 ,  CharSequence arg1 )  { try { boolean loc0 = StringUtils . contains ( arg0 ,  arg1 )  ;  return loc0 ;  } catch  ( Exception e )  { return false ;  } } }
public U2FService function ( Object arg0 ,  Object arg1 )  { synchronized  ( U2FService . class )  { U2FService loc0 = u2FService ;  if  ( loc0 == null )  { loc0 = new U2FService (  )  ;  u2FService = loc0 ;  } return loc0 ;  } } This method returns a singleton instance of the U2FService class .  The synchronized block ensures that only one thread can access the instantiation code at a time ,  preventing race conditions .  The method uses lazy initialization ,  so the instance is not created until it is needed .  If the instance already exists ,  it is simply returned .  The method takes two generic objects as arguments ,  but they are not used in the implementation of the method . 
ResponseEntity < DishCollection >  function (  @ PathVariable String arg0 )  { try { log . debug ( "REST request to get DishCollection : {}" ,  arg0 )  ;  return dishCollectionService . findOne ( arg0 )   . map ( loc0 - >  new ResponseEntity <  >  ( loc0 ,  HttpStatus . OK )  )   . orElse ( new ResponseEntity <  >  ( HttpStatus . NOT_FOUND )  )  ;  } catch  ( Exception e )  { log . error ( "Error occurred while fetching DishCollection : {}" ,  arg0 ,  e )  ;  return new ResponseEntity <  >  ( HttpStatus . INTERNAL_SERVER_ERROR )  ;  } }
public Script function ( List < TransactionSignature >  arg0 ,  ECKey arg1 )  { ScriptBuilder scriptBuilder = new ScriptBuilder (  )  ;  byte [  ]  sigBytes = arg0 . get ( 0 )  . encodeToBitcoin (  )  ;  scriptBuilder . data ( sigBytes )  ;  Script redeemScript = ScriptBuilder . createOutputScript ( arg1 )  ;  scriptBuilder . data ( redeemScript . getProgram (  )  )  ;  return scriptBuilder . build (  )  ;  }
import static org . hamcrest . MatcherAssert . assertThat ;  import static org . hamcrest . Matchers . nullValue ;  import static org . mockito . Mockito . when ;  public class TestStaticClientConfigurationService { String issuer = "https://www . example . com/" ;  StaticClientConfigurationService service ;  RegisteredClient mockClient ;  ServerConfiguration mockServerConfig ;  void function (  )  { try { prepare (  )  ;  when ( mockServerConfig . getIssuer (  )  )  . thenReturn ( null )  ;  service . getClientConfiguration (  )  ;  assertThat ( service . getClientConfiguration (  )  ,  is ( nullValue (  )  )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } } void prepare (  )  { } void getClientConfiguration_success (  )  { } }
public void function ( ExtraDhcpOption . Builder arg0 ,  String arg1 )  { arg0 . id ( arg1 )  ;  }
void function ( boolean arg0 )  { accountNonExpired = arg0 ;  }
String function ( Object arg0 )  { Element loc0 =  ( Element )  arg0 ;  return loc0 . getAttribute ( "lang" )  ;  }
public AbstractAction function (  )  { if  ( undoAction != null )  { return undoAction . getRedoAction (  )  ;  } else { return null ;  } }
Collection < Device >  function (  )  { Collection < Device >  loc0 ;  try { loc0 = devices . values (  )  ;  } catch ( Exception e )  { loc0 = new ArrayList <  >  (  )  ;  } return loc0 ;  }
boolean function (  )  { return this . accountNonLocked ;  }
List < Station >  function ( Object arg0 )  { List < Station >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = stationDao . find (  )  . asList (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { for  ( Block loc0 : pins )  { Buffer loc1 = buffers . get ( loc0 )  ;  loc1 . unpin (  )  ;  } pins . clear (  )  ;  buffers . clear (  )  ;  }
void function ( String arg0 )  { if  ( debug )  { String loc0 = " [ " + servletName + " ]  " + arg0 ;  context . log ( loc0 )  ;  } }
public void function (  )  { boolean loc0 = settings . getBoolean ( Keys . git . serveRepositories ,  true )  ;  int loc1 = settings . getInteger ( Keys . git . serveOverHttpPort ,  -1 )  ;  if  ( loc0 && loc1  >  0 )  { serverStatus . active = true ;  } }
void function ( byte [  ]  arg0 )  { try { addByteArray ( arg0 )  ;  } catch  ( IOException loc0 )  { } } Note: Since the method "addByteArray" is not included in the given class ,  I assume that it is a missing method and needs to be implemented .  The function simply calls this missing method and handles any potential IO exceptions that may occur . 
HashMap < String ,  GeneticProfile >  function (  )  { HashMap < String ,  GeneticProfile >  loc0 = new HashMap <  >  (  )  ;  try { loc0 = getDefaultGeneticProfileMap ( true ,  false )  ;  } catch  ( Exception e )  { System . out . println ( "An error occurred while getting the default mutation profiles: " + e . getMessage (  )  )  ;  } return loc0 ;  }
String function (  )  { return this . executionEndDateTime ;  }
public void function (  )  { try { TTMParser loc0 = new TTMParser ( EXAMPLE )  ;  loc0 . setNumber ( 1 )  ;  int loc1 = loc0 . getNumber (  )  ;  assertEquals ( 1 ,  loc1 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
Bits function ( Bits arg0 ,  Bits arg1 ,  Bits arg2 )  { Mode mode = new Mode (  )  ;  Mode uMask = mode . getUMask (  )  ;  mode . set ( arg0 ,  arg1 ,  arg2 )  ;  mode = mode . applyUMask ( uMask )  ;  return mode . getUMask (  )  . and ( mode . SVALS [ 7 ]  )  ;  }
public static void function ( ReceiverLossListEntry [  ]  entries )  { Arrays . sort ( entries ,  Comparator . comparingLong ( ReceiverLossListEntry::getSequenceNumber )  )  ;  }
void function ( long arg0 ,  TimeUnit arg1 )  { if  ( arg1 == null )  { throw new IllegalArgumentException ( "srini_string" )  ;  } poolLock . lock (  )  ;  try { idleConnHandler . closeIdleConnections ( arg1 . toMillis ( arg0 )  )  ;  } finally { poolLock . unlock (  )  ;  } }
void function ( BinaryBytesEvent event ,  EventListener listener )  { ParserEventType loc0 = event . getType (  )  ;  byte [  ]  loc1 = event . data ;  listener . processBinaryBytes ( loc0 ,  loc1 )  ;  }
void function (  )  { try { TTMParser loc0 = new TTMParser ( EXAMPLE )  ;  double loc1 = 25 . 3 ;  assertEquals ( loc1 ,  loc0 . getBearing (  )  ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
boolean function ( int arg0 )  { AbstractPlugin loc0 = plugins . getByIndex ( arg0 )  ;  return plugins . remove ( loc0 )  ;  }
import java . lang . annotation . Annotation ;  import java . util . * ;  public class ClasspathScanner { private String ALL_FILES = "**/*" ;  private String WILDCARD = "*" ;  private String [  ]  PACKAGES_TO_SKIP = {"org . apache . cxf"} ;  private ClasspathScanner HELPER ;  private String ALL_CLASS_FILES = ALL_FILES + " . class" ;  private String CLASSPATH_URL_SCHEME = "classpath:" ;  public Map < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  function ( Collection < String >  arg0 ,  List < Class < ? extends Annotation >  >  arg1 ,  ClassLoader arg2 )  { try { return findClassesInternal ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( ClassNotFoundException e )  { e . printStackTrace (  )  ;  return Collections . emptyMap (  )  ;  } } private Map < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  findClassesInternal ( Collection < String >  basePackages ,  List < Class < ? extends Annotation >  >  annotations ,  ClassLoader loader )  throws ClassNotFoundException { Map < Class < ? extends Annotation >  ,  Collection < Class < ? >  >  >  map = new HashMap <  >  (  )  ;  for  ( String packageName : basePackages )  { Set < Class < ? >  >  classes = new HashSet <  >  ( getClasspathScanner (  )  . scanForClasses ( packageName ,  WILDCARD ,  ALL_CLASS_FILES ,  loader ,  PACKAGES_TO_SKIP )  )  ;  for  ( Class < ? >  clazz : classes )  { for  ( Class < ? extends Annotation >  annotation : annotations )  { if  ( clazz . isAnnotationPresent ( annotation )  )  { map . computeIfAbsent ( annotation ,  k - >  new HashSet <  >  (  )  )  . add ( clazz )  ;  } } } } return map ;  } }
void function ( ObjectOutputStream arg0 )  throws IOException { arg0 . defaultWriteObject (  )  ;  arg0 . writeInt ( length (  )  )  ;  for  ( int loc0 = 0 ;  loc0  <  length (  )  ;  loc0 ++  )  { arg0 . writeDouble ( get ( loc0 )  )  ;  } } This method serializes the state of the "AtomicDoubleArray" object to an output stream .  It first calls the defaultWriteObject (  )  method to serialize any non-transient fields of the object's superclass ,  then writes the length of the array as an integer ,  and finally writes each element of the array as a double .  There is no exception handling included in this method . 
function ( Date arg0 )  { try { fetcherEndTimeStamp = arg0 ;  } catch  ( Exception e )  { System . out . println ( "An exception occurred while setting the fetcher end time stamp: " + e . getMessage (  )  )  ;  } }
String function (  )  { return user ;  }
import java . io . IOException ;  import java . nio . file . * ;  public class UnderFileSystemUtils { public void function ( String arg0 )  throws IOException { Path loc0 = Paths . get ( arg0 )  ;  Files . createFile ( loc0 )  ;  } }
void function ( int arg0 )  { if  ( arg0 == 0 )  { mManager . scrollToPosition ( 0 )  ;  } page_now = 1 ;  listview . setRefreshing ( true )  ;  refresh_default . run (  )  ;  listview . getAdapter (  )  . notifyDataSetChanged (  )  ;  }
BufferedImage function ( String arg0 ,  int arg1 )  { try { BufferedImage loc0 = ImageIO . read ( new File ( arg0 )  )  ;  BufferedImage loc1 = Scalr . getLargeThumbnail ( loc0 ,  arg1 )  ;  return loc1 ;  } catch  ( IOException loc2 )  { Popup . error ( "Error reading image: " + loc2 . getMessage (  )  )  ;  return null ;  } }
public static CertificateInfo function ( String arg0 ,  String arg1 )  { CertificateInfo loc0 = null ;  try { loc0 = CertificateInfo . getInstance ( arg0 ,  arg1 )  ;  } catch  ( CertificateException loc1 )  { } return loc0 ;  }
public void function (  )  { try { panel . getSharedContext (  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public static ApplicationManagementService function (  )  { try { ApplicationManagementService loc0 = ApplicationManagementServiceImpl . getInstance (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { System . err . println ( "Failed to get instance of ApplicationManagementService: " + loc1 . getMessage (  )  )  ;  return null ;  } }
void function (  )  { MemoryLocksService loc0 = new MemoryLocksService (  )  ;  Services loc1 = new Services (  )  ;  loc1 . registerService ( loc0 )  ;  loc0 . init ( loc1 )  ;  loc0 . instrument ( null )  ;  loc0 . locks . clear (  )  ;  }
void function ( byte [  ]  arg0 )  { int loc0 = arg0 . length + 2 ;  ensureCapacity ( loc0 )  ;  putShort (  ( short )  arg0 . length )  ;  put ( arg0 )  ;  }
int function ( long arg0 )  { int loc0 = 1 ;  if  ( arg0  <  0 )  { loc0 = 10 ;  } else if  ( arg0  <  1  <  <  7 )  { loc0 = 1 ;  } else if  ( arg0  <  1  <  <  14 )  { loc0 = 2 ;  } else if  ( arg0  <  1  <  <  21 )  { loc0 = 3 ;  } else if  ( arg0  <  1  <  <  28 )  { loc0 = 4 ;  } else { loc0 = 5 ;  } return loc0 ;  }
public CoordinatorEngine function ( String arg0 ,  String arg1 )  { CoordinatorEngine loc0 = null ;  try { loc0 = new CoordinatorEngine ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public static long function ( String amount )  { long loc0 ;  try { loc0 = COIN . multiply ( FRIENDLY_FORMAT . parse ( amount )  )  . getValue (  )  ;  } catch  ( IllegalArgumentException e )  { throw new RuntimeException ( "Invalid amount: " + amount ,  e )  ;  } if  ( loc0  <  0 )  { throw new RuntimeException ( "Amount too small: " + amount )  ;  } if  ( loc0  >  MAX_SATOSHIS )  { throw new RuntimeException ( "Amount too large: " + amount )  ;  } return loc0 ;  }
import java . awt . Desktop ;  import java . net . URI ;  import java . net . URL ;  import java . util . logging . Logger ;  public class StartBrowser { private static final Logger LOG = Logger . getLogger ( StartBrowser . class . getName (  )  )  ;  public static void function ( URL arg0 )  { try { openUrl ( arg0 . toExternalForm (  )  )  ;  } catch  ( Exception loc0 )  { LOG . severe ( "Error opening URL: " + loc0 . getMessage (  )  )  ;  } } private static void openUrl ( String arg0 )  throws Exception { if  ( Desktop . isDesktopSupported (  )  )  { Desktop . getDesktop (  )  . browse ( new URI ( arg0 )  )  ;  } else { Runtime . getRuntime (  )  . exec ( "xdg-open " + arg0 )  ;  } } }
Position function ( QQ arg0 ,  ExtensionInfo arg1 ,  Type arg2 )  { Position loc0 = arg2 . position (  )  ;  if  ( loc0 == Position . COMPILER_GENERATED )  { loc0 = arg1 . typeSystem (  )  . getPosition ( arg0 . FILE ,  arg0 . DECL )  ;  } return loc0 ;  }
Integer function (  )  { Integer loc0 = this . errorCode ;  return loc0 ;  }
void function ( int arg0 )  { tokenHash = arg0 ;  }
public DiffBuilder function ( Object arg0 )  { Source control = getSource ( arg0 )  ;  return new DiffBuilder (  )   . ignoreComments (  )   . withNodeMatcher ( nodeMatcher )   . withComparisonController ( comparisonController )   . withNamespaceContext ( namespaceContext )   . withAttributeFilter ( attributeFilter )   . withComparisonListeners ( comparisonListeners )   . withDifferenceEvaluator ( differenceEvaluator )   . checkForIdentical (  )   . withTestSource ( control )   . withComparisonResultsToCheck ( comparisonResultsToCheck )   . withDifferenceListeners ( differenceListeners )   . ignoreWhitespace (  )   . checkForSimilar (  )   . normalizeWhitespace (  )   . withNodeFilter ( nodeFilter )  ;  }
class SatelliteInfo { int elevation ;  int noise ;  int azimuth ;  String id ;  void setId ( String arg0 )  { id = arg0 ;  } int getNoise (  )  { return noise ;  } int getElevation (  )  { return elevation ;  } void setAzimuth ( int arg0 )  { azimuth = arg0 ;  } int getAzimuth (  )  { return azimuth ;  } void setElevation ( int arg0 )  { elevation = arg0 ;  } void setNoise ( int arg0 )  { noise = arg0 ;  } void function (  )  { try { System . out . println ( "Satellite ID: " + id )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Error occurred: " + loc0 . getMessage (  )  )  ;  } } }
private void function ( EndpointInfo arg0 ,  QName arg1 ,  Bus arg2 )  { try { Object loc0 = getTargetReference ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( RuntimeException e )  { getLogger (  )  . warning ( "Error getting target reference: " + e . getMessage (  )  )  ;  incomingObserver . onException ( e )  ;  throw e ;  } }
public static RoleList function (  )  { try { RoleList loc0 = new RoleList (  )  ;  return loc0 ;  } catch  ( Exception loc1 )  { } }
void function ( Object arg0 ,  String arg1 ,  Object arg2 ,  Object arg3 )  { if  ( arg0 instanceof arg2 . getClass (  )  )  { try { Field loc0 = getFieldImpl ( arg2 . getClass (  )  ,  arg1 )  ;  Class loc1 = getClass ( loc0 ,  arg2 . getClass (  )  . getName (  )  )  ;  loc0 . setAccessible ( true )  ;  loc0 . set ( arg2 ,  arg3 )  ;  } catch  ( Exception e )  { } } }
byte [  ]  function (  )  { ByteArrayOutputStream loc0 = new ByteArrayOutputStream (  )  ;  try { serializeToStream ( loc0 )  ;  } catch  ( IOException loc1 )  { throw new RuntimeException ( loc1 )  ;  } return loc0 . toByteArray (  )  ;  }
boolean function ( Object arg0 )  { Element loc0 =  ( Element )  arg0 ;  return ui . isActive ( loc0 )  ;  }
void function ( String arg0 ,  String arg1 )  { try { OutputStreamWriter loc0 = this . processWriter ;  loc0 . write ( arg0 + " " + arg1 + "\n" )  ;  loc0 . flush (  )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } }
void function ( ContextFactory arg0 ,  Dim loc0 )  { try { loc0 . attachTo ( arg0 )  ;  } catch  ( Exception e )  { } }
void function (  )  { remove ( "someKey" )  ;  // Replace "someKey" with the actual key to remove String authString = toString (  )  ;  System . out . println ( authString )  ;  }
boolean function ( String arg0 ,  String arg1 )  { String loc0 = userRepoPrefix + arg0 + "/" ;  return arg1 . startsWith ( loc0 )  ;  }
boolean function ( String arg0 )  { try { Matcher loc0 = mIPv6Pattern . matcher ( arg0 )  ;  return loc0 . matches (  )  ;  } catch  ( Exception loc1 )  { Log . loc0 ( "Error in function: " ,  loc1 . getMessage (  )  ,  loc1 )  ;  return false ;  } }
MapMaker function ( MapMaker mapMaker )  { try { return mapMaker . setKeyStrength ( Strength . WEAK )  ;  } catch  ( NullPointerException e )  { } return null ;  }
public void function ( int arg0 ,  int arg1 )  { try { DenseMatrix64F loc0 = RandomMatrices . createRandom ( arg0 ,  arg1 ,  new Random ( 5745784 )  )  ;  checkItAll ( loc0 )  ;  } catch  ( RuntimeException loc1 )  { System . err . println ( loc1 . getMessage (  )  )  ;  } }
String function ( String arg0 )  { String loc0 = "" ;  Interaction loc1 = new Interaction (  )  ;  loc1 . setPmids ( arg0 )  ;  loc0 = loc1 . getPmids (  )  ;  return loc0 ;  }
public ResultEntry function ( Result result ,  int index )  { ResultEntry resultEntry = null ;  try { resultEntry = result . get ( index )  ;  } catch  ( IndexOutOfBoundsException e )  { } return resultEntry ;  }
ConfigurationKey function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 )  { ConfigurationKey loc0 = new ConfigurationKeyImpl ( arg0 ,  arg1 )  ;  ConfigurationKey loc1 = new ConfigurationKeyImpl ( arg2 ,  arg3 )  ;  ConfigurationKey loc2 = loc0 . append ( loc1 )  ;  return loc2 ;  }
String function ( Scan arg0 )  { MaxFn loc0 = new MaxFn (  )  ;  loc0 . processFirst ( arg0 )  ;  while  ( arg0 . hasNext (  )  )  { loc0 . processNext ( arg0 )  ;  } return "maxof" + loc0 . fldname ;  }
long function (  )  { try { final long loc0 = System . currentTimeMillis (  )  ;  final long loc1 = this . m_startTime ;  return loc0 - loc1 ;  } catch  ( Exception e )  { return -1 ;  } }
void function (  )  { setUp (  )  ;  time . setHours ( 10 )  ;  time . setMinutes ( 20 )  ;  time . setSeconds ( 30 )  ;  time . setMilliseconds ( 40 )  ;  testGetMinutes (  )  ;  assertEquals ( 20 ,  time . getMinutes (  )  )  ;  }
Set < String >  function ( Jedis jedis )  { Set < String >  termCounterKeys = new HashSet <  >  (  )  ;  try { Set < String >  urls = jedis . smembers ( "urls" )  ;  for  ( String url : urls )  { String key = "TermCounter:" + url ;  termCounterKeys . add ( key )  ;  } } catch  ( Exception e )  { } return termCounterKeys ;  }
Site function ( String arg0 )  { log . debug ( "Getting site with id: {}" ,  arg0 )  ;  Site loc0 = siteRepository . findOne ( arg0 )  ;  return loc0 ;  }
String function (  )  { String loc0 = "" ;  List < String >  loc1 = actionsFunction . apply ( initialState )  ;  for  ( String loc2 : loc1 )  { loc0 += loc2 + ": " + resultFunction . apply ( initialState ,  loc2 )  + " .  " ;  } return loc0 . trim (  )  ;  }
public static String function ( Date arg0 )  { try { TimeUtils utils = new TimeUtils (  )  ;  return utils . timeAgo ( arg0 )  ;  } catch  ( Exception loc0 )  { return "" ;  } }
public class InternalErrorHandler { public void function ( String arg0 )  { try { voidFunction ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  System . exit ( 0 )  ;  } } private void voidFunction ( String arg0 )  throws Exception { throw new Exception ( arg0 )  ;  } }
static void function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 ,  Object arg4 ,  Object arg5 ,  Object arg6 )  { try { TokenMapper . replacedTokens = new ArrayList (  )  ;  TokenMapper . parentScope = 0 ;  TokenMapper . functionBracePositions = new ArrayList (  )  ;  TokenMapper . funcObjects = new ObjArray (  )  ;  TokenMapper . functionNum = 0 ;  TokenMapper . functionVarMappings = new ArrayList (  )  ;  TokenMapper . lastTokenCount = 0 ;  } catch  ( Exception e )  { System . err . println ( "Error resetting TokenMapper static members: " + e . getMessage (  )  )  ;  } }
public void function ( HttpServletRequest arg0 )  { try { UserInfo user = new UserInfo (  )  ;  user . loginUser ( user . EMAIL ,  arg0 )  ;  HttpSession session = arg0 . getSession (  )  ;  session . removeAttribute ( user . getEmailId ( arg0 )  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public int function ( String arg0 )  { int loc0 ;  try { loc0 = Integer . parseInt ( arg0 )  ;  } catch  ( NumberFormatException loc1 )  { throw new IllegalArgumentException ( "Cannot convert MultiplicityRange bound string to an integer: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
String function ( String loc0 ,  String loc1 ,  int loc2 ,  String loc3 )  { mainMethodClassName = loc3 ;  return mainMethodClassName ;  } Note: This method sets the value of the member variable "mainMethodClassName" to the input argument "loc3" and returns the value of "mainMethodClassName" . 
static byte function ( int arg0 )  { final byte loc0 = 1 ;  assert arg0  > = 0 && arg0  <  8 ;  return  ( byte )   ( loc0  <  <  arg0 )  ;  }
Class function ( NotationName arg0 ,  int arg1 )  { Notation notation = findNotation ( arg0 )  ;  NotationProvider provider = notation . getNotationProvider ( arg1 )  ;  return provider . getClass (  )  ;  }
void function ( byte [  ]  byteArray ,  String fileName )  { try { FileOutputStream fos = new FileOutputStream ( fileName )  ;  fos . write ( byteArray )  ;  fos . close (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error saving file: " + e . toString (  )  )  ;  } System . out . println ( "File saved successfully!" )  ;  }
void function ( DirectedAcyclicGraphNode < T >  arg0 ,  DirectedAcyclicGraphNode < T >  arg1 )  { Preconditions . checkState ( arg0 . contains ( arg1 )  ,  "arg1 is not a child of arg0" )  ;  arg0 . getChildren (  )  . remove ( arg1 )  ;  }
public Object function ( Object arg0 ,  String arg1 ,  Class < ? >  [  ]  arg2 ,  Object .  .  .  arg3 )  { Class < ? >  loc0 = getClass ( arg0 . getClass (  )  . getClassLoader (  )  ,  arg0 . getClass (  )  . getName (  )  )  ;  Method loc1 = getMethod ( loc0 ,  arg1 ,  arg2 )  ;  return loc1 . invoke ( arg0 ,  arg3 )  ;  } This method takes an object instance as its first argument  ( arg0 )  ,  the name of the method to be called  ( arg1 )  ,  and an array of Class objects representing the types of the arguments to be passed to the method  ( arg2 )  .  It uses the getClass (  )  method to obtain the Class object corresponding to the type of the object instance ,  then uses getMethod (  )  to obtain a reference to the method to be called .  Finally ,  it invokes the method using the invoke (  )  method of the Method class ,  passing in the object instance and the argument values as parameters .  The method returns the result of the method call ,  which may be null if the method returns void . 
void function ( String arg0 ,  OperationSignature arg1 )  { if  ( !operations . containsKey ( arg1 )  )  { operations . put ( arg1 ,  new HashMap <  >  (  )  )  ;  } Map < String ,  OperationStats >  loc0 = operations . get ( arg1 )  ;  if  ( !loc0 . containsKey ( arg0 )  )  { loc0 . put ( arg0 ,  new OperationStats (  )  )  ;  } }
Script function ( byte [  ]  arg0 ,  List < byte [  ]  >  arg1 )  { Preconditions . checkArgument ( arg1 . size (  )   >  0 )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . smallNum ( arg1 . size (  )  )  ;  for  ( byte [  ]  data : arg1 )  { builder . data ( data )  ;  } builder . smallNum ( arg0 . length )  ;  builder . data ( arg0 )  ;  builder . smallNum ( arg1 . size (  )  )  ;  for  ( int i = 0 ;  i  <  arg1 . size (  )  ;  i ++  )  { builder . op ( OP_CHECKSIGVERIFY )  ;  } builder . op ( OP_CHECKMULTISIG )  ;  return builder . build (  )  ;  }
public void function (  )  { Time time = new Time (  )  ;  try { time . setHour ( -1 )  ;  fail ( "Expected IllegalArgumentException was not thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { } }
public T function ( T arg0 ,  String arg1 )  { Tag tag = new Tag ( "ownedBy" ,  arg1 )  ;  TypedItemMapper loc0 = mapper ;  PlatformLayerKey loc1 = loc0 . toKey ( arg0 . getClass (  )  ,  arg0 . getId (  )  )  ;  loc0 . addTag ( loc1 ,  tag )  ;  return loc0 . putItem ( arg0 )  ;  }
void function (  )  { try { RPCBlockReadRequest loc0 = new RPCBlockReadRequest ( LENGTH ,  OFFSET ,  LOCK_ID ,  SESSION_ID ,  BLOCK_ID ,  mBuffer )  ;  int loc1 = loc0 . getEncodedLength (  )  ;  ByteBuf loc2 = Unpooled . buffer ( loc1 )  ;  loc0 . encode ( loc2 )  ;  RPCBlockReadRequest loc3 = RPCBlockReadRequest . decode ( loc2 )  ;  assertValid ( BLOCK_ID ,  OFFSET ,  LENGTH ,  LOCK_ID ,  SESSION_ID ,  loc3 )  ;  Assert . assertEquals ( loc1 ,  loc2 . readableBytes (  )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  Assert . fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
int function ( ServalDatagramPacket packet )  { return packet . offset ;  }
public ArrayList < String >  function ( Map < String ,  Double >  arg0 )  { Map < String ,  Double >  loc0 = evaluate (  )  ;  loc0 . putAll ( arg0 )  ;  ArrayList < String >  loc1 = sortByValue ( loc0 )  ;  return loc1 ;  }
String function ( MessageReader arg0 )  { String loc0 = readAttributeValue ( arg0 ,  SOAP_ENCODING_REF_1_2 )  ;  if  ( loc0 == null )  { loc0 = readAttributeValue ( arg0 ,  SOAP_ENCODING_REF_1_1 )  ;  } return loc0 ;  }
String function (  )  { List < String >  locList = getLocations (  )  ;  String randomLoc = Util . selectRandomlyFromList ( locList )  ;  return randomLoc ;  }
public Object function ( String arg0 )  { Object loc0 = bundle . get ( arg0 )  ;  if  ( loc0 instanceof ShareOpenGraphObject )  { return String . valueOf ( loc0 )  ;  } else { return loc0 ;  } } This method takes a String argument "arg0" which is used to retrieve an object from the member variable "bundle" .  If the retrieved object is an instance of "ShareOpenGraphObject" ,  it is converted to a String using the "String . valueOf (  ) " method and returned .  Otherwise ,  the object is returned as is .  This method does not handle any exceptions . 
void function (  )  { if  ( connectedHandler != null )  { connectedHandler . close (  )  ;  } }
Date function ( String arg0 ,  String arg1 )  { Date loc0 = new Date (  )  ;  ParsePosition loc1 = new ParsePosition ( 0 )  ;  SimpleDateFormat loc2 = new SimpleDateFormat ( arg1 )  ;  loc0 = loc2 . parse ( arg0 ,  loc1 )  ;  return loc0 ;  }
boolean function ( boolean arg0 )  { selected = arg0 ;  return selected ;  }
void function ( Object item )  { try { mArray . add ( item )  ;  } catch  ( Exception e )  { } }
boolean function ( String arg0 ,  String arg1 )  { try { return userService . renameRepositoryRole ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { logger . error ( "Error renaming repository role: {}" ,  e . getMessage (  )  )  ;  return false ;  } }
public void function ( BundleContext arg0 )  { for  ( AutoSIMConnectionConfig loc0 : config . connections )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } }
void function ( int arg0 ,  int arg1 ,  String arg2 ,  int arg3 )  { unifiedBreak ( arg0 ,  1 ,  " " ,  arg3 )  ;  }
void function (  )  { try { CollisionDJBX33X collision = new CollisionDJBX33X (  )  ;  String arg0 = "example" ;  int loc0 = collision . hashForth ( arg0 . substring ( 0 ,  7 )  )  ;  int arg1 = 1178162601 ;  assertEquals ( arg1 ,  loc0 )  ;  System . out . println ( "Hash forward first 7 Characters" )  ;  } catch  ( Exception e )  { System . out . println ( "Error occurred: " + e . getMessage (  )  )  ;  } }
void function (  )  { clearHash (  )  ;  clear (  )  ;  fireMapDataEvent ( new MapEvent ( "reset" )  )  ;  System . out . println ( "No data available after this reset . " )  ;  } Note: Since the original code was not provided ,  I assumed the presence of the methods "clearHash (  ) " ,  "clear (  ) " ,  and "fireMapDataEvent ( MapEvent event ) " and added a print statement to indicate that the data has been reset .  Also ,  I added the import statement for "MapEvent" . 
boolean function (  )  { return results . isEmpty (  )  ;  }
void function ( int arg0 ,  int arg1 )  { Rect loc0 = getFramingRect (  )  ;  loc0 . top =  ( loc0 . height (  )  - arg0 )  / 2 ;  loc0 . bottom = loc0 . top + arg0 ;  loc0 . left =  ( loc0 . width (  )  - arg1 )  / 2 ;  loc0 . right = loc0 . left + arg1 ;  Log . d ( TAG ,  "Calculated framing rect: " + loc0 )  ;  } This method allows third party apps to specify the scanning rectangle dimensions by calling the CameraManager's "getFramingRect" method and modifying the dimensions based on the arguments passed in .  The new dimensions are then logged using Log . d without exception handling . 
I'm sorry ,  I cannot perform this task as the method "tokenToString (  ) " already exists in the AccessToken class and it returns the string representation of the access token .  Therefore ,  there is no need to create a new method with the same functionality . 
Map < String ,  String >  function ( String groupName )  { Map < String ,  String >  loc0 = null ;  try { SCIMGroupHandler groupHandler = new SCIMGroupHandler (  )  ;  loc0 = groupHandler . getGroupAttributesById ( groupHandler . getGroupId ( groupName )  )  ;  } catch  ( Exception e )  { Log logger = LogFactory . getLog ( SCIMGroupHandler . class )  ;  logger . error ( "Failed to retrieve group attributes for group " + groupName ,  e )  ;  } return loc0 ;  }
long function (  )  { long loc0 = getTime (  )  ;  int loc1 =  ( int )   ( loc0 - lastFrame )  ;  lastFrame = loc0 ;  return loc1 ;  }
void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 )  { BlockMatrix64F loc0 = new BlockMatrix64F ( 1 , 1 )  ;  LinearSolver < BlockMatrix64F >  loc1 = new BlockCholeskyOuterSolver (  )  ;  loc0 . reshape ( arg0 . numRows , arg0 . numCols )  ;  ConvertDenseToBlock64 . convert ( arg0 , loc0 )  ;  loc1 . setA ( loc0 )  ;  }
void function ( T arg0 )  { while  ( !isHealthy ( arg0 )  )  { LOG . info ( "Resource " + arg0 + " is not healthy ,  removing .  .  . " )  ;  remove ( arg0 )  ;  closeResource ( arg0 )  ;  arg0 = acquire (  )  ;  } }
void function (  )  { MWVParser loc0 = new MWVParser (  )  ;  loc0 . parse ( EXAMPLE )  ;  assertEquals ( "Invalid speed unit" ,  SpeedUnit . KNOTS ,  loc0 . getSpeedUnit (  )  )  ;  }
void function (  )  { ResourceSet loc0 = new ResourceSet (  )  ;  try { loc0 . setId ( arg0 )  ;  resourceSetService . saveNew ( loc0 )  ;  } catch  ( Exception e )  { } }
void function (  )  { System . out . println ( "Prints input in console for debugging . " )  ;  String loc0 = fis . getFunctionBlock (  )  . toString (  )  ;  ArrayList < String >  loc1 = fis . getFunctionBlock (  )  . getVariables (  )  ;  String loc2 = fis . toString (  )  ;  }
void function ( String arg0 ,  int arg1 )  { try { addField ( arg0 ,  INTEGER ,  arg1 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public int function ( Object arg0 )  { int hash = 0 ;  try { hash = hashCode (  )  ;  } catch  ( Exception loc0 )  { hash = arg0 . hashCode (  )  ;  } return hash ;  }
Set < String >  function ( Context arg0 )  { Set < String >  loc0 = instances . keySet (  )  ;  return Collections . unmodifiableSet ( loc0 )  ;  }
void function ( BufferedOutputStream arg0 ,  File arg1 )  { mLocalOutputStream = arg0 ;  mFile = arg1 ;  mStream = new S3AOutputStream ( BUCKET_NAME ,  KEY ,  mLocalOutputStream ,  null )  ;  before (  )  ;  mStream . flush (  )  ;  mStream . close (  )  ;  Mockito . verify ( arg0 )  . close (  )  ;  mStream . verify (  )  ;  arg0 . flush (  )  ;  }
void function ( Object arg0 ,  Object arg1 )  { try { throw new UnsupportedOperationException ( "Guaranteed to throw an exception and leave the underlying data unmodified . " )  ;  } catch  ( UnsupportedOperationException loc0 )  { } }
Class function ( Class arg0 ,  String arg1 )  { Class loc0 = arg0 . getClassImpl ( arg0 ,  arg1 )  ;  Class loc1 = loc0 . getClass (  )  ;  return loc1 ;  }
String function ( String arg0 ,  String arg1 )  { final String loc0 = arg0 ;  final String loc1 = arg1 ;  UnderFileSystemUtils . mkdirIfNotExists ( loc1 )  ;  return new LocalAlluxioMaster (  (  )  - >  loc0 ,  loc1 )  . getUri (  )  ;  }
void function (  )  { try { ByteBuffer . setUseDirectBuffers ( true )  ;  ByteBuffer . setAllocator ( new SimpleByteBufferAllocator (  )  )  ;  } catch  ( Exception e )  { m_log . error ( "Error occurred while setting ByteBuffer properties: " + e . getMessage (  )  )  ;  } }
ConditionsProvider function ( TokenProviderParameters arg0 )  { List < AttributeStatementProvider >  loc0 = getAttributeStatementProviders (  )  ;  SubjectProvider loc1 = getSubjectProvider (  )  ;  SamlCallbackHandler loc2 = createCallbackHandler ( arg0 ,  new byte [ 0 ]  ,  null )  ;  SamlAssertionWrapper loc3 = createSamlToken ( arg0 ,  new byte [ 0 ]  ,  null )  ;  TokenProviderResponse loc4 = createToken ( arg0 )  ;  return conditionsProvider ;  }
void function ( Block arg0 )  { if  ( arg0 != null )  { arg0 . unpin (  )  ;  } }
public void function ( String arg0 )  { try { this . setTokenId ( arg0 )  ;  } catch  ( Exception e )  { } }
public String function (  )  { String result = "" ;  try { result = getState (  )  ;  } catch  ( Exception e )  { } result += address . getCountrySubentityCode (  )  . getValue (  )  ;  return result ;  } private String getState (  )  { return address . getAddressType (  )  . getAddress (  )  . getState (  )  ;  }
void function ( long arg0 )  { ClientRWLock loc0 = mLocks . get ( arg0 )  ;  if  ( loc0 != null )  { loc0 . unlock (  )  ;  releaseBlockLockIfUnused ( arg0 )  ;  } }
public static double function (  )  { String loc0 = System . getProperty ( "client . version" ,  "0 . 00" )  ;  return Double . parseDouble ( loc0 )  ;  }
void function (  )  { mThrown . expect ( IllegalStateException . class )  ;  mThrown . expectMessage ( "Unable to find lock record for blockId=" )  ;  mLockManager . unlockBlock ( TEST_BLOCK_ID )  ;  String errorMessage = mThrown . getMessage (  )  ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = this . checksumType ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = "zoom " + arg0 + " " + arg1 ;  try { loc0 = String . valueOf ( loc0 . concat ( "&cmd=%23SET%20PTZ" )  )  ;  runUrl ( loc0 )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function (  )  { setUp (  )  ;  dev = new Device ( "iPhone" ,  "Apple" ,  "12345" )  ;  System . out . println ( "Testing getAddress method .  .  . " )  ;  String loc0 = dev . getAddress (  )  ;  assertEquals ( "12345" ,  loc0 )  ;  tearDown (  )  ;  }
long function ( DefaultConditionsProvider arg0 )  { try { return arg0 . maxLifetime ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while getting the maximum lifetime: " + e . getMessage (  )  )  ;  return 0L ;  } }
Object function ( Object arg0 ,  Object arg1 )  { try { Object loc0 = new RouteCalculator ( arg0 ,  arg1 )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
void function ( String arg0 ,  String arg1 )  { Path loc0 = Paths . get ( arg0 )  ;  Set < PosixFilePermission >  loc1 = PosixFilePermissions . fromString ( "rwxrwxrwx" )  ;  Files . setPosixFilePermissions ( loc0 ,  loc1 )  ;  }
void function ( InputStream arg0 )  { stop (  )  ;  DefaultDataReader loc0 = new DefaultDataReader ( arg0 )  ;  setDataReader ( loc0 )  ;  start (  )  ;  }
void function (  )  { try { connection . close (  )  ;  } catch  ( SQLException loc0 )  { Jamuz . getLogger (  )  . log ( Level . SEVERE ,  "Error closing database connection" ,  loc0 )  ;  } }
ArrayList < Date >  function (  )  { ArrayList < Date >  loc0 = new ArrayList < Date >  (  )  ;  if  ( dates == null )  { dates = loc0 ;  } return this . dates ;  }
void function ( float arg0 ,  float arg1 ,  float arg2 ,  float arg3 ,  float arg4 )  { gl . glPushMatrix (  )  ;  gl . glTranslatef ( loc0 ,  loc1 ,  loc2 )  ;  gl . glRotatef ( loc3 ,  loc4 ,  loc5 ,  loc6 )  ;  for  ( int i = 0 ;  i  <  mapSize ;  i ++  )  { for  ( int j = 0 ;  j  <  mapSize ;  j ++  )  { if  ( map [ i ]  [ j ]   >  0 )  { gl . glColor3f ( loc7 ,  loc8 ,  loc9 )  ;  gl . glBegin ( GL . GL_QUADS )  ;  gl . glVertex3f ( i ,  0 ,  j )  ;  gl . glVertex3f ( i + 1 ,  0 ,  j )  ;  gl . glVertex3f ( i + 1 ,  0 ,  j + 1 )  ;  gl . glVertex3f ( i ,  0 ,  j + 1 )  ;  gl . glEnd (  )  ;  } } } gl . glPopMatrix (  )  ;  }
void function ( String arg0 ,  String arg1 )  { try { Translator translator = new Translator (  )  ;  translator . initInternal ( arg0 )  ;  Localizer . addResource ( translator . BUNDLES_PATH ,  translator . bundles ,  translator . classLoaders ,  arg1 )  ;  } catch  ( Exception loc0 )  { Translator . LOG . error ( loc0 . getMessage (  )  )  ;  } } Note: I assumed that the argument "arg1" in the function corresponds to the second argument in the Localizer . addResource method ,  which is the resource file extension . 
String function ( String path )  { String cleanPath = cleanPath ( path )  ;  String fileName = FilenameUtils . getName ( cleanPath )  ;  String parentPath = "" ;  if  ( !StringUtils . isEmpty ( fileName )  )  { int index = cleanPath . lastIndexOf ( fileName )  ;  parentPath = cleanPath . substring ( 0 ,  index - 1 )  ;  } return parentPath ;  }
public TrustManager [  ]  function ( TrustManager [  ]  arg0 )  { try { this . trustManagers = arg0 ;  } catch  ( Exception loc0 )  { } return this . trustManagers ;  }
public void function ( EndpointReferenceType arg0 )  { try { setReplyTo ( arg0 )  ;  } catch  ( Exception e )  { } }
public static String function (  )  { String [  ]  loc0 = {"yyyy-MM-dd'T'HH:mm:ss'Z'"} ;  SimpleDateFormat loc1 = new SimpleDateFormat ( loc0 [ 0 ]  )  ;  loc1 . setTimeZone ( TimeZone . getTimeZone ( "UTC" )  )  ;  String loc2 = loc1 . format ( new Date (  )  )  ;  return loc2 ;  }
public void function ( RowHeaderType arg0 ,  ColumnHeaderType arg1 ,  ValueType arg2 )  { try { if  ( arg0 == null || arg1 == null || arg2 == null )  { throw new IllegalArgumentException ( "Neither the row nor the column nor the value can be null" )  ;  } if  ( !rowHeaders . contains ( arg0 )  )  { rowHeaders . add ( arg0 )  ;  rows . put ( arg0 ,  new Hashtable < ColumnHeaderType , ValueType >  (  )  )  ;  } Hashtable < ColumnHeaderType , ValueType >  row = rows . get ( arg0 )  ;  if  ( !columnHeaders . contains ( arg1 )  )  { columnHeaders . add ( arg1 )  ;  } row . put ( arg1 ,  arg2 )  ;  cells . put ( arg1 ,  value )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( List < String >  arg0 )  { acceptedSignatureAlgorithms = arg0 ;  }
public void function (  )  { try { String arg0 = "test" ;  String arg1 = "string" ;  instance . setResponseString ( arg0 ,  arg1 )  ;  System . out . println ( "Test of setResponseString method ,  of class LogEntryRequest . " )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Exception caught: " + loc0 . getMessage (  )  )  ;  } }
Map < String ,  String >  function ( String arg0 ,  String arg1 )  { try { Map < String ,  String >  loc0 = this . namespaceMap ;  loc0 . put ( arg0 ,  arg1 )  ;  return loc0 ;  } catch  ( Exception e )  { return null ;  } }
void function (  )  { RMCParser loc0 = new RMCParser ( EXAMPLE )  ;  loc0 . setDataStatus ( 'A' )  ;  assertEquals ( 'A' ,  loc0 . getMode (  )  )  ;  }
void function (  )  { RMBSentence loc0 = new RMBSentence ( EXAMPLE )  ;  loc0 . setSteerTo ( "R" )  ;  assertEquals ( "R" ,  loc0 . getSteerTo (  )  )  ;  }
int function ( Constant arg0 ,  Plan arg1 ,  IndexInfo arg2 )  { Schema loc0 = arg1 . schema (  )  ;  String loc1 = arg2 . fieldName (  )  ;  int loc2 = loc0 . stats ( loc1 )  . distinctValues (  )  ;  return loc2 ;  }
public String function ( SayHi obj )  { String loc0 = null ;  try { loc0 = obj . msg ;  } catch  ( NullPointerException e )  { System . err . println ( "The object is null . " )  ;  } return loc0 ;  }
public int function (  )  { int loc0 = this . priority ;  return loc0 ;  }
String function ( String arg0 )  { String loc0 = top . get ( 0 )  . prefix ;  if  ( loc0 != null && loc0 . equals ( arg0 )  )  { return loc0 ;  } String loc1 = getURI ( arg0 )  ;  if  ( loc1 == null )  { loc1 = "ns" + nsPrefixCount ;  nsPrefixCount ++  ;  List < NSDecl >  loc2 = new ArrayList <  >  (  )  ;  loc2 . add ( new NSDecl ( arg0 ,  loc1 )  )  ;  stack . add ( loc2 )  ;  } else { for  ( int loc3 = 0 ;  loc3  <  stack . size (  )  ;  loc3 ++  )  { List < NSDecl >  loc4 = stack . get ( loc3 )  ;  for  ( int loc5 = 0 ;  loc5  <  loc4 . size (  )  ;  loc5 ++  )  { if  ( loc4 . get ( loc5 )  . uri . equals ( loc1 )  && loc4 . get ( loc5 )  . prefix . equals ( arg0 )  )  { return loc4 . get ( loc5 )  . prefix ;  } } } String loc6 = "ns" + nsPrefixCount ;  nsPrefixCount ++  ;  stack . get ( size - 1 )  . add ( new NSDecl ( arg0 ,  loc6 )  )  ;  return loc6 ;  } return loc1 ;  }
public Actual function ( Actual arg0 )  { subst . putAll ( subst )  ;  for  ( Map . Entry < Formal ,  Actual >  entry : subst . entrySet (  )  )  { if  ( entry . getValue (  )  . equals ( arg0 )  )  { return entry . getValue (  )  ;  } } return arg0 ;  } Note: I had to make some assumptions about the context in which this method is being used ,  as some of the variables and methods referenced in the original description were not defined or provided . 
public BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry . Value function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { BrowseOffersResponse browseOffersResponse = createBrowseOffersResponse (  )  ;  BrowseOffersResponse . Return browseOffersResponseReturn = createBrowseOffersResponseReturn (  )  ;  BrowseOffersResponse . Return . OfferData offerData = createBrowseOffersResponseReturnOfferData (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia offerMedia = createBrowseOffersResponseReturnOfferDataOfferMedia (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage offerImage = createBrowseOffersResponseReturnOfferDataOfferMediaOfferImage (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry entry = createBrowseOffersResponseReturnOfferDataOfferMediaOfferImageEntry (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry . Value value = createBrowseOffersResponseReturnOfferDataOfferMediaOfferImageEntryValue (  )  ;  BrowseOffersResponse . Return . OfferData . OfferMedia . OfferImage . Entry . Value . Item loc0 = createBrowseOffersResponseReturnOfferDataOfferMediaOfferImageEntryValueItem (  )  ;  return loc0 ;  }
void function (  )  { try { loc0 . setSentenceIndex ( arg0 )  ;  assertTrue ( loc0 . isDirty (  )  )  ;  assertEquals ( arg0 ,  loc0 . getSentenceIndex (  )  )  ;  } catch  ( IllegalArgumentException e )  { fail ( "Unexpected exception: " + e . getMessage (  )  )  ;  } catch  ( Exception e )  { assertTrue ( e . getMessage (  )  . contains ( "Failed to parse sentence index" )  )  ;  } }
void function (  )  { undoAction ( step )  ;  item . changed (  )  ;  }
float function ( MotionEvent arg0 ,  int arg1 )  { int loc0 = MotionEventCompat . IMPL . getActionIndex ( arg0 )  ;  if  ( loc0  <  0 || loc0  > = arg1 )  { loc0 = 0 ;  } return arg0 . getX ( loc0 )  ;  }
long function (  )  { long committedBytes = 0L ;  try { committedBytes = mDir . getCommittedBytes (  )  ;  } catch  ( Exception e )  { } return committedBytes ;  }
void function (  )  { long arg0 = nextLong (  )  ;  CompleteFileOptions arg1 = new CompleteFileOptions (  )  ;  arg1 . defaults (  )  ;  arg1 . setUfsLength ( arg0 )  ;  TCompleteFileOptions loc0 = arg1 . toThrift (  )  ;  TCompleteFileOptions loc1 = new TCompleteFileOptions (  )  ;  loc1 . read ( new TBinaryProtocol ( new TMemoryInputTransport ( loc0 . write (  )  )  )  )  ;  assertEquals ( loc0 ,  loc1 )  ;  }
ClassLoader function (  )  { ClassLoader loc0 = null ;  try { loc0 = Thread . currentThread (  )  . getContextClassLoader (  )  ;  } catch  ( Throwable ex )  { loc0 = ClassHelper . class . getClassLoader (  )  ;  } return loc0 ;  }
public Object function ( Class < ? >  arg0 )  { Class < ? >  loc0 = arg0 . getSuperclass (  )  ;  boolean loc1 = Wrapper . class . isAssignableFrom ( arg0 )  && !arg0 . equals ( Wrapper . class )  ;  Wrapper loc2 =  ( Wrapper )  Wrapper . WRAPPER_MAP . get ( arg0 )  ;  if  ( loc2 == null )  { if  ( loc1 )  { loc2 = Wrapper . WRAPPER_MAP . get ( loc0 )  ;  } if  ( loc2 == null )  { loc2 = Wrapper . makeWrapper ( arg0 )  ;  Wrapper . WRAPPER_MAP . put ( arg0 ,  loc2 )  ;  } } return loc2 ;  }
public Scan function ( Object arg0 ,  Object arg1 )  { TableScan ts = new TableScan ( new ProjectPlan (  )  . p )  ;  ts . open (  )  ;  Schema loc0 = ts . schema (  )  ;  Schema loc1 = new Schema (  )  ;  for  ( String field :  ( ArrayList < String >  )  arg0 )  { String [  ]  splitField = field . split ( "\\ . " )  ;  if  ( splitField . length == 1 )  { for  ( String fieldName : loc0 . fields (  )  )  { if  ( fieldName . equals ( splitField [ 0 ]  )  )  { loc1 . add ( new Schema . Var ( fieldName ,  loc0 . type ( fieldName )  )  )  ;  } } } else { Schema tempSchema = loc0 ;  for  ( int i = 0 ;  i  <  splitField . length ;  i ++  )  { for  ( String fieldName : tempSchema . fields (  )  )  { if  ( fieldName . equals ( splitField [ i ]  )  )  { if  ( i == splitField . length - 1 )  { loc1 . add ( new Schema . Var ( fieldName ,  tempSchema . type ( fieldName )  )  )  ;  } else { tempSchema = tempSchema . type ( fieldName )  . asSchema (  )  ;  } } } } } } return new Project ( ts ,  loc1 . fields (  )  )  ;  }
public void function ( int arg0 )  { int loc0 = arg0 ;  int [  ]  loc1 = new int [ loc0 + 1 ]  ;  for  ( int loc2 = 0 ;  loc2  < = grado && loc2  < = loc0 ;  loc2 ++  )  { loc1 [ loc2 ]  = coef [ loc2 ]  ;  } grado = loc0 ;  coef = loc1 ;  }
public static Response function ( RestCallable callable )  { try { Object result = callable . call (  )  ;  return createResponse ( result )  ;  } catch  ( Exception e )  { LOG . error ( "Error occurred in RestCallable" ,  e )  ;  return createErrorResponse ( "Error occurred: " + e . getMessage (  )  )  ;  } }
void function (  )  { try { instance . setYear ( arg0 )  ;  fail ( "IllegalArgumentException expected but not thrown" )  ;  } catch  ( IllegalArgumentException loc1 )  { } }
public String function ( ASTConstructorDeclaration arg0 )  { ASTClassOrInterfaceDeclaration loc0 = arg0 . getFirstParentOfType ( ASTClassOrInterfaceDeclaration . class )  ;  QualifiedName loc1 = loc0 . getQualifiedName (  )  ;  String loc2 = arg0 . getImage (  )  ;  ASTFormalParameters loc3 = arg0 . getFirstDescendantOfType ( ASTFormalParameters . class )  ;  String loc4 = loc1 . makeOperationOf ( "constructor" ,  loc3 . getArgumentCount (  )  )  ;  return loc4 ;  }
void function ( ApplicationManagementService arg0 )  { Log loc0 = LogFactory . getLog ( OAuth2ServiceComponent . class )  ;  BundleContext loc1 = bundleContext ;  if  ( loc0 . isDebugEnabled (  )  )  { loc0 . debug ( "Unsetting Application management service implementation" )  ;  } OAuth2ServiceComponentHolder . setApplicationMgtService ( null )  ;  }
List < String >  function ( CertificateConstraintsType arg0 )  { List < String >  loc0 = Collections . emptyList (  )  ;  if  ( arg0 != null && arg0 . isSetSubjectDNConstraints (  )  )  { DNConstraintsType loc1 = arg0 . getSubjectDNConstraints (  )  ;  if  ( loc1 != null )  { List < RegularExpressionType >  loc2 = loc1 . getRegularExpression (  )  ;  if  ( loc2 != null && !loc2 . isEmpty (  )  )  { loc0 = new ArrayList <  >  ( loc2 . size (  )  )  ;  for  ( RegularExpressionType loc3 : loc2 )  { loc0 . add ( loc3 . getValue (  )  )  ;  } } } } return loc0 ;  }
void function (  )  { try { notificationController . deregisterUserSession ( null ,  mockServerMessage )  ;  } catch  ( NullPointerException e )  { } }
TiledMap function ( Array < Asset >  arg0 ,  ShadowStruggles game )  { FileMap loc0 = new FileMap (  )  ;  String loc1 = resourcesToDirectory ( arg0 . get ( 0 )  . fileName )  ;  loc0 . setDirectory ( loc1 )  ;  AssetManager loc2 = game . getAssets (  )  ;  loc2 . load ( arg0 . get ( 0 )  . fileName ,  TiledMap . class )  ;  loc2 . finishLoadingAsset ( arg0 . get ( 0 )  . fileName )  ;  return loc2 . get ( arg0 . get ( 0 )  . fileName ,  TiledMap . class )  ;  }
boolean function ( Collection arg0 ,  Collection arg1 )  { if  ( !isEmpty ( arg0 )  && !isEmpty ( arg1 )  )  { for  ( Object loc0 : arg1 )  { if  ( contains ( arg0 . iterator (  )  ,  loc0 )  )  { return true ;  } } } return false ;  }
public void function (  )  { Position loc0 = new Position (  )  ;  loc0 . setLatitude ( 12 . 345 )  ;  assertEquals ( 'N' ,  loc0 . getLatHemisphere (  )  )  ;  Position loc1 = new Position (  )  ;  loc1 . setLatitude ( -12 . 345 )  ;  assertEquals ( 'S' ,  loc1 . getLatHemisphere (  )  )  ;  }
public PasswordCredentials function (  )  { PasswordCredentials loc0 = null ;  try { loc0 = new PasswordCredentials (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
ViolationNode function ( final String arg0 ,  final int arg1 ,  final int arg2 ,  final int arg3 ,  final int arg4 ,  final String arg5 )  { final ViolationNode loc0 = createViolationNode ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 ,  arg5 )  ;  final ViolationNode loc1 = createViolationNode ( arg0 ,  arg1 ,  arg2 ,  arg3 + 1 ,  arg4 ,  arg5 )  ;  assertFalse ( loc0 . equals ( loc1 )  )  ;  }
BigDecimal function (  )  { return this . expDataUnitId ;  }
public void function (  )  { try { DateTest obj = new DateTest (  )  ;  obj . testEqualsAfterInit (  )  ;  assertTrue ( true )  ;  } catch  ( Exception e )  { assertTrue ( false )  ;  } }
void function ( List < RegPCLTestResultDetailsEntity >  arg0 )  { regPclTestResultDetails = arg0 ;  }
void function (  )  { int arg0 = 60 ;  // set invalid minutes Time time = new Time (  )  ;  try { time . setMinutes ( arg0 )  ;  fail ( "Expected IllegalArgumentException was not thrown" )  ;  } catch  ( IllegalArgumentException loc0 )  { } }
T function ( BinaryMinHeap heap )  { T loc0 = null ;  try { loc0 = heap . key ( heap . get (  )  . getKey (  )  )  ;  } catch  ( NoSuchElementException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
String function ( String arg0 ,  String arg1 )  { try { String loc0 = arg0 . equalsIgnoreCase ( "name" )  ? this . getName (  )  : this . getNotation ( arg0 ,  arg1 )  . getName (  )  ;  String loc1 = loc0 . toUpperCase (  )  ;  String loc2 = this . getNotationNameString ( arg0 ,  arg1 )  ;  if  ( loc1 . equals ( loc2 . toUpperCase (  )  )  )  { return loc2 ;  } return loc1 ;  } catch  ( Exception e )  { this . LOG . log ( Level . SEVERE ,  "An error occurred in the function method . " ,  e )  ;  return "" ;  } }
TopKSelector < greatest >  function ( TopKSelector < greatest >  arg0 ,  int arg1 )  { TopKSelector < greatest >  loc0 = arg0 . least ( arg1 ,  Ordering . natural (  )  )  ;  return loc0 . combine ( arg0 )  ;  } Note: I assumed that the generic type parameter used in the TopKSelector class for the greatest elements is named "greatest" . 
public void function ( String arg0 ,  XKMSCacheToken arg1 )  { try { Element loc0 = new Element ( arg0 ,  arg1 )  ;  cache . put ( loc0 )  ;  } catch  ( Exception loc1 )  { } }
public ShareOpenGraphValueContainer function (  )  { ShareOpenGraphValueContainer loc0 =  ( ShareOpenGraphValueContainer )  this . clone (  )  ;  loc0 . bundle =  ( Bundle )  this . bundle . clone (  )  ;  return loc0 ;  }
public int function ( LaneData data )  { int loc0 = 0 ;  try { loc0 = data . getQuality (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting quality: " + e . getMessage (  )  )  ;  } return loc0 ;  }
String function ( DuplicateInfo obj )  { String loc0 = obj . getAlbum (  )  ;  return loc0 ;  }
void function ( int arg0 )  { if ( arg0  <  -13 || arg0  >  13 )  { throw new IllegalArgumentException ( "srini_string" )  ;  } this . offsetHours = arg0 ;  } This method takes an integer argument `arg0` and sets the `offsetHours` instance variable of the current object to the value of `arg0` .  It first checks if the value of `arg0` is less than -13 or greater than 13 using a conditional statement with logical OR operator .  If this condition is true ,  it throws an `IllegalArgumentException` with a message "srini_string" .  The method does not return any value . 
Sure ,  what would you like to know about the Java class "SeedPeers"?
void function ( Source arg0 )  { ArrayList < Source >  loc0 = new ArrayList <  >  (  )  ;  loc0 . add ( arg0 )  ;  validator . setSchemaSources ( loc0 . toArray ( new Source [ loc0 . size (  )  ]  )  )  ;  }
void function ( TMXTiledMap arg0 ,  int arg1 )  { TextureRegion loc0 = arg0 . getTextureRegionFromGlobalTileID ( arg1 )  ;  for  ( TMXTile tile : arg0 . getAllTiles (  )  )  { if  ( tile . getGlobalTileID (  )  == arg1 )  { tile . setTextureRegion ( loc0 )  ;  } } }
void function ( Piloto arg0 )  { Comando loc0 = null ;  try { loc0 = arg0 . proximoComando (  )  ;  loc0 . ejecutar ( this . getPartida (  )  )  ;  } catch  ( Exception loc1 )  { this . notificarObservadoresException ( arg0 ,  loc0 ,  loc1 )  ;  } }
void function ( boolean arg0 )  { try { this . resetTimeout (  )  ;  this . timeoutEnabled = arg0 ;  } catch  ( Exception loc0 )  { } }
Coin function (  )  { return value ;  }
Items function (  )  { return items ;  }
Map < String ,  String >  function ( String arg0 )  { Map < String ,  String >  loc0 = createParameterMap ( arg0 )  ;  String loc1 = canonicalize ( loc0 )  ;  String loc2 = timestamp (  )  ;  String loc3 = hmac ( REQUEST_METHOD + "\n" + endpoint + "\n" + REQUEST_URI + "\n" + loc1 + "\n" + loc2 )  ;  loc0 . put ( "Signature" ,  percentEncodeRfc3986 ( loc3 )  )  ;  String loc4 = "http://" + endpoint + REQUEST_URI + "?" + canonicalize ( loc0 )  ;  return loc0 ;  }
public Node function (  )  { Node loc0 = this . node ;  return loc0 ;  }
void function (  )  { try { mLockManager . validateLock ( loc0 ,  loc1 ,  loc2 )  ;  fail ( "Expected exception not thrown" )  ;  } catch  ( BlockNotLockedException ex )  { assertThat ( ex . getMessage (  )  ,  containsString ( "Lock not found" )  )  ;  } catch  ( Exception ex )  { fail ( "Unexpected exception: " + ex . getMessage (  )  )  ;  } }
public void function ( String arg0 ,  ServiceBuilder serviceBuilder )  { try { serviceBuilder . callback ( arg0 )  ;  Preconditions . checkNotNull ( serviceBuilder )  ;  } catch  ( NullPointerException e )  { } }
void function ( ClassType arg0 ,  EfgClassInfo arg1 )  { Type loc0 = type ( arg0 )  ;  EfgClassInfo loc1 = get ( loc0 )  ;  if  ( loc1 == null )  { loc1 = new EfgClassInfo ( position ( arg0 )  ,  packageName (  )  ,  lang (  )  ,  superClass (  )  ,  superInterface (  )  )  ;  put ( loc0 ,  loc1 )  ;  } loc1 . addAuto ( arg1 )  ;  }
String function ( TaskStatus taskStatus )  { String loc0 = "" ;  try { loc0 = taskStatus . getId (  )  ;  } catch  ( NullPointerException ex )  { System . out . println ( "TaskStatus ID is null . " )  ;  } return loc0 ;  }
void function ( Iterable < Range < C >  >  arg0 )  { for  ( Range < C >  loc0 : arg0 )  { remove ( loc0 )  ;  } }
String function ( DestinationFileExistsDTO arg0 ,  String arg1 )  { arg0 . setTestId ( arg1 )  ;  return arg0 . getTestId (  )  ;  }
boolean function ( final MoverDState < DsT >  arg0 )  { MoverDState . VisitorAdapter < Boolean ,  DsT >  loc0 = new MoverDState . VisitorAdapter < Boolean ,  DsT >  ( Boolean . FALSE )  ;   @ Override Boolean visitDownloading ( final Downloading < DsT >  arg1 )  { return Boolean . TRUE ;  } return arg0 . accept ( loc0 )  . booleanValue (  )  ;  }
public static void function ( Object arg0 ,  Object arg1 )  { Configuration loc0 =  ( Configuration )  arg0 ;  boolean loc1 =  ( boolean )  arg1 ;  SessionFactory sessionFactory = loc0 . function (  )  ;  LOG . debug ( "Creating new Hibernate session factory . " )  ;  SchemaExport schemaExport = new SchemaExport ( loc0 )  ;  schemaExport . create ( loc1 ,  true )  ;  sessionFactory . buildSessionFactory (  )  ;  }
void function ( String arg0 )  { uri = arg0 ;  }
Texture function ( String arg0 ,  String arg1 )  { Texture texture = Texture . getAssets (  )  . get ( arg0 ,  Texture . class )  ;  if  ( texture == null )  { Array < Texture >  loc0 = new Array <  >  (  )  ;  loc0 . add ( new Texture ( Gdx . files . internal ( arg0 )  )  )  ;  Texture . getAssets (  )  . load ( arg0 ,  Texture . class )  ;  Texture . getAssets (  )  . finishLoadingAsset ( arg0 )  ;  texture = Texture . getAssets (  )  . get ( arg0 ,  Texture . class )  ;  } return texture ;  }
public boolean function ( OAuth2RefreshTokenEntity loc0 )  { try { Date loc1 = loc0 . getExpiration (  )  ;  if  ( loc1 != null )  { long loc2 = loc1 . getTime (  )  - System . currentTimeMillis (  )  ;  return loc2  < = 0 ;  } } catch  ( Exception e )  { } return true ;  }
String function ( String arg0 )  { String loc0 ;  if  ( s1 . hasField ( arg0 )  )  { loc0 = s1 . getString ( arg0 )  ;  } else { loc0 = s2 . getString ( arg0 )  ;  } return loc0 ;  }
void function ( String arg0 ,  String arg1 )  { namespaceURI = arg0 ;  String loc0 = "http://www . w3 . org/2005/08/addressing/" + arg1 ;  QName loc1 = new QName ( loc0 ,  "Metadata" )  ;  mustUnderstand . add ( loc1 )  ;  } Note: This code assumes that the variables "namespaceURI" and "mustUnderstand" are already declared and initialized . 
String function (  )  { return _stack_type ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = mUri . getPath (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
boolean function ( int arg0 ,  Sha256Hash arg1 )  { Sha256Hash loc0 = checkpoints . get ( arg0 )  ;  return loc0 == null || loc0 . equals ( arg1 )  ;  }
void function ( StandardRtfParser parser ,  byte [  ]  data )  { parser . handleEvent ( new BinaryBytesEvent ( data )  )  ;  } This method takes a StandardRtfParser object and a byte array as arguments ,  and uses the parser object to create a new BinaryBytesEvent object with the given data byte array .  It then calls the handleEvent method of the parser object ,  passing in the newly created BinaryBytesEvent object to handle the event from the RawRtfParser . 
public int function ( int defaultValue )  { int result = defaultValue ;  try { if  ( currentValue != null && !currentValue . trim (  )  . isEmpty (  )  )  { result = Integer . parseInt ( currentValue . trim (  )  )  ;  } } catch  ( NumberFormatException e )  { } return result ;  }
public void function ( DirectedAcyclicGraphNode < T >  arg0 )  { try { if  ( arg0 == null )  { throw new IllegalArgumentException ( "Argument cannot be null . " )  ;  } if  ( this . mParents . contains ( arg0 )  )  { throw new IllegalArgumentException ( "Node is already a parent . " )  ;  } this . mParents . add ( arg0 )  ;  arg0 . addChild ( this )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( String arg0 )  { response . setContentType ( arg0 )  ;  }
String function ( String arg0 )  { String loc0 = "" ;  if  ( arg0 . equals ( this . feedId )  )  { loc0 = this . testId ;  } return loc0 ;  }
void function ( Source styleSheet )  { try { setSource ( styleSheet )  ;  } catch  ( Exception e )  { } }
void function (  )  { File loc0 = new File ( Environment . getExternalStoragePublicDirectory ( Environment . DIRECTORY_DCIM )  ,  DIR_NAME )  ;  if  ( !loc0 . mkdirs (  )  )  { Log . d ( TAG ,  "Failed to create directory: " + loc0 . getAbsolutePath (  )  )  ;  } if  ( !loc0 . canWrite (  )  )  { Log . d ( TAG ,  "No write access to directory: " + loc0 . getAbsolutePath (  )  )  ;  } String loc1 = mDateTimeFormat . format ( new Date (  )  )  ;  mOutputPath = new File ( loc0 ,  loc1 + " . mp4" )  . toString (  )  ;  }
import java . io . BufferedReader ;  import java . io . InputStreamReader ;  import java . net . HttpURLConnection ;  public class ResponseUtil { public static String function ( HttpURLConnection arg0 )  { StringBuffer loc0 = new StringBuffer (  )  ;  try { BufferedReader loc1 = new BufferedReader ( new InputStreamReader ( arg0 . getInputStream (  )  )  )  ;  String loc2 ;  while  (  ( loc2 = loc1 . readLine (  )  )  != null )  { loc0 . append ( loc2 )  ;  } loc1 . close (  )  ;  } catch  ( Exception e )  { } return loc0 . toString (  )  ;  } }
void function ( int arg0 )  { try { PropPanelFactory loc0 = ppfactories . remove ( arg0 )  ;  } catch  ( IndexOutOfBoundsException loc1 )  { } }
void function (  )  { m_selectorManager . addChannelInterestLater ( m_socketChannel ,  SelectionKey . OP_WRITE )  ;  }
void function (  )  { long arg0 = TimeUnit . MINUTES . toMillis ( 1 )  ;  String loc0 = WebUtils . convertMsToClockTime ( arg0 )  ;  String loc1 = "00:01:00" ;  Assert . assertEquals ( loc1 ,  loc0 )  ;  }
public void function ( TerminalDevice arg0 )  { try { TerminalDevice loc0 = repository . save ( arg0 )  ;  } catch  ( Exception loc1 )  { } }
boolean function ( String arg0 ,  String arg1 )  { String loc0 = analyseTrack ( arg0 ,  arg1 ,  "field" )  ;  if  ( loc0 . equals ( "" )  )  { return false ;  } else { int loc1 = getErrorLevel (  )  ;  if  ( loc1 != 0 )  { return false ;  } } return true ;  }
private void function (  )  { Object arg0 = Mockito . mock ( Object . class )  ;  Object arg1 = Mockito . mock ( Object . class )  ;  OSSUnderFileSystem loc0 = new OSSUnderFileSystem (  )  ;  AlluxioURI loc1 = new AlluxioURI ( "" )  ;  }
public void function (  )  { if ( currentblk != null && tx != null )  { tx . unpin ( currentblk )  ;  } } This method checks if the currentblk and tx variables are not null and if so ,  calls the tx . unpin (  )  method to unpin the buffer and close the page .  It does not throw any exceptions and does not have any arguments .  Local variables are not used in this method . 
EndpointReferenceType function (  )  { EndpointReferenceType loc0 = getFrom (  )  ;  return loc0 ;  }
String function (  )  { String loc0 = function (  )  . toString (  )  ;  String loc1 = _on_symbol . name (  )  ;  int loc2 = _to_state . index (  )  ;  return loc0 + loc1 + loc2 ;  }
float function ( Element arg0 ,  String arg1 ,  String arg2 )  { Element loc0 =  ( Element )  arg0 . getElementsByTagName ( arg1 )  . item ( 0 )  ;  String loc1 = loc0 . getAttribute ( arg2 )  ;  return Float . parseFloat ( loc1 )  ;  }
Object function ( Object arg0 ,  Object arg1 )  { Object loc0 = mClassifier ;  return loc0 ;  }
void function ( String arg0 )  { url = arg0 ;  }
public int function (  )  { int loc0 = 0 ;  try { loc0 = text . length (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
class Launcher { OnlineStatusRegistrationListener m_onlineStatusListener ;  TurnServer m_turnServer ;  SipProxy m_sipProxy ;  SipRegistrar m_registrar ;  Logger LOG = LoggerFactory . getLogger ( Launcher . class )  ;  void function (  )  { try { function (  )  ;  m_sipProxy . start (  )  ;  m_turnServer . start (  )  ;  synchronized  ( this )  { wait (  )  ;  } } catch  ( InterruptedException e )  { e . printStackTrace (  )  ;  } } }
void function ( SshDataReceivedEvent arg0 )  { System . out . println ( "srini_string" )  ;  System . out . print ( arg0 . getData (  )  )  ;  }
public int function ( T arg0 )  { int loc0 = counter . getOrDefault ( arg0 ,  0 )  ;  return loc0 ;  }
public void function ( double arg0 ,  double arg1 )  { try { DAOWrapper . GenericJSONBuilder builder = new DAOWrapper (  )  . new GenericJSONBuilder (  )  ;  builder . setCoordinateRadius ( 0 )  . setCreatedTime ( null )  . setIDstr ( null )   . setPlaceName ( "unknown" )  . setUserid ( "unknown" )  . setImage ( null )   . addText ( "" )  . addField ( "unknown" ,  "unknown" )   . setAuthor ( "unknown" ,  "unknown" )  ;  builder . addField ( "lng" ,  Double . toString ( arg0 )  )  ;  builder . addField ( "lat" ,  Double . toString ( arg1 )  )  ;  String json = builder . builder (  )  . buildFieldJSON (  )  ;  System . out . println ( json )  ;  } catch  ( Exception e )  { System . out . println ( "Not required" )  ;  } }
XYLocation function ( XYLocation loc0 )  { return loc0 . north (  )  ;  }
Collection < GrantedAuthority >  function (  )  { try { return grantedAuthorities ;  } catch  ( Exception e )  { return null ;  // or throw a custom exception } }
public void function ( DenseMatrix64F arg0 )  { try { DenseMatrix64F loc0 = new DenseMatrix64F ( arg0 )  ;  DenseMatrix64F loc1 = seed ;  loc1 . set ( loc0 )  ;  } catch  ( Exception e )  { } }
GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value . Item function ( Object arg0 ,  Object arg1 )  { GetOfferDetailsResponse response = createGetOfferDetailsResponse (  )  ;  GetOfferDetailsResponse . Return responseReturn = createGetOfferDetailsResponseReturn (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData detailOfferData = createGetOfferDetailsResponseReturnDetailOfferData (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia offerMedia = createGetOfferDetailsResponseReturnDetailOfferDataOfferMedia (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage offerImage = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImage (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry offerImageEntry = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntry (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value offerImageEntryValue = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntryValue (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value . Item loc0 = offerImageEntryValue . getItem (  )  . get ( 0 )  ;  return loc0 ;  }
public Type findType ( String name )  { Type loc0 = null ;  TopLevelResolver loc1 = head ;  while  ( loc1 != null )  { loc0 = loc1 . findType ( name )  ;  if  ( loc0 != null )  { break ;  } loc1 = loc1 . getNext (  )  ;  } return loc0 ;  }
void function ( ResourceTypeHandler arg0 ,  Set < String >  arg1 )  { try { extensionsDenied . put ( arg0 ,  arg1 )  ;  extensionsAllowed . remove ( arg0 )  ;  } catch  ( Exception e )  { } } void getSet ( ResourceTypeHandler arg0 )  { try { extensionsDenied . get ( arg0 )  ;  extensionsAllowed . get ( arg0 )  ;  } catch  ( Exception e )  { } } void clear (  )  { try { extensionsDenied . clear (  )  ;  extensionsAllowed . clear (  )  ;  } catch  ( Exception e )  { } } Set < String >  getExtensionsDenied ( ResourceTypeHandler arg0 )  { try { return extensionsDenied . get ( arg0 )  ;  } catch  ( Exception e )  { return null ;  } } Set < String >  getExtensionsAllowed ( ResourceTypeHandler arg0 )  { try { return extensionsAllowed . get ( arg0 )  ;  } catch  ( Exception e )  { return null ;  } }
void function ( String id )  { try { String key = CACHE_KEY + " . id" ;  Element element = new Element ( key ,  id )  ;  cache . put ( element )  ;  } catch  ( Exception e )  { } }
void function ( CSP arg0 )  { DomainRestoreInfo loc0 = new DomainRestoreInfo (  )  ;  FIFOQueue loc1 = new FIFOQueue (  )  ;  loc0 . storeDomains ( arg0 . getVariables (  )  )  ;  loc1 . addMultipleElements ( arg0 . getConstraints (  )  )  ;  while  ( !loc1 . isEmpty (  )  )  { Constraint loc2 =  ( Constraint )  loc1 . pop (  )  ;  boolean loc3 = false ;  for  ( Variable loc4 : loc2 . vars )  { for  ( Variable loc5 : loc0 . getModifiedVariables (  )  )  { if  ( loc4 . equals ( loc5 )  )  { loc3 = revise ( loc4 ,  loc5 ,  loc2 ,  arg0 ,  loc0 )  ;  if  ( loc4 . domain . isEmpty (  )  )  { loc0 . restoreDomains (  )  ;  return ;  } if  ( loc3 )  { loc1 . addMultipleElements ( arg0 . getConstraints (  )  )  ;  } } } } } loc0 . restoreDomains (  )  ;  }
public double function (  )  { double loc0 = 0 . 0 ;  try { loc0 = this . altitude ;  } catch  ( Exception e )  { System . out . println ( "Error getting altitude: " + e . getMessage (  )  )  ;  } return loc0 ;  }
Object [  ]  function ( Object arg0 )  { try { Object result = get ( arg0 )  ;  if  ( result instanceof Object [  ]  )  { return  ( Object [  ]  )  result ;  } else { throw new IllegalStateException ( "Result is not an array . " )  ;  } } catch  ( Exception loc0 )  { throw new IllegalStateException ( "Error retrieving result array . " ,  loc0 )  ;  } }
public void function ( Object arg0 ,  Object arg1 )  { try { Hardware hardware = Hardware . getInstance (  ( Context )  arg0 )  ;  assertNotNull ( hardware )  ;  boolean hasPenDigitizer = hardware . mHasPenDigitizer ;  boolean hasPressureSensor = hardware . hasPressureSensor (  )  ;  if  ( hasPenDigitizer && hasPressureSensor )  { } else { } } catch  ( Exception e )  { } }
public static void function ( Parcel out ,  boolean value )  { try { out . writeInt ( value ? 1 : 0 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( EndpointResolver arg0 )  { try { resolvers . remove ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
PrintStream function (  )  { return debugGui . getConsole (  )  . getErr (  )  ;  }
int function ( NetworkParameters arg0 )  { try { int loc0 = arg0 . getInterval (  )  ;  return loc0 ;  } catch  ( Exception e )  { } }
public static ComplexNode function (  )  { ComplexNode loc0 = null ;  try { loc0 = new ObjectFactory (  )  . createComplexNode (  )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
void function ( ArrayList < CanonicalGene >  arg0 )  { try { this . genes_in_ROI = arg0 ;  } catch  ( Exception e )  { System . out . println ( "An exception occurred while setting the genes in the ROI: " + e . getMessage (  )  )  ;  } }
public static void function ( final Callable < ? >  arg0 ,  int arg1 )  { try { Future < ? >  loc0 = WaitForAsyncUtils . asyncFx ( arg0 )  ;  WaitForAsyncUtils . waitFor ( arg1 ,  TimeUnit . SECONDS ,  loc0 )  ;  WaitForAsyncUtils . waitForFxEvents (  )  ;  } catch  ( Exception e )  { throw new RuntimeException ( "Exception thrown while executing the Callable" ,  e )  ;  } }
void function ( String arg0 )  { try { log . add ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
public int function ( Object arg0 ,  Object arg1 )  { int loc0 = 0 ;  try { loc0 = computeHashCode (  )  ;  } catch  ( Exception e )  { loc0 = 0 ;  } return 0xCafe123 ;  } private int computeHashCode (  )  { return 0 ;  }
import java . util . Random ;  public class IceTieBreaker { private byte [  ]  m_byteArray = new byte [ 8 ]  ;  private Random s_random = new Random (  )  ;  public byte [  ]  function (  )  { byte [  ]  loc0 = new byte [ 8 ]  ;  s_random . nextBytes ( loc0 )  ;  return loc0 ;  } }
void function ( BigDecimal arg0 )  { fileCount = arg0 ;  }
int function (  )  { int loc0 = 0 ;  try { loc0 =  ( step * 100 )  / getNumSteps (  )  ;  } catch  ( ArithmeticException e )  { } return loc0 ;  }
public BrowseOffersResponse . Return . OfferData . Geo . Region function ( BrowseOffersResponse . Return . OfferData . Geo . Region . Country . State arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 )  { BrowseOffersResponse . Return . OfferData . Geo . Region . Country . State loc0 = arg0 ;  String loc1 = arg1 ;  String loc2 = arg2 ;  String loc3 = arg3 ;  String loc4 = arg4 ;  String loc5 = arg5 ;  return new BrowseOffersResponse (  )  . new Return (  )  . new OfferData (  )  . new Geo (  )  . new Region ( loc0 ,  loc1 ,  loc2 ,  loc3 ,  loc4 ,  loc5 )  ;  }
int function ( int arg0 )  { try { return resolvePort ( arg0 )  ;  } catch  ( Exception loc0 )  { } return -1 ;  // or return a default value }
void function (  )  { Set < Item >  loc0 = invMap . keySet (  )  ;  System . out . println ( "Inventory List:" )  ;  for  ( Item loc1 : loc0 )  { System . out . println ( loc1 . getUnlocalizedName (  )  + ": " + invMap . get ( loc1 )  )  ;  } }
void function ( long arg0 ,  FileSizeComparable arg1 )  { length = arg1 ;  }
LanguageVersion function ( File arg0 )  { List < Language >  languages = getLanguagesForFile ( arg0 )  ;  if  ( !languages . isEmpty (  )  )  { Language language = languages . get ( 0 )  ;  LanguageVersion languageVersion = getDefaultLanguageVersion ( language )  ;  return languageVersion ;  } return null ;  }
void function (  )  { try { Image loc0 = dev . getImage (  )  ;  System . out . println ( "Image Name: " + loc0 . getName (  )  )  ;  assertEquals ( 640 ,  loc0 . getWidth (  )  )  ;  assertEquals ( 480 ,  loc0 . getHeight (  )  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Exception: " + loc1 . getMessage (  )  )  ;  fail ( "Test failed: " + loc1 . getMessage (  )  )  ;  } }
public static int function ( int arg0 ,  CheckpointRecord arg1 )  { int loc0 = -1 ;  // Dummy negative txid try { int op = arg1 . op (  )  ;  loc0 = arg1 . writeToLog (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
public static Builder function ( NetworkSegment arg0 )  { Builder loc0 = Builder . builder (  )  ;  loc0 = loc0 . fromNetworkSegment ( arg0 )  ;  return loc0 ;  }
void function (  )  { try { int loc0 = 0 ;  LogEntryInterval loc1 = new LogEntryInterval (  )  ;  loc1 . setNumberRequests ( loc0 )  ;  System . out . println ( "Test of setNumberRequests method ,  of class LogEntryInterval . " )  ;  } catch  ( Exception e )  { } }
Reader function ( String arg0 ,  int arg1 )  { InputStream loc0 = IOUtils . getResourceAsStream ( arg0 ,  arg1 )  ;  return new InputStreamReader ( loc0 )  ;  }
void function (  )  { DataNettyBuffer dataNettyBuffer = new DataNettyBuffer ( mBuffer )  ;  ByteBuffer loc0 = dataNettyBuffer . getReadOnlyByteBuffer (  )  ;  assertTrue ( loc0 . isReadOnly (  )  )  ;  assertEquals ( LENGTH ,  loc0 . remaining (  )  )  ;  ByteBuf loc1 = dataNettyBuffer . nioBuffer (  )  ;  assertEquals ( mBuffer ,  loc1 )  ;  mThrown . expect ( IllegalRefCountException . class )  ;  dataNettyBuffer . release (  )  ;  }
boolean function ( String arg0 )  { return _device . getVisited ( arg0 )  ;  }
public static Json function ( Object arg0 )  { Json loc0 = new Json (  )  ;  loc0 . writeValue ( "class" ,  arg0 . getClass (  )  . getName (  )  )  ;  Field [  ]  loc1 = arg0 . getClass (  )  . getFields (  )  ;  for  ( Field loc2 : loc1 )  { if  ( arg1 . contains ( loc2 . getName (  )  )  )  { continue ;  } try { loc0 . writeValue ( loc2 . getName (  )  ,  loc2 . get ( arg0 )  )  ;  } catch  ( IllegalAccessException e )  { System . out . println ( "Error accessing field: " + e . getMessage (  )  )  ;  } } return loc0 ;  }
List < MeanValue >  function (  )  { try { List < MeanValue >  loc0 = new ArrayList <  >  ( metrics )  ;  return Collections . unmodifiableList ( loc0 )  ;  } catch  ( Exception e )  { } }
public class ChartObjectTest { public void function (  )  { try { AttackModel (  )  ;  ChartObject (  )  ;  createOverlaidChart (  )  ;  assertNotNull (  )  ;  } catch  ( Exception e )  { System . out . println ( "Exception occurred: " + e . getMessage (  )  )  ;  } } private void AttackModel (  )  { } private void ChartObject (  )  { } private void createOverlaidChart (  )  { } private void assertNotNull (  )  { } }
int function ( CharSequence arg0 ,  int arg1 ,  int arg2 )  { int loc0 = arg1 ;  int consecutiveDigits = 0 ;  while  ( loc0  <  arg2 )  { char currentChar = arg0 . charAt ( loc0 )  ;  if  ( Character . isDigit ( currentChar )  )  { consecutiveDigits ++  ;  } else { break ;  } loc0 ++  ;  } return consecutiveDigits ;  }
public int function (  )  { int loc0 = 0 ;  try { loc0 = this . x ;  } catch  ( Exception e )  { } return loc0 ;  }
public void function ( Long arg0 )  { try { this . testId = arg0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting test ID: " + e . getMessage (  )  )  ;  } }
void function ( Object arg0 ,  AccessibilityEvent arg1 )  { IMPL . onInitializeAccessibilityEvent ( arg0 ,  arg1 )  ;  }
int function ( boolean arg0 )  { int loc0 = formatOff ;  int loc1 = 0 ;  while  ( loc0  <  format . length (  )  )  { char loc2 = format . charAt ( loc0 )  ;  if  ( Character . isDigit ( loc2 )  )  { loc1 =  ( loc1 * 10 )  + Character . digit ( loc2 ,  10 )  ;  loc0 ++  ;  } else { break ;  } } if  ( arg0 && loc0  >  formatOff )  { formatOff = loc0 ;  } return loc1 ;  }
String function (  )  { String loc0 = null ;  try { loc0 = this . actValue ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
EaseUserProfileProvider function (  )  { return userProvider ;  }
void function ( int arg0 )  { try { int loc0 = arg0 ;  value = loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { try { HashMap < String ,  Object >  loc0 = new HashMap <  >  (  )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_TITLE ,  null )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_MESSAGE ,  "Test message" )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_APPLICATION ,  "Test application" )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_TIMESTAMP ,  System . currentTimeMillis (  )  )  ;  loc0 . put ( Notification . NOTIFICATION_KEY_USER ,  "Test user" )  ;  Event loc1 = new Event ( Notification . TOPIC_NOTIFICATION ,  loc0 )  ;  notificationController . handleEvent ( loc1 )  ;  } catch  ( IllegalArgumentException loc2 )  { } }
String function (  )  { String loc0 = "" ;  try { loc0 = getModuleName (  )  ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
boolean function ( Class < ? >  arg0 )  { Map < Class < ? >  ,  Class < ? >  >  loc0 = PRIMITIVE_TO_WRAPPER_TYPE ;  Map < Class < ? >  ,  Class < ? >  >  loc1 = WRAPPER_TO_PRIMITIVE_TYPE ;  try { Preconditions . checkNotNull ( arg0 )  ;  return loc0 . containsKey ( arg0 )  || loc1 . containsKey ( arg0 )  ;  } catch  ( NullPointerException e )  { return false ;  } }
class NormOps { double normF ( D1Matrix64F a )  ;  double normP1 ( DenseMatrix64F A )  ;  double inducedP2 ( DenseMatrix64F A )  ;  double inducedP1 ( DenseMatrix64F A )  ;  double normP ( DenseMatrix64F A ,  double p )  ;  double fastNormP ( DenseMatrix64F A ,  double p )  ;  double fastNormP2 ( DenseMatrix64F A )  ;  double normP2 ( DenseMatrix64F A )  ;  double fastNormF ( D1Matrix64F a )  ;  double fastElementP ( D1Matrix64F A ,  double p )  ;  double conditionP2 ( DenseMatrix64F A )  ;  double conditionP ( DenseMatrix64F A ,  double p )  ;  double elementP ( RowD1Matrix64F A ,  double p )  ;  double normPInf ( DenseMatrix64F A )  ;  double inducedPInf ( DenseMatrix64F A )  ;  void function ( DenseMatrix64F arg0 )  { double loc0 = normF ( arg0 )  ;  int loc1 = arg0 . getNumElements (  )  ;  DenseMatrix64F loc2 = new DenseMatrix64F ( arg0 )  ;  CommonOps . divide ( loc2 ,  loc0 )  ;  } }
void function ( TSTNode arg0 ,  String arg1 )  { ArrayList < String >  loc0 = new ArrayList < String >  (  )  ;  traverse ( arg0 ,  arg1 )  ;  }
ExceptionListener function (  )  { return exceptionListener ;  }
void function (  )  { mHostname = NetworkAddressUtils . getLocalHostName (  )  ;  LOG . debug ( "Sets hostname . " )  ;  }
void function ( Card arg0 ,  Image arg1 )  { update ( arg1 )  ;  update ( arg0 )  ;  }
public Map < String ,  String >  function (  )  { Map < String ,  String >  result = new HashMap <  >  (  )  ;  try { result = this . attributes ;  } catch  ( Exception e )  { } return result ;  }
BigDecimal function ( BigDecimal arg0 )  { BigDecimal loc0 = new BigDecimal ( arg0 . toString (  )  )  ;  return loc0 ;  }
public double function ( int index )  { return eig . getEigenvalue ( index )  ;  }
public CoordinatorStore function (  )  { CoordinatorStore coordinatorStore = null ;  Transaction transaction = null ;  try { coordinatorStore = CoordinatorStore . newCoordinatorStore (  )  ;  transaction = coordinatorStore . beginTransaction (  )  ;  transaction . commit (  )  ;  } catch  ( StoreException e )  { if  ( transaction != null )  { transaction . rollback (  )  ;  } throw new Exception ( ErrorCode . E0600 ,  "Error creating CoordinatorStore: " + e . getMessage (  )  )  ;  } finally { if  ( coordinatorStore != null )  { if  ( transaction == null )  { coordinatorStore . close (  )  ;  } else { coordinatorStore . commitTransaction ( transaction )  ;  coordinatorStore . close (  )  ;  } } } return coordinatorStore ;  }
public void function ( int arg0 )  { try { StoredTransactionOutput output = transactionOutputMap . get ( this )  ;  if  ( output != null && output . getIndex (  )  == arg0 )  { transactionOutputMap . remove ( this )  ;  } } catch  ( Exception e )  { } }
public static Script createOpReturnScript ( byte [  ]  data )  { checkArgument ( data . length  < = Script . MAX_SCRIPT_ELEMENT_SIZE ,  "Data is too long" )  ;  ScriptBuilder builder = new ScriptBuilder (  )  ;  builder . op ( OP_RETURN )  ;  builder . data ( data )  ;  return builder . build (  )  ;  }
Class < ? extends Service >  function (  )  { return SchedulerService . class ;  }
public void function ( String arg0 ,  String arg1 )  { try { IdentityProvider idp = idPMgtStub . getIdPByName ( arg0 )  ;  if  ( idp == null )  { throw new RuntimeException ( "Identity Provider with name " + arg0 + " not found" )  ;  } idPMgtStub . deleteIdP ( arg0 )  ;  log . info ( "Identity Provider " + arg0 + " deleted successfully" )  ;  } catch  ( Exception loc0 )  { log . error ( "Error deleting Identity Provider " + arg0 + ": " + loc0 . getMessage (  )  ,  loc0 )  ;  throw new RuntimeException ( loc0 . getMessage (  )  ,  loc0 )  ;  } }
boolean function (  )  { return debugGui . isVisible (  )  ;  }
public static Document function ( String arg0 )  { Document loc0 = null ;  try { DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (  )  ;  factory . setNamespaceAware ( false )  ;  DocumentBuilder builder = factory . newDocumentBuilder (  )  ;  loc0 = builder . parse ( new InputSource ( new StringReader ( arg0 )  )  )  ;  } catch  ( Exception e )  { SoapUtilities . log . error ( e . getMessage (  )  )  ;  } return loc0 ;  }
int function ( long arg0 )  { long loc0 = arg0 & UnsignedInts . INT_MASK ;  if  ( loc0  < = 0 )  { return 0 ;  } else if  ( loc0  > =  ( 1L  <  <  31 )  )  { return -1 ;  } else if  ( loc0  > =  ( 1L  <  <  30 )  )  { long loc1 = loc0 -  ( 1L  <  <  31 )  ;  return  ( int )   ( loc1 |  ( 1L  <  <  31 )  )  ;  } else { return  ( int )  loc0 ;  } }
public static String function ( ParameterDirectionKindEnum arg0 )  { String loc0 = null ;  try { loc0 = arg0 . toString (  )  ;  } catch  ( Exception loc1 )  { loc0 = "" ;  } return loc0 ;  }
void function (  )  { prepare (  )  ;  arg0 = "unknownIssuer" ;  loc0 = service . getServerConfiguration ( arg0 )  ;  assertThat ( loc0 ,  is ( nullValue (  )  )  )  ;  }
void function ( IdentityProvider arg0 )  { try { idPMgtStub . updateIdP ( arg0 )  ;  } catch  ( RemoteException loc0 )  { String error = loc0 . getMessage (  )  ;  log . error ( "Error updating Identity Provider: " + error )  ;  } }
boolean function ( final HttpParams arg0 )  { try { if  ( arg0 == null )  { throw new IllegalArgumentException (  )  ;  } return arg0 . getBooleanParameter ( NIOReactorPNames . INTEREST_OPS_QUEUEING ,  false )  ;  } catch  ( Exception e )  { return false ;  } }
String function ( String arg0 )  { try { String loc0 = "urn:oasis:names:tc:xacml:3 . 0:rule-combining-algorithm:deny-unless-permit" ;  EntitlementAdminServiceClient client = new EntitlementAdminServiceClient (  )  ;  client . setGlobalPolicyAlgorithm ( loc0 )  ;  return "Policy algorithm set globally to " + loc0 ;  } catch  ( Exception e )  { String loc1 = e . getMessage (  )  ;  handleException ( "Error setting policy algorithm globally: " + loc1 ,  e )  ;  return "Failed to set policy algorithm globally" ;  } }
public byte [  ]  function ( int arg0 )  { byte [  ]  loc0 = null ;  switch  ( arg0 )  { case 0: loc0 = new byte [  ] { ( byte )  0xf9 ,   ( byte )  0xbe ,   ( byte )  0xb4 ,   ( byte )  0xd9} ;  break ;  case 1: loc0 = new byte [  ] { ( byte )  0x0b ,   ( byte )  0x11 ,   ( byte )  0x09 ,   ( byte )  0x07} ;  break ;  case 2: loc0 = new byte [  ] { ( byte )  0xf1 ,   ( byte )  0xcf ,   ( byte )  0xa6 ,   ( byte )  0xd6} ;  break ;  case 3: loc0 = new byte [  ] { ( byte )  0xfd ,   ( byte )  0xd2 ,   ( byte )  0xc8 ,   ( byte )  0xf1} ;  break ;  default: throw new IllegalArgumentException ( "Unknown header bytes position: " + arg0 )  ;  } return loc0 ;  }
Map < String ,  String >  function (  )  { Map < String ,  String >  result = new LinkedHashMap <  >  (  )  ;  List < String >  strings = getStrings (  )  ;  for  ( String string : strings )  { String [  ]  parts = string . split ( SPACE_DELIMITED ,  2 )  ;  if  ( parts . length == 2 )  { result . put ( parts [ 0 ]  ,  parts [ 1 ]  )  ;  } } return result ;  }
String function ( HttpServletRequest arg0 ,  IssuerServiceResponse arg1 )  { String loc0 = "" ;  try { loc0 = arg1 . getIssuer (  )  ;  } catch  ( Exception loc1 )  { loc0 = this . issuer ;  } return loc0 ;  }
public static Object function ( Object arg0 ,  Object arg1 )  { try { return  (  ( Class < ? >  ) arg0 )  . newInstance (  )  ;  } catch  ( InstantiationException loc0 )  { throwAsScriptRuntimeEx ( loc0 )  ;  } catch  ( IllegalAccessException loc1 )  { throwAsScriptRuntimeEx ( loc1 )  ;  } return null ;  }
public BigInteger function (  )  { try { DHParameterSpec loc0 = new DHParameterSpec (  new BigInteger ( "00FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E08" + "8A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B" + "302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9" + "A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE6" + "49286651ECE65381FFFFFFFFFFFFFFFF" , 16 )  ,  new BigInteger ( "2" )  ,  320  )  ;  KeyPair loc1 = generateKeyPair (  )  ;  TorTapKeyAgreement loc2 = new TorTapKeyAgreement (  )  ;  loc2 . DH_PARAMETER_SPEC = loc0 ;  loc2 . G = loc0 . getG (  )  ;  loc2 . PRIVATE_KEY_SIZE = loc1 . getPrivate (  )  . getEncoded (  )  . length * 8 ;  loc2 . keyPair = loc1 ;  loc2 . dh = loc2 . createDH (  )  ;  loc2 . onionKey = new TorPublicKey (  )  ;  loc2 . DH_LEN = 128 ;  loc2 . DH_SEC_LEN = 40 ;  return new BigInteger ( loc2 . getPublicKeyBytes (  )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return null ;  }
public long function (  )  { long loc0 = 0 ;  try { loc0 = getGeneA (  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Error getting Entrez Gene ID for Gene A: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
String function ( Repository arg0 ,  RepositoryModel arg1 ,  String arg2 )  { String loc0 = StringUtils . escapeForHtml ( arg2 )  ;  String loc1 = processTextRegex ( arg0 ,  arg1 . getName (  )  ,  loc0 )  ;  String loc2 = StringUtils . breakLinesForHtml ( loc1 )  ;  return loc2 ;  }
Double function ( String arg0 ,  String arg1 )  { Double dist = links . get ( arg0 ,  arg1 )  ;  return dist ;  }
public static JsonElement function ( Set < String >  arg0 ,  boolean arg1 )  { JsonElement loc0 = null ;  try { if  ( arg0 != null && !arg0 . isEmpty (  )  || arg1 )  { loc0 = gson . toJsonTree ( arg0 )  ;  } } catch  ( Exception e )  { logger . error ( "Error converting set to JSON array" ,  e )  ;  } return loc0 != null && loc0 . isJsonArray (  )  ? loc0 : JsonNull . INSTANCE ;  }
public void function ( Context arg0 ,  View arg1 )  { try { SoftInputUtil softInputUtil = new SoftInputUtil (  )  ;  softInputUtil . hideSoftInput ( arg0 ,  arg1 )  ;  InputMethodManager inputMethodManager =  ( InputMethodManager )  arg0 . getSystemService ( Context . INPUT_METHOD_SERVICE )  ;  inputMethodManager . showSoftInput ( arg1 ,  InputMethodManager . SHOW_IMPLICIT )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
Timestamp function (  )  { Timestamp loc0 = null ;  try { loc0 = this . getReceiptDate (  )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
ConduitSelector function (  )  { return this . conduitSelector ;  }
public static SpringChain function ( SpringConfig arg0 ,  SpringConfig arg1 )  { try { SpringChain chain = new SpringChain (  )  ;  chain . mMainSpringConfig = arg0 != null ? arg0 : new SpringConfig ( chain . DEFAULT_MAIN_TENSION ,  chain . DEFAULT_MAIN_FRICTION )  ;  chain . mAttachmentSpringConfig = arg1 != null ? arg1 : new SpringConfig ( chain . DEFAULT_ATTACHMENT_TENSION ,  chain . DEFAULT_ATTACHMENT_FRICTION )  ;  chain . registry . addSpringConfig ( chain . mMainSpringConfig ,  "default" )  ;  chain . registry . addSpringConfig ( chain . mAttachmentSpringConfig ,  "attachment" )  ;  return chain ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
String function ( int arg0 )  { GenericJSONBuilder builder = new DAOWrapper (  )  . builder (  )  ;  builder . setLocRadius ( arg0 )  ;  return builder . buildFieldJSON (  )  ;  }
Map < Variable , Term >  function ( FOLNode arg0 ,  FOLNode arg1 ,  Map < Variable , Term >  bindings )  { try { Map < Variable , Term >  result = new Unifier (  )  . _substVisitor . unify ( arg0 ,  arg1 ,  bindings )  ;  return result ;  } catch  ( UnificationFailedException e )  { return null ;  } }
String function (  @ Nonnull Key arg0 )  { String loc0 = "SHA-256" ;  try { MessageDigest loc1 = MessageDigest . getInstance ( loc0 )  ;  byte [  ]  loc2 = loc1 . digest ( arg0 . getEncoded (  )  )  ;  return DatatypeConverter . printHexBinary ( loc2 )  ;  } catch  ( NoSuchAlgorithmException loc3 )  { throw new IllegalStateException ( "Invalid algorithm: " + loc0 ,  loc3 )  ;  } }
TiledMap function (  )  { RpgMap rpgMap = RpgMap . getInstance (  )  ;  TiledMap loc0 = rpgMap . getMap (  )  ;  TiledMapTileLayer loc1 =  ( TiledMapTileLayer )  loc0 . getLayers (  )  . get ( rpgMap . tileLayerString )  ;  return loc1 ;  }
Document function ( Source arg0 )  { try { Document doc = tryExtractDocFromDOMSource ( arg0 )  ;  if  ( doc != null )  { return doc ;  } else { InputSource inputSrc = toInputSource ( arg0 )  ;  DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance (  )  ;  factory . setNamespaceAware ( true )  ;  DocumentBuilder docBuilder = factory . newDocumentBuilder (  )  ;  return docBuilder . parse ( inputSrc )  ;  } } catch  ( Exception e )  { return null ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = "subgraph " + arg0 + " {\n" ;  return loc0 ;  }
class CoAPServiceActivator implements BundleActivator { IEnvironments environments = null ;  HashMap < String , CoAPConnectionFactory >  factories = new HashMap < String , CoAPConnectionFactory >  (  )  ;  AutoSIMCoAPConfig config = null ;  public void start ( BundleContext context )  { } public void stop ( BundleContext context )  { for  ( AutoSIMConnectionConfig loc0 : config . connections )  { environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  } } }
boolean function ( String arg0 )  { AbstractPlugin loc0 = getByName ( arg0 )  ;  return remove ( loc0 )  ;  }
_production = arg0 ;  _core_hash_cache = arg1 ;  _symbol_after_dot = null ;  _dot_pos = 0 ; 
void function (  )  { Device loc0 = new Device ( "TestDevice" )  ;  loc0 . setAddress ( "192 . 168 . 0 . 1" )  ;  loc0 . addCapability ( "capability1" )  ;  loc0 . addCapability ( "capability2" )  ;  loc0 . addCapability ( "capability3" )  ;  String expected = "Device{name=TestDevice ,  address=192 . 168 . 0 . 1 ,  capabilities= [ capability1 ,  capability2 ,  capability3 ] }" ;  System . out . println ( "Testing toString (  )  method .  .  . " )  ;  assertEquals ( expected ,  loc0 . toString (  )  )  ;  System . out . println ( "toString (  )  method test passed . " )  ;  }
List < String >  function ( RefLogEntry loc0 )  { return loc0 . getChangedRefs ( Constants . R_TAGS )  ;  }
Object function ( String arg0 )  { Object loc0 = json . get ( arg0 )  ;  return loc0 ;  } String function ( String arg0 ,  String arg1 )  { String loc0 = json . getString ( arg0 ,  arg1 )  ;  return loc0 ;  }
int [  ]  recordedMovement = ourInstance . recordedMovement ;  int lastMovement = recordedMovement [ recordedMovement . length - 1 ]  ;  if  ( lastMovement != arg0 )  { for  ( int i = 0 ;  i  <  recordedMovement . length - 1 ;  i ++  )  { recordedMovement [ i ]  = recordedMovement [ i + 1 ]  ;  } recordedMovement [ recordedMovement . length - 1 ]  = arg0 ;  } void function ( int arg0 )  { int [  ]  loc0 = ourInstance . recordedMovement ;  int loc1 = loc0 [ loc0 . length - 1 ]  ;  if  ( loc1 != arg0 )  { for  ( int loc2 = 0 ;  loc2  <  loc0 . length - 1 ;  loc2 ++  )  { loc0 [ loc2 ]  = loc0 [ loc2 + 1 ]  ;  } loc0 [ loc0 . length - 1 ]  = arg0 ;  } }
public void function (  )  { try { Preconditions . checkState ( mNettyBuf != null ,  "mNettyBuf cannot be null" )  ;  int loc0 = mNettyBuf . refCnt (  )  ;  mNettyBuf . release (  )  ;  int loc1 = mNettyBuf . refCnt (  )  ;  Preconditions . checkState ( loc1 == loc0 - 1 ,  "mNettyBuf was not released properly" )  ;  } catch  ( Exception e )  { } }
void function (  )  { try { mBlockStream . skipInternal ( BLOCK_LENGTH )  ;  } catch  ( IOException e )  { } }
BookPreview function ( Book arg0 )  { BookPreview loc0 = null ;  UUID loc1 = arg0 . getUUID (  )  ;  for  ( BookPreview loc2 : data )  { if  ( loc2 . getUUID (  )  . equals ( loc1 )  )  { loc0 = loc2 . getPreview (  )  ;  break ;  } } return loc0 ;  }
String function (  )  { int loc0 = getHour (  )  ;  int loc1 = getMinutes (  )  ;  double loc2 = getSeconds (  )  ;  int loc3 = getOffsetHours (  )  ;  int loc4 = getOffsetMinutes (  )  ;  int loc5 =  ( int )  Math . floor ( loc2 )  ;  String loc6 = String . format ( TIME_PATTERN ,  loc0 ,  loc1 ,  loc5 ,  loc3 ,  loc4 )  ;  return loc6 ;  }
public void function ( Long arg0 ,  Long arg1 ,  String arg2 ,  Long arg3 )  { try { setFeedId ( arg2 )  ;  } catch  ( Exception loc0 )  { } } private void setFeedId ( String loc1 )  { this . feedId = loc1 ;  }
Object function ( Object arg0 ,  Object arg1 )  { Object loc0 = new DateTest (  )  ;  Object loc1 = new DateTest (  )  ;  assertFalse ( loc0 . equals ( loc1 )  )  ;  loc0 = arg0 ;  loc1 = arg1 ;  assertFalse ( loc0 . equals ( loc1 )  )  ;  return null ;  }
AppStatus function ( AppInstanceStatus .  .  .  instances )  { AppStatus appStatus = AppStatus . of ( UUID . randomUUID (  )  . toString (  )  )  ;  for  ( AppInstanceStatus loc0 : instances )  { appStatus = appStatus . with ( loc0 )  ;  } return appStatus ;  } Note: This implementation assumes that the UUID class is imported and the AppInstanceStatus class is properly defined .  Also ,  this implementation does not handle any exceptions that may occur during the execution of the method . 
public void function ( String arg0 ,  String arg1 )  { ViolationNode loc0 = createViolationNode ( arg0 ,  1 ,  2 ,  3 ,  4 ,  "variable" )  ;  ViolationNode loc1 = createViolationNode ( arg1 ,  1 ,  2 ,  3 ,  4 ,  "variable" )  ;  assertFalse ( loc0 . equals ( loc1 )  )  ;  }
Object function ( Object arg0 )  { return impl . function ( arg0 )  ;  }
void function ( int arg0 )  { numRows = arg0 ;  }
void function ( String arg0 )  { errorMsg = arg0 ;  }
public static void function ( int arg0 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 ;  loc0 ++  )  { } }
void function (  )  { Locale [  ]  loc0 = {Locale . ENGLISH ,  Locale . FRENCH ,  new Locale ( "srini_string" ,  "srini_string" )  ,  Locale . GERMAN ,  Locale . ITALIAN ,  Locale . CHINESE ,  Locale . UK} ;  }
public Instrumentation function (  )  { return instrumentation ;  }
long lastMark = System . currentTimeMillis (  )  ;  void mark (  )  { lastMark = System . currentTimeMillis (  )  ;  } long function (  )  { long currentTime = System . currentTimeMillis (  )  ;  long timeElapsed = currentTime - lastMark ;  return timeElapsed ;  }
String function ( ConfigSetUpDTO config )  { String loc0 = null ;  try { loc0 = config . getPclFeedId (  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Error getting pcl feed id: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
public int function ( MyComplexStruct obj )  { int loc0 = 0 ;  try { loc0 = obj . elem3 ;  } catch  ( NullPointerException e )  { System . out . println ( "Object is null . " )  ;  } return loc0 ;  }
String function (  )  { return getOrder (  )  ;  }
Node function ( Node head )  { if  ( head == null || head . next == null )  { return head ;  } Node rest = function ( head . next )  ;  head . next . next = head ;  head . next = null ;  return rest ;  }
public static OpenFileOptions function ( CreateFileOptions arg0 )  { OpenFileOptions loc0 = OpenFileOptions . defaults (  )  ;  loc0 . setReadType ( ReadType . CACHE )  ;  loc0 . setReadType ( ReadType . NO_CACHE )  ;  if  ( arg0 . getWriteType (  )  . isThrough (  )  )  { loc0 . setCacheable ( false )  ;  } return loc0 ;  }
public static KeyInfoElement function ( EncryptedKeyElement encryptedKeyElement ,  Element keyInfoElement )  { }
void function ( Message arg0 ,  AddressingProperties arg1 ,  boolean arg2 )  { try { org . apache . cxf . ws . addressing . ContextUtils . storeMAPs ( arg0 ,  arg1 ,  arg2 )  ;  } catch  ( Exception loc0 )  { } }
public String function ( Context arg0 )  { PackageManager loc0 = arg0 . getPackageManager (  )  ;  String loc1 = arg0 . getPackageName (  )  ;  Intent loc2 = loc0 . getLaunchIntentForPackage ( loc1 )  ;  loc2 . setAction ( "com . facebook . react . devsupport . ReloadAppAction" )  ;  return loc2 . getDataString (  )  ;  }
public static void function (  )  { try { String loc0 = RequestInput . getString ( "Enter a string:" ,  "default" )  ;  System . out . println ( "Input string: " + loc0 )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Exception caught: " + loc1 . getMessage (  )  )  ;  } }
String function (  )  { WorkflowJobBean loc0 = getWorkflow (  )  ;  String loc1 = loc0 . getGroup (  )  ;  return loc1 ;  }
public void function ( String arg0 ,  String arg1 )  { try { String loc0 = arg1 ;  Module module = new Module (  )  ;  module . setModuleName ( loc0 )  ;  } catch  ( Exception e )  { } }
void function ( T arg0 )  { try { if  ( checkDuplicate ( arg0 )  )  { throw new IllegalStateException ( "Duplicate object found" )  ;  } if  ( !free ( arg0 )  )  { arg0 = null ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function ( String correlationId ,  RabbitMQMessage message )  { try { message . setCorrelationId ( correlationId )  ;  } catch  ( Exception e )  { System . err . println ( "Failed to set correlation id: " + e . getMessage (  )  )  ;  } }
public void function (  )  { before (  )  ;  mPlainSaslServer = new PlainSaslServer (  )  ;  String loc0 = "testUser" ;  String loc1 = "testPassword" ;  byte [  ]  loc2 = getUserInfo ( loc0 ,  loc1 )  ;  mPlainSaslServer . evaluateResponse ( new String ( new byte [  ] {sSEPARATOR} )  + loc0 + new String ( new byte [  ] {sSEPARATOR} )  + loc1 ,  loc2 )  ;  String loc3 = mPlainSaslServer . getAuthorizationID (  )  ;  Assert . assertEquals ( loc0 ,  loc3 )  ;  }
void function ( IParserEvent arg0 )  { handlerStack . pop (  )  ;  handlerStack . peek (  )  . handleEvent ( arg0 )  ;  }
List < TempTable >  function ( Scan arg0 )  { SortScan scan = new SortScan ( splitIntoRuns ( arg0 )  ,  comp )  ;  return doAMergeIteration ( scan . sort (  )  )  ;  }
public void function ( Subject arg0 )  { try { boolean loc0 = arg0 . isReadOnly (  )  ;  Set loc1 = arg0 . getPrincipals ( User . class )  ;  if  ( loc1 != null && !loc1 . isEmpty (  )  )  { User loc2 =  ( User )  loc1 . iterator (  )  . next (  )  ;  arg0 . getPrincipals (  )  . remove ( loc2 )  ;  } } catch  ( UnsupportedOperationException e )  { } catch  ( ClassCastException e )  { } catch  ( NullPointerException e )  { } }
String function (  )  { String loc0 = null ;  try { loc0 = this . postId ;  if  ( loc0 == null || loc0 . isEmpty (  )  )  { throw new DataErrorException ( "Post ID is not available" )  ;  } } catch  ( DataErrorException loc1 )  { boolean loc2 = this . getShouldFailOnDataError (  )  ;  if  ( loc2 )  { throw loc1 ;  } else { System . err . println ( "Error: " + loc1 . getMessage (  )  )  ;  } } catch  ( Exception loc3 )  { System . err . println ( "Error: " + loc3 . getMessage (  )  )  ;  } return loc0 ;  }
boolean function ( int arg0 )  { int [  ]  loc0 = getAcceptableAddressCodes (  )  ;  for  ( int loc1 = 0 ;  loc1  <  loc0 . length ;  loc1 ++  )  { if  ( arg0 == loc0 [ loc1 ]  )  { return true ;  } } return false ;  }
boolean function ( boolean arg0 )  { boolean loc0 = true ;  try { appendSemicolon ( arg0 )  ;  } catch  ( Exception e )  { loc0 = false ;  } return loc0 ;  }
public void function (  )  { rmc . setFaaMode ( 'A' )  ;  assertEquals ( 'A' ,  rmc . getMode (  )  )  ;  } Note: This assumes that the class has an imported JUnit library and that the test case is properly set up with the required dependencies and annotations . 
int function ( int arg0 )  { tx . pin ( blk )  ;  currentslot = arg0 ;  return currentslot ;  }
String function ( String arg0 )  { if  ( lhs . equals ( rhs )  || !lhs . isFieldName (  )  || !rhs . isFieldName (  )  )  { return null ;  } String loc0 = lhs . asFieldName (  )  ;  String loc1 = rhs . asFieldName (  )  ;  if  ( arg0 . equals ( loc0 )  && !arg0 . equals ( loc1 )  )  { return loc1 ;  } if  ( arg0 . equals ( loc1 )  && !arg0 . equals ( loc0 )  )  { return loc0 ;  } return null ;  }
void function ( String arg0 )  { actValue = arg0 ;  }
Diff function ( Object arg0 ,  Object arg1 )  { Source controlSource = getSource ( arg0 )  ;  Source testSource = getSource ( arg1 )  ;  DiffBuilder diffBuilder = new DiffBuilder ( controlSource ,  testSource )   . ignoreComments (  )   . checkForSimilar (  )   . withNodeMatcher ( new DefaultNodeMatcher ( ElementSelectors . byName )  )   . normalizeWhitespace ( true )  ;  return diffBuilder . build (  )  ;  }
private String function ( String arg0 ,  String arg1 )  { RegistryBasedTrustedServiceStore loc0 = new RegistryBasedTrustedServiceStore (  )  ;  String [  ]  loc1 = loc0 . getTrustedServiceClaims ( arg1 )  ;  return  ( loc1 != null && loc1 . length  >  0 )  ? loc1 [ 0 ]  : "" ;  }
boolean function ( ShareOpenGraphValueContainer obj ,  String key ,  boolean defaultValue )  { boolean result = defaultValue ;  try { result = obj . getBoolean ( key ,  defaultValue )  ;  } catch ( Exception e )  { } return result ;  }
public boolean function ( String arg0 ,  String arg1 )  { String loc0 = arg0 . toUpperCase (  )  ;  Map < String ,  Integer >  loc1 = logLevels ;  if  ( loc1 . containsKey ( loc0 )  )  { int loc2 = loc1 . get ( loc0 )  ;  if  ( loc2  <  logFilter . getLevel (  )  )  { return false ;  } } Matcher loc3 = filterPattern . matcher ( arg1 )  ;  if  ( noFilter || loc3 . matches (  )  )  { return true ;  } String loc4 = loc3 . group ( 2 )  . toUpperCase (  )  ;  loc1 = filterParams ;  if  ( loc1 . containsKey ( loc4 )  )  { String loc5 = loc3 . group ( 3 )  ;  String loc6 = loc1 . get ( loc4 )  ;  if  ( loc6 == null || Pattern . matches ( loc6 ,  loc5 )  )  { return true ;  } } return false ;  }
public static void function ( BufferedByteWriter writer ,  int arg0 )  { try { writer . put32 (  ( byte )   ( arg0  >  >  24 )  )  ;  writer . put32 (  ( byte )   ( arg0  >  >  16 )  )  ;  writer . put32 (  ( byte )   ( arg0  >  >  8 )  )  ;  writer . put32 (  ( byte )  arg0 )  ;  } catch  ( Exception e )  { } }
public AuthenticationHolderEntity function (  )  { return authenticationHolder ;  }
void function (  )  { Iterator < AbstractPlugin >  loc0 = singleton . allPlugins . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { AbstractPlugin loc1 = loc0 . next (  )  ;  loc1 . removePluginObserver (  )  ;  loc0 . remove (  )  ;  } }
void function ( float loc0 )  { weight = loc0 ;  }
void function ( InetSocketAddress arg0 ,  Channel arg1 )  { Preconditions . checkArgument ( arg0 != null && arg1 != null )  ;  if  ( NETTY_CHANNEL_POOL_MAP . containsKey ( arg0 )  )  { NettyChannelPool loc0 = NETTY_CHANNEL_POOL_MAP . get ( arg0 )  ;  loc0 . release ( arg1 )  ;  } }
String function (  )  { return SERVICES . getConf (  )  . get ( CONF_SYSTEM_ID )  ;  }
void function ( String arg0 ,  ArrayList < Parcelable >  arg1 )  { bundle . putParcelableArrayList ( arg0 ,  arg1 )  ;  return ;  }
URIBuilder function (  )  { URIBuilder uriBuilder = new URIBuilder (  )  ;  uriBuilder . fragment ( arg0 )  ;  return uriBuilder ;  }
public void function ( long arg0 )  { keySize = arg0 ;  }
private void function ( int arg0 ,  String arg1 )  { int loc0 = 0 ;  try { loc0 = getInt ( PropertyKey . WORKER_SESSION_TIMEOUT_MS )  ;  } catch  ( Exception e )  { loc0 = mSessionTimeoutMs ;  } mSessionTimeoutMs = Math . min ( Math . max ( loc0 ,  MIN_LEN )  ,  MAX_LEN )  ;  }
Map < SpringConfig ,  String >  function (  )  { Map < SpringConfig ,  String >  loc0 = new HashMap <  >  ( INSTANCE . mSpringConfigMap )  ;  return Collections . unmodifiableMap ( loc0 )  ;  }
import java . text . SimpleDateFormat ;  import java . util . Date ;  import java . util . TimeZone ;  public static String function (  )  { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ss'Z'" )  ;  formatter . setTimeZone ( TimeZone . getTimeZone ( "UTC" )  )  ;  return formatter . format ( new Date (  )  )  ;  }
void function (  )  { try { function (  )  ;  } catch  ( Exception e )  { m_log . error ( "Error synchronizing directory" ,  e )  ;  } }
void function ( String path ,  String sql )  { try { SQLiteUriMatcher . getInstance ( SQLiteUriMatcher . class ,  mAuthority )  . addTablesSQL ( path ,  sql )  ;  } catch  ( Exception e )  { } }
void function (  )  { try { individualStructures . clear (  )  ;  } catch  ( Exception loc0 )  { } }
Object function ( Object arg0 ,  Object arg1 ,  Object arg2 ,  Object arg3 ,  Object arg4 ,  Object arg5 )  { this . languageVersion ;  }
public SignatureProperties function (  )  { SignatureProperties loc0 = new SignatureProperties (  )  ;  loc0 . load ( StaticSTSProperties . class . getResourceAsStream ( "signature . properties" )  )  ;  return loc0 ;  }
Predicate function (  )  { return pred ;  }
boolean function ( DenseMatrix64F arg0 )  { return MatrixFeatures . isDiagonalPositive ( arg0 ,  TOL )  ;  }
public void function ( ByteBuffer arg0 ,  int arg1 )  { int loc0 = arg1 & 0xFF ;  arg0 . putInt (  ( byte )  loc0 )  ;  }
public void function ( Token arg0 ,  String arg1 )  { try { UserSubject loc0 = new UserSubject ( arg1 )  ;  arg0 . setSubject ( loc0 )  ;  } catch  ( Exception loc1 )  { } }
void function ( boolean arg0 ,  JMenuBar arg1 ,  boolean arg2 ) { setBreakOnExceptions ( arg0 )  ;  getMenuBar (  )  . setSelected ( arg1 ,  arg2 )  ;  } Note: I assumed that the "getMenuBar" method returns a reference to a JMenuBar object ,  and that the "setSelected" method is a method of JMenuBar that takes two boolean arguments .  Also ,  keep in mind that removing comments and exception handling may not be recommended in actual coding practices ,  as they can improve code readability and robustness . 
public float function ( int arg0 )  { try { float loc0 = originLat -  ( arg0 / dotsPerDeg )  / dotsPerInch ;  return loc0 ;  } catch  ( Exception e )  { } }
USAddress function (  )  { try { return new USAddress (  )  ;  } catch  ( Exception e )  { return null ;  } }
void function (  )  { Executor loc0 = MoreExecutors . renamingDecorator ( executor (  )  ,  new Supplier < String >  (  )  {  @ Override public String get (  )  { return serviceName (  )  ;  } } )  ;  loc0 . execute ( new Runnable (  )  {  @ Override public void run (  )  { try { startUp (  )  ;  notifyStarted (  )  ;  if  ( isRunning (  )  )  { try { AbstractExecutionThreadService . this . run (  )  ;  } catch  ( Throwable t )  { try { shutDown (  )  ;  } catch  ( Exception ignored )  { logger . log ( Level . WARNING ,  "Error while attempting to shut down the service after failure . " ,  ignored )  ;  } notifyFailed ( t )  ;  return ;  } } shutDown (  )  ;  notifyStopped (  )  ;  } catch  ( Throwable t )  { notifyFailed ( t )  ;  } } } )  ;  }
JSONObject function ( int arg0 )  { Object loc0 = mArray . get ( arg0 )  ;  return loc0 == null ? null : loc0 instanceof JSONObject ?  ( JSONObject )  loc0 : null ;  }
import org . ejml . data . DenseMatrix64F ;  import org . ejml . ops . CommonOps ;  public class NaiveDeterminant { public double recursive ( DenseMatrix64F mat )  { if  ( mat . numRows != mat . numCols )  { throw new IllegalArgumentException ( "Matrix must be square . " )  ;  } if  ( mat . numRows == 1 )  { return mat . get ( 0 ,  0 )  ;  } if  ( mat . numRows == 2 )  { return mat . get ( 0 ,  0 )  * mat . get ( 1 ,  1 )  - mat . get ( 0 ,  1 )  * mat . get ( 1 ,  0 )  ;  } double sum = 0 . 0 ;  DenseMatrix64F submat = new DenseMatrix64F ( mat . numRows - 1 ,  mat . numCols - 1 )  ;  for  ( int i = 0 ;  i  <  mat . numCols ;  i ++  )  { CommonOps . extract ( mat ,  1 ,  mat . numRows ,  0 ,  i ,  submat ,  0 ,  0 )  ;  sum +=  (  ( i % 2 == 0 )  ? 1 . 0 : -1 . 0 )  * mat . get ( 0 ,  i )  * recursive ( submat )  ;  } return sum ;  } public double function ( DenseMatrix64F arg0 )  { int n = arg0 . numRows ;  int [  ]  indices = new int [ n ]  ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { indices [ i ]  = i ;  } double sum = 0 . 0 ;  do { double product = 1 . 0 ;  for  ( int i = 0 ;  i  <  n ;  i ++  )  { product *= arg0 . get ( i ,  indices [ i ]  )  ;  } int sign = 1 ;  for  ( int i = 0 ;  i  <  n - 1 ;  i ++  )  { for  ( int j = i + 1 ;  j  <  n ;  j ++  )  { if  ( indices [ i ]   >  indices [ j ]  )  { sign = -sign ;  } } } sum += sign * product ;  } while  ( PermuteArray . next ( indices )  )  ;  return sum ;  } }
public Dish function ( String arg0 )  { Dish loc0 = null ;  try { loc0 = dishRepository . findBySiteUrl ( arg0 )  ;  } catch  ( Exception loc1 )  { log . error ( "Error occurred while getting dish by site url: {}" ,  arg0 ,  loc1 )  ;  } return loc0 ;  }
String function (  )  { try { java . rmi . server . UID loc0 = new java . rmi . server . UID (  )  ;  return loc0 . toString (  )  ;  } catch  ( Exception loc1 )  { ItemUID . LOG . error ( "Error generating unique ID" ,  loc1 )  ;  return null ;  } }
void function (  )  { int loc0 = errorCount ;  flushed = true ;  errorCount = 0 ;  System . out . println ( "Flushed " + loc0 + " errors from " + name )  ;  }
void function ( long arg0 ,  int arg1 ,  ServiceID arg2 ,  int arg3 ,  InetAddress arg4 )  { long loc0 = arg0 ;  int loc1 = RETVAL_OK ;  ServiceInfoStat [  ]  loc2 = null ;  onServiceRegistration ( arg2 ,  arg1 ,  arg3 ,  arg4 ,  null )  ;  onServiceModify ( loc0 ,  loc1 ,  loc2 )  ;  }
List < String >  function (  )  { List < String >  loc0 = new LinkedList < String >  (  )  ;  try { loc0 = this . registeredScopes ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
import java . io . * ;  import java . util . * ;  class TempFileUtils { private static final Logger LOG = Logger . getLogger ( TempFileUtils . class )  ;  public static void function ( File arg0 )  { try { traverseDir ( arg0 ,  new FileAction (  )  { public void act ( File arg1 )  { arg1 . delete (  )  ;  } } )  ;  arg0 . delete (  )  ;  } catch  ( IOException e )  { LOG . error ( error ( "Failed to delete directory: " + arg0 . getAbsolutePath (  )  ,  e )  )  ;  } } private static String error ( String msg ,  Throwable t )  { StringWriter sw = new StringWriter (  )  ;  PrintWriter pw = new PrintWriter ( sw )  ;  pw . println ( msg )  ;  pw . println ( t . toString (  )  )  ;  t . printStackTrace ( pw )  ;  return sw . toString (  )  ;  } private static void traverseDir ( File directory ,  FileAction action )  throws IOException { if  ( !directory . isDirectory (  )  )  { throw new IOException ( directory + " is not a directory" )  ;  } for  ( File file : directory . listFiles (  )  )  { if  ( file . isDirectory (  )  )  { traverseDir ( file ,  action )  ;  } else { action . act ( file )  ;  } } } private static interface FileAction { public void act ( File file )  ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = " (  ( \\w+\\ .  ) +|\\ .  )  (  ( \\w+ )  ( \\$\\w+ ) * )  ( # ( \\w+ ) \\ (  (  ( \\w+ )  (  ,  \\w+ ) * ) ?\\ )  ) ?" ;  Pattern loc1 = Pattern . compile ( loc0 )  ;  String [  ]  loc2 = null ;  String loc3 = null ;  String [  ]  loc4 = new String [ 1 ]  ;  QualifiedName loc5 = parseName ( arg0 )  ;  loc2 = loc5 . getPackages (  )  ;  loc4 [ 0 ]  = loc5 . getClasses (  )  [ 0 ]  ;  if  ( arg1 != null )  { loc3 = getOperationName ( arg1 ,  null )  ;  } if  ( loc3 == null )  { loc3 = loc4 [ 0 ]  ;  } return loc3 ;  }
void function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 ,  String arg6 ,  String arg7 ,  String arg8 ,  String arg9 ,  String arg10 ,  String arg11 ,  String arg12 ,  String arg13 ,  String arg14 ,  String arg15 ,  String arg16 ,  String arg17 ,  String arg18 ,  String arg19 ,  String arg20 )  { int loc0 = 1 ;  int loc1 = 0 ;  int loc2 = 2 ;  int loc3 = 3 ;  int loc4 = 7 ;  boolean loc5 = true ;  int loc6 = 4 ;  int loc7 = 5 ;  String loc8 = "" ;  String loc9 = "" ;  String loc10 = "" ;  String [  ]  loc11 = {} ;  double loc12 = 0 . 0 ;  boolean loc13 = false ;  int loc14 = 6 ;  boolean [  ]  loc15 = {} ;  int loc16 = 0 ;  this . type = loc1 ;  this . valid = loc5 ;  this . valueString = loc8 ;  this . description = loc9 ;  this . invalidationMessage = loc10 ;  this . options = loc11 ;  this . valueDouble = loc12 ;  this . valueBoolean = loc13 ;  this . valueCheck = loc15 ;  this . valueInteger = loc16 ;  }
void function (  )  { List < ? extends Piloto >  loc0 = getPilotos (  )  ;  Collections . shuffle ( loc0 )  ;  for  ( Piloto loc1 : loc0 )  { runTurno ( loc1 )  ;  } long loc2 = rondas . incrementAndGet (  )  ;  notificarObservadoresRondaTerminada ( loc2 )  ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = request . getOriginalPath (  )  ;  if  ( loc0 . endsWith ( "/" )  )  { loc0 = loc0 . substring ( 0 ,  loc0 . length (  )  - 1 )  ;  } } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
public static void function (  )  { long loc0 = IdUtils . createFileId (  )  ;  long loc1 = IdUtils . createFileId (  )  ;  Assert . assertNotEquals ( loc0 ,  loc1 ,  "Tests if output of IdUtils#createFileId ( long )  is valid . " )  ;  }
List < PropertyDescriptor < ? >  >  function (  )  { List < PropertyDescriptor < ? >  >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 . addAll ( propertyDescriptors )  ;  } catch  ( Exception e )  { } return loc0 ;  }
public static ReaderInputStream function ( Reader arg0 )  { ReaderInputStream loc0 = null ;  try { loc0 = new ReaderInputStream ( arg0 )  ;  } catch  ( IOException e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  failedAttrib = loc0 ;  } Note: This method sets the "failedAttrib" member variable of the "RegPCLTestResultDetailsEntity" class to the trimmed value of the "arg0" parameter .  No exception handling is implemented in this method . 
public void function ( Profile arg0 )  { try { ProfileManager loc0 = getManager (  )  ;  loc0 . registerProfile ( arg0 )  ;  } catch  ( NullPointerException e )  { notInitialized ( "ProfileManager is not initialized" )  ;  } }
boolean function ( Method arg0 ,  Method arg1 ,  Map < TypeVariable ,  Type >  arg2 )  { Method loc0 = findGenericDeclaration ( arg0 )  ;  List < Method >  loc1 = Arrays . asList ( loc0 . getReturnType (  )  . getDeclaredMethods (  )  )  ;  Method loc2 = searchCandidates ( loc1 ,  arg0 )  ;  return isResolvedTypeMatch ( loc0 ,  arg1 ,  arg2 )  && isVisibilityBridgeMethodPair ( arg0 ,  loc2 )  ;  } Note: The function uses the previously defined methods "findGenericDeclaration" ,  "searchCandidates" ,  "isResolvedTypeMatch" ,  and "isVisibilityBridgeMethodPair" .  It takes two Method objects as arguments  ( arg0 and arg1 )  and a Map < TypeVariable ,  Type >  object  ( arg2 )  to check whether or not the bridge Method  ( arg0 )  is the bridge for the supplied candidate Method  ( arg1 )  .  It returns a boolean value indicating the result .  No exception handling is included in this implementation . 
public void function ( Color arg0 ,  int arg1 )  { setForegroundColor ( arg0 )  ;  fillCircle ( circle . getX (  )  ,  loc0 ,  arg1 )  ;  }
Object function ( String arg0 )  { try { if  ( !vars . containsKey ( arg0 )  )  { throw new IllegalArgumentException ( String . format ( "Variable '%s' not found" ,  arg0 )  )  ;  } return vars . get ( arg0 )  ;  } catch  ( Exception e )  { } return null ;  }
public void function (  )  { try { final Path loc0 = new Path ( "srini_string" )  ;  final String loc1 = HadoopUtils . getPathWithoutScheme ( loc0 )  ;  Assert . assertFalse ( "srini_string" . equals ( loc1 )  )  ;  } catch  ( Exception e )  { System . out . println ( "This test doesn't work the way you might expect .  If you take the URI . create ( \"hdfs://localhost:1234/foo/bar/baz?please=dont&amp ; show=up\" )  . getPath it will return /foo/bar/baz .  If you go through Hadoop's Path using  { @ link Path#Path ( String ) }then Hadoop injects the query params into the path ,  so when you call toURI it gives a different response . " )  ;  } }
public int function (  )  { try { return xPosition ;  } catch  ( Exception e )  { System . err . println ( "Error occurred while getting xPosition: " + e . getMessage (  )  )  ;  return -1 ;  // or throw a custom exception } }
float function ( short arg0 ,  float arg1 )  { float loc0 = 0 . 0f ;  try { loc0 = arg1 ;  if  ( primitiveType != arg0 )  { loc0 = FSCssValueConversion . convertFloatValue ( primitiveType ,  arg0 ,  arg1 )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
void function ( long arg0 )  { mBlocksToMoveIn . add ( arg0 )  ;  }
public static WSDLFactory function (  )  { WSDLFactory factory = null ;  String implName = new WSDLCorbaFactory (  )  . findFactoryImplName (  )  ;  if  ( implName != null )  { try { factory =  ( WSDLFactory )  Class . forName ( implName )  . newInstance (  )  ;  } catch  ( ClassNotFoundException | InstantiationException | IllegalAccessException e )  { } } if  ( factory == null )  { try { String propValue = System . getProperty ( WSDLCorbaFactory . PROPERTY_NAME )  ;  if  ( propValue != null )  { factory =  ( WSDLFactory )  Class . forName ( propValue )  . newInstance (  )  ;  } } catch  ( ClassNotFoundException | InstantiationException | IllegalAccessException e )  { } } if  ( factory == null )  { Properties props = new Properties (  )  ;  try { InputStream is = ClassLoader . getSystemResourceAsStream ( WSDLCorbaFactory . PROPERTY_FILE_NAME )  ;  if  ( is != null )  { props . load ( is )  ;  String implName2 = props . getProperty ( WSDLCorbaFactory . PROPERTY_NAME )  ;  if  ( implName2 != null )  { factory =  ( WSDLFactory )  Class . forName ( implName2 )  . newInstance (  )  ;  } } } catch  ( IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e )  { } } if  ( factory == null )  { try { factory =  ( WSDLFactory )  Class . forName ( WSDLCorbaFactory . DEFAULT_FACTORY_IMPL_NAME )  . newInstance (  )  ;  } catch  ( ClassNotFoundException | InstantiationException | IllegalAccessException e )  { } } return factory ;  }
List < String >  function ( Set < String >  groups ,  List < EMMessage >  messages )  { List < String >  mentionedGroups = new ArrayList < String >  (  )  ;  try { for  ( EMMessage message : messages )  { if  ( isAtMeMsg ( message )  )  { String groupId = message . getTo (  )  ;  if  ( groups . contains ( groupId )  )  { mentionedGroups . add ( groupId )  ;  } } } } catch  ( Exception e )  { } return mentionedGroups ;  }
public static String function ( Object arg0 ,  Class < Object >  arg1 ,  String propertyName )  { PropertyDescriptor [  ]  descriptors = PropertyUtil . propertyDescriptorsFor ( arg0 ,  arg1 )  ;  for  ( PropertyDescriptor descriptor : descriptors )  { if  ( descriptor . getName (  )  . equals ( propertyName )  )  { return descriptor . getName (  )  ;  } } return null ;  }
void function ( int minutes )  { try { if  ( minutes  <  0 || minutes  >  59 )  { throw new IllegalArgumentException ( "Invalid minute value: " + minutes )  ;  } this . minutes = minutes ;  } catch  ( IllegalArgumentException ex )  { System . err . println ( ex . getMessage (  )  )  ;  } }
String function ( Coin arg0 )  { try { MonetaryFormat format = MonetaryFormat . BTC . minDecimals ( 0 )  . repeatOptionalDecimals ( 1 ,  8 )  . noCode (  )  ;  String plainString = arg0 . divide ( Coin . COIN_VALUE )  . toString (  )  ;  String formattedString = format . format ( arg0 )  ;  return formattedString . substring ( 0 ,  formattedString . length (  )  -  ( plainString . length (  )  + 1 )  )  ;  } catch  ( ArithmeticException e )  { return "Error: " + e . getMessage (  )  ;  } }
void function ( JPanel arg0 )  { uiStack . addToStack ( arg0 )  ;  }
boolean function ( TypeCreationOptions loc0 )  { return loc0 . defaultNillable ;  }
public List < SAXParseException >  function ( Source arg0 )  { List < SAXParseException >  loc0 = new ArrayList <  >  (  )  ;  try { validator . validate ( arg0 )  ;  } catch  ( SAXException e )  { loc0 . addAll ( getProblems (  )  )  ;  } catch  ( IOException e )  { } return problemToExceptionList ( loc0 )  ;  }
private void function ( DiffBuilder builder ,  ComparisonListener listener )  { try { builder . withComparisonListeners ( Collections . singletonList ( listener )  )  ;  builder . checkForIdentical (  )  . checkForSimilar (  )  . normalizeWhitespace (  )  . ignoreComments (  )  ;  builder . build (  )  . getDifferences (  )  . forEach ( diff - >  { if  ( diff . getResult (  )  != ComparisonResult . EQUAL )  { listener . comparisonPerformed ( diff ,  diff . getResult (  )  )  ;  } } )  ;  } catch  ( Exception e )  { } }
void function ( ConduitSelector arg0 )  { this . conduitSelector = arg0 ;  }
String function ( Message arg0 )  { Exchange loc0 = arg0 . getExchange (  )  ;  Message loc1 = loc0 . getOutFaultMessage (  )  ;  boolean loc2 = MessageUtils . isEmptyPartialResponse ( loc1 )  ;  boolean loc3 = MessageUtils . isFault ( loc1 )  ;  boolean loc4 = loc2 && loc3 ;  if  ( loc4 )  { return "fault" ;  } else { boolean loc5 = MessageUtils . isPartialResponse ( loc1 )  ;  if  ( loc5 )  { return "partial" ;  } else { return "none" ;  } } }
public static void function ( Context arg0 ,  View arg1 )  { try { InputMethodManager loc0 =  ( InputMethodManager )  arg0 . getSystemService ( Context . INPUT_METHOD_SERVICE )  ;  loc0 . hideSoftInputFromWindow ( arg1 . getWindowToken (  )  ,  0 )  ;  } catch  ( Exception loc1 )  { } }
BigDecimal function (  )  { BigDecimal loc0 = arg6 ;  return loc0 ;  }
String function ( AuthenticationRequest authReq )  { try { return authReq . getTenantDomain (  )  ;  } catch  ( Exception loc0 )  { } return null ;  }
Rect function (  )  { Rect rect = new Rect (  )  ;  return rect ;  }
Collection < Playlist >  function ( Map < Integer , Playlist >  arg0 )  { Collection < Playlist >  loc0 ;  try { loc0 = arg0 . values (  )  ;  Collections . sort ( new ArrayList <  >  ( loc0 )  )  ;  } catch  ( Exception e )  { loc0 = null ;  } return loc0 ;  }
public void function ( String arg0 ,  String arg1 ,  String arg2 )  { try { Class . forName ( arg0 )  . newInstance (  )  ;  Connection loc0 = DriverManager . getConnection ( arg1 ,  arg2 )  ;  Documents loc1 = new Documents (  )  ;  loc1 . con = loc0 ;  loc1 . createDb (  )  ;  } catch  ( Exception loc2 )  { loc2 . printStackTrace (  )  ;  } }
void function ( CString arg0 )  { paramName = arg0 ;  }
boolean function ( String arg0 )  { String loc0 = _uriResolver . resolveURI ( arg0 )  ;  return loc0 != null && _imageResourceLoader . getImageResource ( loc0 )  != null ;  }
String function ( String arg0 )  { try { if  ( arg0 == null )  { throw new NullPointerException (  )  ;  } return DAVRepository . class . getName (  )  + "srini_string" + arg0 ;  } catch  ( Exception e )  { return null ;  } }
void function ( Object arg0 )  { _out . writeStreamingObject ( arg0 )  ;  }
void function ( String arg0 ,  int arg1 ,  int arg2 ,  boolean arg3 )  { CPD cpd = new CPD ( 0 )  ;  CPDTest test = new CPDTest (  )  ;  NoFileAssertListener listener = new NoFileAssertListener (  )  ;  cpd . setListener ( listener )  ;  cpd . add ( new File ( arg0 )  )  ;  test . addedFile ( arg1 ,  new File ( arg0 )  )  ;  cpd . add ( new File ( arg0 )  )  ;  test . addedFile ( arg1 ,  new File ( arg0 )  )  ;  test . verify (  )  ;  }
void function (  )  { BlockContainerIdGenerator loc0 = new BlockContainerIdGenerator ( TEST_ID )  ;  mGenerator = loc0 ;  long loc1 = 5678 ;  mGenerator . setNextContainerId ( loc1 )  ;  long loc2 = loc0 . getNextContainerId (  )  ;  assertEquals ( loc1 ,  loc2 )  ;  getNewContainerId (  )  ;  }
void function ( int arg0 ,  int arg1 )  { int loc0 = arg0 ;  int loc1 = arg1 ;  checkRankNUpdate ( loc0 ,  loc1 )  ;  }
 @ Test void function (  )  { try { when ( mockServerSession . getId (  )  )  . thenReturn ( null )  ;  notificationController . registerUserSession ( mockServerSession ,  mockServerMessage )  ;  fail ( "Expected a NullPointerException to be thrown" )  ;  } catch  ( NullPointerException e )  { } catch  ( Exception e )  { fail ( "Unexpected exception thrown: " + e . getClass (  )  . getSimpleName (  )  )  ;  } }
public Dimension function (  )  { Rectangle loc0 = new Rectangle (  )  ;  Dimension loc1 = panel . getPreferredSize (  )  ;  layout (  ( Graphics2D )  loc0 ,  loc1 )  ;  int loc2 =  ( int )  Math . ceil ( loc0 . getWidth (  )  )  ;  int loc3 =  ( int )  Math . ceil ( loc0 . getHeight (  )  )  ;  return new Rectangle ( 0 ,  0 ,  loc2 ,  loc3 )  . getSize (  )  ;  }
public DenseMatrix64F function ( DenseMatrix64F arg0 )  { DenseMatrix64F loc0 = new DenseMatrix64F ( numRows ,  numCols )  ;  loc0 . set ( arg0 )  ;  for  ( int j = 0 ;  j  <  minLength ;  j ++  )  { v [ j ]  = loc0 . get ( j ,  j )  ;  householder ( j )  ;  updateA ( j )  ;  } return QR ;  } Note: This is a modified version of the "getQR (  ) " function of the original class .  The method calculates the QR decomposition of the input matrix "arg0" using Householder reflections and returns the inner matrix "QR" that stores the decomposition . 
import java . io . IOException ;  import java . io . InputStream ;  import java . net . URL ;  public class ResourceLoader { private int TIMEOUT ;  public ResourceLoader ( int timeout )  { this . TIMEOUT = timeout ;  } public InputStream function ( String arg0 )  { InputStream loc0 = null ;  try { loc0 = loadResourceAsStream ( arg0 )  ;  } catch  ( IOException e1 )  { try { URL loc1 = getClassLoader (  )  . getResource ( arg0 )  ;  if  ( loc1 != null )  { loc0 = loc1 . openStream (  )  ;  } } catch  ( IOException e2 )  { throw new RuleSetNotFoundException ( "Unable to find resource: " + arg0 ,  e2 )  ;  } } return loc0 ;  } private InputStream loadResourceAsStream ( String arg0 )  throws IOException { } private ClassLoader getClassLoader (  )  { } private class RuleSetNotFoundException extends RuntimeException { public RuleSetNotFoundException ( String message ,  Throwable cause )  { super ( message ,  cause )  ;  } } }
int function ( OrderLineTypeFacade obj )  { int loc0 = 0 ;  try { loc0 = obj . getLineItem (  )  . getQuantity (  )  . getValue (  )  . intValue (  )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  }
void function ( Gistic g ,  String cytoband )  { try { g . setCytoband ( cytoband )  ;  } catch  ( Exception e )  { } }
ValidateAccess function (  )  { JAXBElement < ValidateAccess >  loc0 = new JAXBElement < ObjectFactory . _ValidateAccess_QNAME ,  ValidateAccess >  (  ObjectFactory . _ValidateAccess_QNAME ,  ValidateAccess . class ,  null ,  new ValidateAccess (  )  )  ;  return loc0 . getValue (  )  ;  }
String function ( HttpServletRequest arg0 )  { String loc0 = arg0 . getParameter ( WebService . FORMAT )  ;  return loc0 == null ? null : loc0 . toLowerCase (  )  ;  }
void function ( DishCollection arg0 )  { DishCollection loc0 = dishCollectionRepository . save ( arg0 )  ;  log . debug ( "Saved a dishCollection: {}" ,  loc0 )  ;  }
public static Sha256Hash function ( byte [  ]  arg0 )  { byte [  ]  loc0 = Sha256Hash . create ( arg0 )  . getBytes (  )  ;  byte [  ]  loc1 = Sha256Hash . Utils . doubleDigest ( loc0 )  ;  return Sha256Hash . create ( loc1 )  ;  }
void function ( String arg0 )  { WorkflowAppService loc0 = new WorkflowAppService (  )  ;  loc0 . init ( null )  ;  }
String function (  )  { try { GregorianCalendar loc0 = GregorianCalendar . getInstance (  )  ;  String loc1 = fromCalendar ( loc0 )  ;  return loc1 ;  } catch  ( Exception loc2 )  { return null ;  } }
public static DiffBuilder function ( final Object arg0 ,  final Object arg1 )  { try { Source source0 = Input . from ( arg0 )  . getSource (  )  ;  Source source1 = Input . from ( arg1 )  . getSource (  )  ;  return DiffBuilder . compare ( source0 )  . withTest ( source1 )  . checkForIdentical (  )  ;  } catch  ( Exception e )  { throw new RuntimeException ( "Failed to create DiffBuilder from input" ,  e )  ;  } }
public static void function ( JSONObject arg0 ,  String arg1 ,  Object arg2 )  { try { arg0 . put ( arg1 ,  arg2 )  ;  } catch  ( JSONException loc0 )  { LOG . warn ( "Unable to add JSON object to array . " ,  loc0 )  ;  } }
T function (  )  { DenseMatrix64F loc0 = new DenseMatrix64F ( mat . numCols ,  mat . numCols )  ;  svd . getV ( loc0 ,  true )  ;  return  ( T )  SimpleMatrix . wrap ( loc0 )  ;  }
public String function (  )  { String loc0 = mAlias ;  return loc0 ;  } Note: Since the original method did not have any arguments or thrown exceptions ,  these elements were removed in the updated method .  Additionally ,  the method name was changed to "function" as per the question prompt ,  although a more descriptive name would be preferable in practice .  Lastly ,  variable and parameter names were changed to conform to the naming conventions specified in the prompt . 
public static void function ( String [  ]  arg0 )  { try { TurnLauncher loc0 = new TurnLauncher (  )  ;  loc0 . start (  )  ;  Logger LOG = LoggerFactory . getLogger ( TurnLauncher . class )  ;  LOG . debug ( "Launching SIP and TURN servers . " )  ;  } catch  ( Throwable loc1 )  { Logger LOG = LoggerFactory . getLogger ( TurnLauncher . class )  ;  LOG . error ( "Failed to launch servers . " ,  loc1 )  ;  } }
void function ( byte [  ]  arg0 )  { projectSecret = arg0 ;  }
public static String function ( String arg0 ,  String arg1 )  { Date loc0 = Date . valueOf ( arg0 )  ;  SimpleDateFormat loc1 = new SimpleDateFormat ( "yyyy-MM-dd" )  ;  return loc1 . format ( loc0 )  ;  }
int function ( SymmetricQrAlgorithm arg0 ,  double arg1 ,  double arg2 )  { int loc0 = 0 ;  for  ( int i = 0 ;  i  <  arg0 . getNumberOfEigenvalues (  )  ;  i ++  )  { double loc1 = arg0 . getEigenvalue ( i )  ;  if  ( Math . abs ( loc1 - arg1 )   < = arg2 )  { loc0 ++  ;  } } return loc0 ;  }
public static void function ( ServiceInfo arg0 )  { BasicNameManager loc0 = new BasicNameManager (  )  ;  try { loc0 . initialize ( arg0 ,  null )  ;  } catch  ( Exception e )  { } }
Object function (  )  { handler = new ConfigurationHandler (  )  . function (  )  ;  return handler ;  }
FederationProposal function ( String arg0 )  { for  ( FederationProposal loc0 : getPendingFederationProposals (  )  )  { if  ( loc0 . getToken (  )  . equals ( arg0 )  )  { return loc0 ;  } } return null ;  }
void function ( String arg0 )  { _cssText = "Not supported ,  class is immutable .  Sets the string representation of the current value . " ;  }
Block loc0 = new Block ( arg0 ,  arg1 )  ;  String loc1 = loc0 . fileName (  )  ;  int loc2 = loc0 . number (  )  ;  pg . read ( loc0 )  ;  pg . getInt ( pg . getInt ( Page . maxSize - Integer . BYTES )  )  ; 
Object function ( Object arg0 ,  Object arg1 )  throws Exception { InitialContext loc0 = new InitialContext (  )  ;  Object loc1 = loc0 . lookup ( "java:comp/env/ejb/TargetObject" )  ;  Class < ? >  loc2 = loc1 . getClass (  )  ;  loc2 . getMethod ( "methodName" ,  param1 ,  param2 )  . invoke ( loc1 ,  arg0 ,  arg1 )  ;  }
public List < String >  function (  )  { List < String >  loc0 = acceptedEncryptionAlgorithms ;  return loc0 ;  }
public void function ( BundleContext arg0 )  { AutoSIMConnectionConfig arg1 = config . connections ;  environments . deregisterConnectionFactory ( loc0 . name )  ;  factories . remove ( loc0 . name )  ;  }
String function ( String [  ]  arg0 ,  Object [  ]  [  ]  arg1 )  { try { Borders FULL = Borders . of ( Borders . SINGLE_LINE ,  Borders . SINGLE_LINE ,  Borders . SINGLE_LINE ,  Borders . SINGLE_LINE ,  Borders . SINGLE_LINE ,  Borders . SINGLE_LINE ,  Borders . SINGLE_LINE ,  Borders . SINGLE_LINE )  ;  FlipTable table = new FlipTable ( arg0 . length ,  null ,  0 ,  0 ,  arg0 ,  arg1 ,  FULL )  ;  return table . toString (  )  ;  } catch  ( Exception e )  { return "Error creating table: " + e . getMessage (  )  ;  } }
public Node function ( Node arg0 ,  Node arg1 )  { String loc0 = xpath . replace ( "TARGET" ,  target . getNodeName (  )  )  ;  Node loc1 = arg0 . selectSingleNode ( loc0 )  ;  Object loc2 = getValue (  )  ;  Object loc3 = null ;  if  ( loc1 != null )  { switch  ( type )  { case ATTRIBUTE: loc3 = loc1 . valueOf ( control . getValue (  )  )  ;  break ;  case NODE: loc3 = loc1 . asXML (  )  ;  break ;  case TEXT: loc3 = loc1 . getText (  )  ;  break ;  } } loc2 = value != null ? value : loc2 ;  Detail loc4 = new Detail ( loc2 ,  loc3 )  ;  return new DetailFormatter (  )  . format ( loc4 )  ;  }
void function ( Object arg0 ,  Object arg1 ,  Collection arg2 )  { impl . function ( arg0 ,  arg1 ,  arg2 )  ;  }
void function (  )  { long arg0 = 1000L ;  long arg1 = TimeUnit . SECONDS . toMillis ( 1 )  ;  String loc0 = WebUtils . convertMsToClockTime ( arg0 )  ;  String loc1 = WebUtils . convertMsToClockTime ( arg1 )  ;  Assert . assertEquals ( "00:00:01" ,  loc0 )  ;  Assert . assertEquals ( "00:01:00" ,  loc1 )  ;  }
public String function ( VisibilityKindEnum arg0 )  { String loc0 = arg0 . literalName ;  if  ( loc0 == null )  { throw new IllegalArgumentException ( "Invalid argument: null literalName" )  ;  } return loc0 ;  }
public List < ClassdiagramNode >  function (  )  { return downlinks ;  }
String function (  )  { String loc0 ;  try { loc0 = createRuntimeDir (  )  ;  } catch  ( IOException loc1 )  { throw new RuntimeException ( "Could not create runtime directory" ,  loc1 )  ;  } return loc0 ;  }
public boolean function ( String arg0 ,  boolean arg1 )  { boolean loc0 = arg1 ;  try { if  ( !arg0 . isEmpty (  )  )  { loc0 = Boolean . parseBoolean ( arg0 . trim (  )  )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
void function ( SeekBar arg0 ,  int arg1 ,  boolean arg2 )  { int loc0 = arg0 . getProgress (  )  ;  int loc1 = arg0 . getMax (  )  ;  arg0 . setProgress ( loc0 )  ;  arg0 . onProgressChanged ( arg0 ,  loc0 ,  false )  ;  }
void function (  )  { setUp (  )  ;  time . setHour ( 5 )  ;  assertEquals ( 5 ,  time . getHour (  )  )  ;  time . setHour ( 0 )  ;  assertEquals ( 0 ,  time . getHour (  )  )  ;  time . setHour ( 23 )  ;  assertEquals ( 23 ,  time . getHour (  )  )  ;  }
int function ( DatePicker arg0 )  { int loc0 = arg0 . getDayOfMonth (  )  ;  int loc1 = arg0 . getMonth (  )  ;  int loc2 = arg0 . getYear (  )  ;  Calendar loc3 = Calendar . getInstance (  )  ;  loc3 . set ( Calendar . DAY_OF_MONTH ,  loc0 )  ;  loc3 . set ( Calendar . MONTH ,  loc1 )  ;  loc3 . set ( Calendar . YEAR ,  loc2 )  ;  Date loc4 = loc3 . getTime (  )  ;  return loc4 ;  }
void function ( Timestamp arg0 )  { try { setCreatedDate ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
public boolean function ( Collection < Assertion >  arg0 ,  Collection < Assertion >  arg1 )  { boolean loc0 = false ;  for  ( Assertion loc1 : arg1 )  { if  ( !arg0 . contains ( loc1 )  )  { return false ;  } loc0 = true ;  } return loc0 ;  }
NodeVisitor function ( Node arg0 )  { return arg0 . begin (  )  ;  }
public XsdStringType function (  )  { XsdStringType loc0 = null ;  try { loc0 = this . paramValue ;  } catch  ( Exception loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
String function ( String arg0 )  { String loc0 = null ;  try { loc0 = arg0 . valueOf ( "" )  . toUpperCase (  )  ;  } catch  ( Exception e )  { loc0 = "Error: " + e . getMessage (  )  ;  System . err . println ( loc0 )  ;  throw new RuntimeException ( loc0 )  ;  } return loc0 . replaceAll ( "//s+" , "" )  ;  }
int function ( ViewConfiguration arg0 )  { int loc0 ;  try { loc0 = IMPL . getScaledPagingTouchSlop ( arg0 )  ;  } catch  ( NoSuchMethodError e )  { loc0 = arg0 . getScaledTouchSlop (  )  ;  } return loc0 ;  }
TypeNode function ( String fmt ,  Object .  .  .  subst )  { QQParser parser = new QQParser (  )  ;  return parser . parse ( QQ . TYPE ,  fmt ,  subst )  ;  }
public void function (  )  { RMBTest rmbTest = new RMBTest (  )  ;  try { rmbTest . rmb . setSteerTo ( null )  ;  fail ( "IllegalArgumentException expected" )  ;  } catch  ( IllegalArgumentException e )  { assertTrue ( "Exception message does not contain expected text" ,  e . getMessage (  )  . contains ( "null is not a valid steer-to value" )  )  ;  } catch  ( Exception e )  { fail ( "Unexpected exception thrown: " + e . getMessage (  )  )  ;  } }
void function ( PaymentChannelServer loc0 )  { if  ( loc0 != null && connectedHandler != null )  { connectedHandler . close (  )  ;  } }
public void function ( PropertyChangeListener arg0 )  { try { m_PropertyChangeSupport . addPropertyChangeListener ( arg0 )  ;  } catch  ( Exception e )  { } }
Client function (  )  { Client loc0 = client . function ( arg0 ,  arg1 )  ;  return loc0 ;  }
public static String function ( AccessibilityServiceInfo arg0 )  { try { return IMPL . getDescription ( arg0 )  ;  } catch  ( Exception e )  { return null ;  } }
void function ( Locale loc0 ,  String str0 ,  String str1 )  { try { Locale . setDefault ( loc0 )  ;  HashMap < String ,  ResourceBundle >  map = new HashMap < String ,  ResourceBundle >  (  )  ;  } catch  ( Exception e )  { LOG . warning ( "Failed to set default Locale: " + e . getMessage (  )  )  ;  } }
public Script function ( Address arg0 ,  ECKey arg1 ,   @ Nullable byte [  ]  arg2 ,  Script arg3 )  { byte [  ]  loc0 = arg1 . getPubKey (  )  ;  byte [  ]  loc1 = arg3 . getProgram (  )  ;  byte [  ]  loc2 = loc1 . clone (  )  ;  int loc3 = 0 ;  int loc4 = Script . decodeFromOpN ( loc2 [ loc3 ++  ]  )  ;  byte [  ]  loc5 ;  if  ( arg2 == null )  { loc5 = new byte [  ] {} ;  } else { loc5 = arg2 ;  } loc2 [ loc3 ++  ]  =  ( byte )   ( loc5 . length + 2 )  ;  loc2 [ loc3 ++  ]  =  ( byte )   ( loc5 . length / 2 )  ;  System . arraycopy ( loc5 ,  0 ,  loc2 ,  loc3 ,  loc5 . length )  ;  loc3 += loc5 . length ;  loc2 [ loc3 ++  ]  =  ( byte )   ( loc4 + loc5 . length / 2 + 2 )  ;  loc2 [ loc3 ++  ]  =  ( byte )  0xac ;  loc2 [ loc3 ++  ]  =  ( byte )   ( loc1 . length + 1 )  ;  loc2 [ loc3 ++  ]  =  ( byte )  0x87 ;  System . arraycopy ( loc1 ,  0 ,  loc2 ,  loc3 ,  loc1 . length )  ;  loc3 += loc1 . length ;  ScriptBuilder loc6 = new ScriptBuilder (  )  ;  loc6 . data ( loc2 )  ;  loc6 . data ( loc0 )  ;  return loc6 . build (  )  ;  }
Timestamp function (  )  { try { return this . receiptDate ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  return null ;  } }
void function ( boolean arg0 )  { enforceKnownIssuer = arg0 ;  }
public ValidateAccess function ( ValidateTokenResponse arg0 )  { ValidateAccess loc0 = arg0 . access ;  return loc0 ;  }
class ArgoVersion { String VERSION = "PRE-0 . 26 . alpha1" ;  void function (  )  { try { String loc0 = VERSION . toLowerCase (  )  ;  String loc1 = loc0 . replaceAll ( " [ ^a-z0-9 ] +" ,  "" )  ;  String loc2 = loc1 . substring ( 0 ,  Math . min ( loc1 . length (  )  ,  20 )  )  ;  String loc3 = loc2 . replaceAll ( " ( \\d+ ) " ,  "0$1" )  ;  String loc4 = loc3 . replaceAll ( "0* ( \\d{4} ) " ,  "$1" )  ;  String loc5 = loc4 . replaceAll ( "0* ( \\d{2 , } ) " ,  "$1" )  ;  String loc6 = loc5 . replaceAll ( " ( \\d+ ) " ,  "$1 . " )  . replaceAll ( "\\ . $" ,  "" )  ;  System . out . println ( "Version: " + loc6 )  ;  } catch  ( Exception loc7 )  { loc7 . printStackTrace (  )  ;  } } }
void function ( int arg0 ,  int arg1 )  { rp . moveTo ( arg0 )  ;  currentblknum = arg0 ;  rp . currentRid (  )  . setId ( arg1 )  ;  }
void function ( WalkDirection arg0 )  { viewer . moveCharacter2d ( arg0 )  ;  }
public BlockWorkerClient acquireWorkerClient ( InetSocketAddress arg0 )  { Preconditions . checkNotNull ( arg0 )  ;  long loc0 = IdUtils . getRandomNonNegativeLong (  )  ;  BlockWorkerClient loc1 = new RetryHandlingBlockWorkerClient (  new BlockWorkerThriftClientPool (  NETTY_CHANNEL_POOL_MAP . get ( arg0 )  ,  BLOCK_WORKER_THRIFT_CLIENT_POOL . get ( arg0 )  ,  BLOCK_WORKER_THRIFT_CLIENT_HEARTBEAT_POOL . get ( arg0 )  ,  acquireNettyChannel ( arg0 ,   (  )  - >  createNettyBootstrap ( arg0 )  )  )  ,  mHasLocalWorker )  ;  return loc1 ;  }
String function (  )  { String loc0 = this . failedAttrib ;  return loc0 ;  }
public void function ( Map < String , Object >  arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 )  { try { arg0 . put ( "soapAction" ,  arg1 )  ;  arg0 . put ( "contentType" ,  arg2 )  ;  arg0 . put ( "messageId" ,  arg3 )  ;  arg0 . put ( "correlationId" ,  arg4 )  ;  arg0 . put ( "replyTo" ,  arg5 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public int function ( Object arg0 )  { int loc0 ;  try { loc0 = super . hashCode (  )  ;  } catch  ( Exception loc1 )  { loc0 = 0 ;  } loc0 = 31 * loc0 +  ( arg0 == null ? 0 : arg0 . hashCode (  )  )  ;  return loc0 ;  }
ValidatedItemDTO [  ]  function ( String arg0 ,  boolean arg1 )  { try { return stub . validateAuthnRequest ( arg0 ,  arg1 )  ;  } catch  ( RemoteException loc0 )  { log . error ( "srini_string" ,  loc0 )  ;  throw new AxisFault ( loc0 . getMessage (  )  ,  loc0 )  ;  } }
Sha256Hash function ( Block arg0 )  { try { byte [  ]  loc0 = arg0 . bitcoinSerialize (  )  ;  return Sha256Hash . wrapReversed ( Sha256Hash . hashTwice ( loc0 )  )  ;  } catch  ( IOException e )  { throw new RuntimeException ( e )  ;  } }
import com . google . common . io . Files ;  import java . io . File ;  import java . io . IOException ;  public class FileUtils { private static final Logger LOG = LoggerFactory . getLogger ( Constants . LOGGER_TYPE )  ;  public static void function ( String arg0 ,  String arg1 )  throws IOException { File loc0 = new File ( arg0 )  ;  File loc1 = new File ( arg1 )  ;  Files . move ( loc0 ,  loc1 )  ;  } }
List < Object >  function ( JSONArray arg0 )  { List < Object >  nodes = new ArrayList <  >  (  )  ;  for  ( int loc0 = 0 ;  loc0  <  arg0 . length (  )  ;  loc0 ++  )  { JSONObject loc1 = arg0 . getJSONObject ( loc0 )  ;  nodes . add ( new Object (  )  { String type = loc1 . getString ( "type" )  ;  String value = loc1 . getString ( "value" )  ;  } )  ;  } return nodes ;  }
void function (  )  { try { md5Cache . clear (  )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Failed to clean the md5 cache: " + loc0 . getMessage (  )  )  ;  } }
String function (  )  { try { return this . inactivationReasonType ;  } catch  ( Exception e )  { return null ;  } }
void function ( Object arg0 ,  Object arg1 ,  Exception e )  { try { Log loc0 = LogFactory . getLog ( ClaimAdminClient . class )  ;  loc0 . error ( "Error occurred while processing " + arg0 + " and " + arg1 ,  e )  ;  throw new AxisFault ( "Error occurred while processing " + arg0 + " and " + arg1 ,  e )  ;  } catch  ( AxisFault af )  { throw af ;  } catch  ( Exception ex )  { throw new AxisFault ( "Error occurred while processing " + arg0 + " and " + arg1 ,  ex )  ;  } }
ByteBuffer function ( int capacity ,  int value )  { ByteBuffer buf = ByteBuffer . allocate ( capacity )  ;  buf . putInt ( value )  ;  buf . flip (  )  ;  return buf ;  }
int function ( int arg0 ,  int arg1 ,  double loc0 ,  Timestamp loc1 ,  int loc2 ,  long loc3 ,  double loc4 )  { return this . lane_id ;  }
public static boolean function ( String arg0 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 . length (  )  ;  loc0 ++  )  { if  ( loc0 == 0 )  { if  ( !Character . isJavaIdentifierStart ( arg0 . charAt ( 0 )  )  )  { return false ;  } } else { if  ( !Character . isJavaIdentifierPart ( arg0 . charAt ( loc0 )  )  )  { return false ;  } } } return true ;  }
boolean function (  )  { ConfigurationHandler loc0 = getFactory (  )  . getConfigurationHandler (  )  ;  return loc0 . loadDefault (  )  ;  }
void function ( List < Double >  arg0 )  { try { profits . add ( arg0 )  ;  } catch  ( Exception e )  { } }
public void function ( Sha256Hash arg0 ,  int arg1 )  { try { StoredTransactionOutPoint outPoint = new StoredTransactionOutPoint ( arg0 ,  arg1 )  ;  BeginTransaction (  )  ;  StoredTransactionOutput output = transactionOutputMap . remove ( outPoint )  ;  if  ( output != null )  { removeUnspentTransactionOutput ( output )  ;  } CommitTransaction (  )  ;  } catch  ( Exception e )  { AbortTransaction (  )  ;  throw new RuntimeException ( "Error while removing output index: " + e . getMessage (  )  )  ;  } }
void function ( InStreamOptions options ,  long arg0 )  { options . setSeekBufferSizeBytes ( arg0 )  ;  return ;  }
String function ( Date arg0 ,  DateTimeFormat arg1 ,  boolean showTimeZone )  { Date loc0 ;  try { loc0 = new Date (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } String loc1 = formatUTC ( loc0 ,  arg1 ,  showTimeZone )  ;  return formatUTCtoSqlUTC ( parseUTC ( loc1 ,  arg1 )  )  ;  }
void function ( T arg0 )  { Integer loc0 = counter . get ( arg0 )  ;  if  ( loc0 == null )  { counter . put ( arg0 ,  1 )  ;  } else { counter . put ( arg0 ,  loc0 + 1 )  ;  } }
public void function ( List < TestResultDTO >  arg0 ,  TestResultsDTO arg1 )  { try { arg1 . setTestResultLst ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
Object function ( Context arg0 ,  Scriptable arg1 ,  Object arg2 ,  Class < ? >  arg3 )  { try { return new NativeJavaObject ( arg1 ,  arg2 ,  arg3 )  ;  } catch  ( Exception loc0 )  { return null ;  } }
String function (  )  { try { return this . mTierAlias ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  return null ;  } }
PaymentChannelServerState function ( Wallet arg0 ,  TransactionBroadcaster arg1 )  { checkArgument ( connectedHandler != null ,  "No connected handler" )  ;  TransactionOutput loc0 = clientOutput ;  ECKey loc1 = myKey ;  BigInteger loc2 = bestValueToMe ;  byte [  ]  loc3 = bestValueSignature ;  Transaction loc4 = contract ;  long loc5 = refundTransactionUnlockTimeSecs ;  return PaymentChannelServerState . of (  arg0 ,  loc4 ,  loc0 ,  loc1 ,  loc2 ,  loc3 ,  connectedHandler ,  loc5 ,  arg1 )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = getPrefix ( arg1 )  ;  if  ( loc0 == null )  { loc0 = "ns" + nsCounter ++  ;  collect ( loc0 ,  arg1 )  ;  } return loc0 + ":" + arg0 ;  }
Plan function ( Object arg0 ,  Object arg1 )  { Plan rhsPlan = rhs . materialize (  )  ;  int fileSize = rhsPlan . blocksAccessed (  )  ;  int numBuffers = MultiBufferProductPlan . bufferManager (  )  . available (  )  ;  int chunkSize = Math . min ( numBuffers - 2 ,  fileSize )  ;  List < Plan >  chunkPlans = rhsPlan . chunkPlan ( chunkSize )  ;  return new MultiBufferProductScan (  copyRecordsFrom ( lhs )  ,  schema (  )  ,  new TableInfo ( "" ,  schema (  )  ,  new ArrayList <  >  (  )  )  ,  new ArrayList <  >  (  )  ,  chunkPlans ,  new ArrayList <  >  (  )   )  ;  }
void function ( boolean arg0 )  { _highPriority = arg0 ;  }
ServerSession function ( String arg0 )  { ServerSession loc0 = null ;  try { loc0 = userSessionMap . get ( arg0 )  ;  } catch  ( Exception e )  { LOGGER . error ( "Error obtaining ServerSession for user with id " + arg0 ,  e )  ;  } return loc0 ;  }
public String function ( Client client )  { try { return client . getApplicationDescription (  )  ;  } catch  ( NullPointerException e )  { System . err . println ( "Application description is null . " )  ;  } return null ;  }
List < String >  function (  )  { try { return links . getVertexLabels (  )  ;  } catch  ( Exception e )  { return null ;  } }
String function ( String arg0 )  { try { if  ( groupfields . contains ( arg0 )  )  { return groupval . getVal ( arg0 )  ;  } else { for  ( AggregationFn loc0 : aggfns )  { if  ( loc0 . hasField ( arg0 )  )  { return loc0 . fieldName ( arg0 )  . value (  )  ;  } } } throw new RuntimeException ( "Field not found: " + arg0 )  ;  } catch  ( Exception e )  { return null ;  } }
String function ( Steps obj )  { String loc0 = obj . getTestData (  )  ;  return loc0 ;  } The above method is a concise implementation that takes an object of the "Steps" class and returns the value of the "testData" member variable .  The method simply calls the "getTestData (  ) " function of the "Steps" class and returns its value .  No exception handling or other operations are included in this method . 
public void function ( LocalAlluxioClusterResource locRes ,  PropertyKey key ,  String value )  { try { locRes . put ( key ,  value )  ;  System . out . println ( locRes . toString (  )  )  ;  } catch  ( Exception e )  { System . out . println ( "Error: " + e . getMessage (  )  )  ;  } }
String function ( String arg0 ,  String [  ]  arg1 )  { try { if ( StringUtils . isEmpty ( arg0 )  )  { throw new IdentityValidationException ( "Input is empty" )  ;  } if ( !isValidOverBlackListPatterns ( arg0 ,  arg1 )  )  { String patternString = getPatternString ( arg1 )  ;  String errorMsg = String . format ( "%s%s%s%s%s" ,  msgSection1 ,  arg0 ,  msgSection3 ,  patternString ,  msgSection4 )  ;  throw new IdentityValidationException ( errorMsg )  ;  } return arg0 ;  } catch ( IdentityValidationException e )  { } }
Schema function (  )  { Schema loc0 = srcplan . schema (  )  ;  return loc0 ;  }
Result function ( ResultEntry arg0 ,  ResultObserver arg1 )  { globalLog . add ( arg0 )  ;  notifyObserversAdd ( arg0 )  ;  boolean containsObject = log . contains ( arg0 )  ;  List < String >  sources = getSources ( arg1 )  ;  log . add ( arg0 )  ;  return globalLog ;  }
Map < Object ,  String >  function ( Set < Object >  arg0 ,  Color arg1 )  { Map < Object ,  String >  map = new HashMap <  >  (  )  ;  Color baseColor = getRandomColor (  )  ;  for  ( Object loc0 : arg0 )  { Color color = tintColor ( baseColor ,  FIXED_TINT_FACTOR )  ;  map . put ( loc0 ,  getColorString ( color )  )  ;  } return map ;  }
function ( int arg0 ,  int arg1 )  { try { setPopulationSize ( 0 )  ;  setIterations ( 0 )  ;  } catch  ( Exception loc0 )  { } }
Element function ( Document arg0 ,  Element arg1 )  { Element domainsAssignment = arg0 . createElement ( "DomainsAssignment" )  ;  for  ( DomPair loc0 : getDomainAssignment (  )  )  { Element domainPairElement = arg0 . createElement ( "DomainPair" )  ;  writeSourceSinkDomPair ( loc0 ,  arg0 ,  domainPairElement )  ;  domainsAssignment . appendChild ( domainPairElement )  ;  } arg1 . appendChild ( domainsAssignment )  ;  return domainsAssignment ;  }
int function ( List < Object >  arg0 )  { int loc0 = 0 ;  try { loc0 = arg0 . size (  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function ( String arg0 ,  String arg1 )  { String loc0 = System . getProperty ( "line . separator" )  ;  String loc1 = Configuration . getString ( Argo . KEY_INPUT_SOURCE_ENCODING )  ;  if  ( !arg0 . equals ( loc1 )  )  { Configuration . setString ( Argo . KEY_INPUT_SOURCE_ENCODING ,  arg0 )  ;  Configuration . setString ( "uml . utility . encoding" ,  arg0 )  ;  loc1 = arg0 ;  } if  ( arg1 != null )  { loc1 = arg1 ;  } PersistenceManager . getPersistenceManager (  )  . setEncoding ( loc1 )  ;  }
void function ( XDebug arg0 ,  int arg1 ,  String arg2 )  { Class loc0 = arg0 . getClass (  )  ;  XDebugMessage loc1 = new XDebugMessage ( arg1 ,  arg2 )  ;  String loc2 = loc0 . getName (  )  ;  arg0 . add ( loc1 )  ;  }
MetadataEditorCompat function ( int arg0 ,  long arg1 )  { MetadataEditorCompat loc0 = editMetadata ( true )  ;  loc0 . putLong ( arg0 ,  arg1 )  ;  return loc0 ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole (  )  ;  loc0 . setLedsAnimation (  )  ;  loc0 . spinLeft (  )  ;  loc0 . doFor ( arg0 ,  arg1 )  ;  loc0 . hover (  )  ;  }
ResponseEntity < Ingredient >  function (  @ PathVariable String arg0 )  { try { log . debug ( "REST request to get Ingredient : {}" ,  arg0 )  ;  Optional < Ingredient >  loc0 = ingredientService . findOne ( arg0 )  ;  return loc0 . map ( result - >  new ResponseEntity <  >  ( result ,  HttpStatus . OK )  )  . orElse ( new ResponseEntity <  >  ( HttpStatus . NOT_FOUND )  )  ;  } catch  ( Exception e )  { log . debug ( "Exception while getting Ingredient : {}" ,  arg0 ,  e )  ;  return ResponseEntity . status ( HttpStatus . INTERNAL_SERVER_ERROR )  . build (  )  ;  } }
void function ( Element arg0 )  { try { testNode ( arg0 ,  null )  ;  } catch  ( Exception e )  { System . err . println ( "Exception caught: " + e . getMessage (  )  )  ;  } }
String function ( String arg0 ,  int arg1 )  { String loc0 = "" ;  try { loc0 = getStringValue ( arg0 ,  arg1 )  ;  if  ( loc0 . isEmpty (  )  )  { loc0 = "{Empty}" ;  } } catch  ( SQLException loc1 )  { loc1 . printStackTrace (  )  ;  } return loc0 ;  }
public static String function ( String arg0 )  { try { int loc0 = arg0 . lastIndexOf ( ' . ' )  ;  if  ( loc0  > = 0 )  { return arg0 . substring ( 0 ,  loc0 )  ;  } } catch  ( Exception e )  { } return "" ;  }
 @ Override boolean function ( Object arg0 )  { if  ( this == arg0 )  return true ;  if  ( ! ( arg0 instanceof SimpleTypedNameDeclaration )  )  return false ;  SimpleTypedNameDeclaration loc0 =  ( SimpleTypedNameDeclaration )  arg0 ;  if  ( !internalEquals ( loc0 )  )  return false ;  if  ( !internalEqualsNext ( loc0 )  )  return false ;  if  ( type != null && loc0 . type != null && !type . isAssignableFrom ( loc0 . type )  && !loc0 . type . isAssignableFrom ( type )  )  { return false ;  } return true ;  }
String function (  )  { String partNumber = "" ;  try { partNumber = lineItem . getLineItem (  )  . getItem (  )  . getSellersItemIdentification (  )  . getID (  )  . getValue (  )  ;  } catch  ( Exception e )  { } return partNumber ;  }
void function ( int arg0 )  { skipBytes = arg0 ;  }
void function ( TMXTile arg0 ,  TMXTiledMap arg1 ,  int arg2 )  { try { arg0 . setGlobalTileID ( arg1 ,  arg2 )  ;  } catch  ( Exception loc0 )  { System . err . println ( "You'd probably want to call TMXTile . setGlobalTileID instead . " )  ;  } }
void function (  )  { long arg0 = 1000L ;  long arg1 = 2000L ;  mBlockStoreMeta = new BlockStoreMeta ( TEST_SESSION_ID ,  mMetadataManager )  ;  mBlockStoreMeta . init ( TEST_BLOCK_SIZE ,  arg0 ,  arg1 )  ;  long loc0 = mBlockStoreMeta . getDefaultTotalCapacityBytes (  )  ;  long loc1 = mBlockStoreMeta . getCapacityBytes (  )  ;  assertEquals ( loc0 ,  arg0 )  ;  assertEquals ( loc1 ,  arg1 )  ;  }
String function (  )  throws IOException { CharBuffer loc0 = cbuf . clear (  )  ;  while  ( readable . read ( loc0 )  != -1 )  { loc0 . flip (  )  ;  lineBuf . add ( buf ,  loc0 . position (  )  ,  loc0 . remaining (  )  )  ;  loc0 . clear (  )  ;  if  ( lines . peek (  )  != null )  { return lines . poll (  )  ;  } } if  ( lineBuf . size (  )   >  0 )  { lineBuf . finish (  )  ;  return lines . poll (  )  ;  } return null ;  }
void function ( int arg0 )  { GSVTest gsvTest = new GSVTest (  )  ;  gsvTest . setSentenceCount ( arg0 )  ;  int loc0 = gsvTest . getSentenceCount (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  }
String function ( String arg0 )  { EaseEmojicon emoji = new EaseEmojicon (  )  ;  emoji . setIconPath ( arg0 )  ;  return arg0 ;  }
String function ( Object arg0 ,  Object arg1 )  { Proxy loc0 = getProxy (  )  ;  Authentication loc1 = getAuth (  )  ;  String username = loc1 . getUsername (  )  ;  String password = loc1 . getPassword (  )  ;  return  ( loc0 != null && username != null && password != null )  ? "Proxy has username and password set . " : "Proxy does not have username and password set . " ;  }
void function ( InputStream arg0 ,  IParserEventHandler arg1 )  { DefaultEventHandler defaultHandler = new DefaultEventHandler (  )  ;  RawRtfParser parser = new RawRtfParser ( arg0 ,  defaultHandler )  ;  parser . parse (  )  ;  }
Result function ( Result arg0 ,  Result arg1 )  { if  ( !arg0 . equals ( arg1 )  )  { List < String >  sources0 = arg0 . getSources (  )  ;  List < String >  sources1 = arg1 . getSources (  )  ;  sources0 . removeAll ( sources1 )  ;  for  ( String loc0 : sources0 )  { arg1 . addObserverLogSource ( new ResultObserverImpl (  )  ,  loc0 )  ;  } for  ( ResultEntry loc1 : arg0 )  { String source = loc1 . getSource (  )  ;  if  ( !sources0 . contains ( source )  )  { arg1 . add ( loc1 )  ;  } } } return arg1 ;  }
void function (  )  { DenseMatrix64F loc0 = new DenseMatrix64F ( 2 , 2 , true , 0 . 2 , 1 , -2 , 3 )  ;  double loc1 = NormOps . conditionP2 ( loc0 )  ;  double loc2 = 1 . 7320508075688772 ;  assertEquals ( loc2 ,  loc1 ,  UtilEjml . TEST_F64 )  ;  double loc3 = 1 . 0/Math . sqrt ( 2 . 0 )  ;  DenseMatrix64F loc4 = new DenseMatrix64F ( 2 , 2 , true , 1 , 1 , 0 , 1 )  ;  CommonOps_DDRM . scale ( loc3 ,  loc4 )  ;  DenseMatrix64F loc5 = new DenseMatrix64F ( 2 , 2 , true , 0 . 416025 , 0 . 27735 , -0 . 138675 , 0 . 5547 )  ;  assertEquals ( loc5 ,  loc4 ,  UtilEjml . TEST_F64 )  ;  double loc6 = -5 . 0 ;  checkUncountable ( loc6 )  ;  }
void function (  )  { try { Mockito . when ( mClient . listObjects ( BUCKET_NAME ,  BUCKET_PREFIX + PATH )  )   . thenThrow ( new ServiceException ( "Exception occurred while listing objects" )  )  ;  mOSSUnderFileSystem . delete ( PATH ,  true )  ;  Assert . assertFalse ( "Failed to delete path " + PATH ,  mOSSUnderFileSystem . exists ( PATH )  )  ;  } catch  ( ServiceException e )  { e . printStackTrace (  )  ;  } }
List < Language >  function ( File arg0 )  { List < Language >  loc0 = new ArrayList <  >  (  )  ;  try { String fileName = arg0 . getName (  )  ;  loc0 = LanguageVersionDiscoverer . getLanguagesForFile ( fileName )  ;  } catch  ( Exception e )  { } return loc0 ;  }
static void function ( FeatureSpecificTestSuiteBuilder builder ,  Method .  .  .  methods )  { builder . suppressedTests . addAll ( Arrays . asList ( methods )  . suppressing (  )  )  ;  }
void function ( AudioManager arg0 ,  RemoteControlClientCompat arg1 )  { if  ( sHasRemoteControlAPIs )  { arg0 . registerRemoteControlClient ( arg1 . getActualRemoteControlClientObject (  )  )  ;  } }
public long function (  )  { try { incrementMessagesSent (  )  ;  return messagesSent ;  } catch  ( Exception e )  { return -1 ;  } }
lalr_item function ( lalr_item_set arg0 )  { Iterator < lalr_item >  loc0 = arg0 . _all . values (  )  . iterator (  )  ;  if  ( arg0 . size (  )  == 0 )  { return null ;  } lalr_item loc1 = loc0 . next (  )  ;  loc0 . remove (  )  ;  return loc1 ;  }
class URLConnectionInfo { URI theURI ;  URI function (  )  { return theURI ;  } }
void function ( String arg0 )  { String loc0 = this . config . getFilterName (  )  + "srini_string" + arg0 ;  this . config . getServletContext (  )  . log ( loc0 )  ;  }
 @ Override public String function ( String arg0 ,  Map < String ,  String >  arg1 )  { if ( PROVISIONING_IDP . equals ( arg0 )  )  { return null ;  } else { return loc0 ;  } }
void function (  )  { GSVSentence loc0 = new GSVSentence ( EXAMPLE )  ;  GSVParser parser = new GSVParser ( "srini_string" )  ;  parser . parse ( loc0 )  ;  List < SatelliteInfo >  loc1 = parser . getSatelliteInfo (  )  ;  assertEquals ( 2 ,  loc1 . size (  )  )  ;  testSatelliteInfo ( loc1 . get ( 0 )  ,  "srini_string" ,  56 ,  182 ,  51 )  ;  testSatelliteInfo ( loc1 . get ( 1 )  ,  "srini_string" ,  38 ,  163 ,  47 )  ;  }
void function (  )  { DataByteBuffer dataByteBuffer = new DataByteBuffer (  )  ;  ByteBuffer loc0 = dataByteBuffer . getNettyOutput (  )  ;  assertTrue ( loc0 . limit (  )  == LENGTH )  ;  }
boolean function (  )  { return loggingEnabled ;  }
public String function ( String arg0 ,  String arg1 )  { String issuer = null ;  try { RegisteredClient client = clients . get ( arg0 )  ;  issuer = client . getIssuer ( arg1 )  ;  issuer = client . get ( arg1 )  . getIssuer (  )  ;  } catch  ( Exception e )  { } return issuer ;  }
String function ( String arg0 )  { String loc0 = arg0 . trim (  )  ;  // Remove leading/trailing whitespace int loc1 = loc0 . lastIndexOf ( " . " )  ;  if  ( loc1  <  0 )  { return loc0 ;  } return loc0 . substring ( 0 ,  loc1 )  ;  }
boolean function ( String arg0 ,  FieldSigMask arg1 )  { FieldSignature loc0 = new FieldSignature ( arg0 )  ;  Set < String >  loc1 = fields . keySet (  )  ;  if  ( arg1 . covers ( loc0 )  )  { Set < String >  loc2 = fields . get ( loc0 )  ;  return loc2 != null && loc2 . contains ( arg0 )  ;  } return false ;  }
Object function ( TreePath arg0 ,  Object arg1 )  { TreePath parentPath = arg0 . getParentPath (  )  ;  Object lastPathComponent = arg0 . getLastPathComponent (  )  ;  int index = arg1 != null ? getIndexOfChild ( parentPath . getLastPathComponent (  )  ,  arg1 )  : -1 ;  if  ( index  > = 0 )  { fireChildChanged ( parentPath ,  index ,  arg1 )  ;  } fireChildrenChanged ( parentPath ,  new int [  ]  {index} ,  new Object [  ]  {arg1} )  ;  return lastPathComponent ;  }
void function ( ServiceID arg0 ,  int arg1 ,  int arg2 ,  InetAddress arg3 )  { int loc0 = RETVAL_NOENTRY ;  try { loc0 = removeService ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  } finally { onServiceUnregistration ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  null )  ;  } if  ( loc0 == RETVAL_OK )  { return ;  } throw new IllegalArgumentException ( getRetvalString ( loc0 )  )  ;  } Note: This is a modified version of the original method "function" from the "HostCtrlCallbacks" class in Java .  The modifications include removing comments ,  removing the function modifiers  ( such as public ,  private ,  protected )  ,  changing argument names to generic names ,  changing local variable names to generic names ,  and removing any exception handling .  The purpose of this modified method is to remove a service and notify the relevant parties of the removal .  If the removal is successful ,  the function returns normally .  Otherwise ,  it throws an exception with a message indicating the reason for the failure . 
void function ( String arg0 )  { testId = arg0 ;  }
void function (  )  { Collection < IoSession >  loc0 = m_connections . values (  )  ;  Iterator < IoSession >  loc1 = loc0 . iterator (  )  ;  while  ( loc1 . hasNext (  )  )  { IoSession loc2 = loc1 . next (  )  ;  loc2 . closeNow (  )  ;  loc1 . remove (  )  ;  } }
public static JSONArray function ( List < JsonWorkflowJob >  arg0 )  { JSONArray loc0 = new JSONArray (  )  ;  for  ( JsonWorkflowJob loc1 : arg0 )  { loc0 . add ( loc1 . toJSONObject (  )  )  ;  } return loc0 ;  }
boolean function (  )  { MRNA loc0 = mrnaValue (  )  ;  return loc0 == MRNA . DOWNREGULATED ;  } Note: Please make sure to use this method in the appropriate context and with the correct values for the member variables . 
Verb function (  )  { return Verb . POST ;  }
boolean function ( DeleteLineageOptions arg0 ,  boolean arg1 )  { arg0 . mCascade = arg1 ;  return true ;  }
boolean function ( MRNA arg0 ,  RPPA arg1 )  { if  ( arg0 == null || arg1 == null )  { return false ;  } double loc0 = arg0 . getValue (  )  ;  double loc1 = arg1 . getValue (  )  ;  return loc0  >  loc1 ;  }
int function (  )  { WorkflowJobBean loc0 = getWorkflow (  )  ;  return loc0 . getRun (  )  ;  }
public void function ( List < ChildNumber >  arg0 ,  DeterministicKey arg1 )  { try { ImmutableList < ChildNumber >  path = getPath ( arg0 )  ;  ImmutableList < ChildNumber >  parentPath = getParent ( path )  ;  ChildNumber childNumber = getChildNumber ( path )  ;  if  ( childNumber == null )  { throw new IllegalArgumentException ( "Can't put key with null child number" )  ;  } Map < ImmutableList < ChildNumber >  ,  DeterministicKey >  loc0 = Maps . newHashMap ( keys )  ;  DeterministicKey parent = get ( parentPath ,  true ,  false )  ;  if  ( parent == null )  { throw new IllegalArgumentException ( "Can't find parent for key" )  ;  } parent . setCreationTimeSeconds ( BIP32_STANDARDISATION_TIME_SECS )  ;  loc0 . put ( path ,  arg1 )  ;  put ( path ,  arg1 )  ;  keys = loc0 ;  if  ( !lastChildNumbers . containsKey ( parentPath )  )  { lastChildNumbers . put ( parentPath ,  childNumber )  ;  } else { ChildNumber lastChildNumber = lastChildNumbers . get ( parentPath )  ;  if  ( childNumber . intValue (  )   >  lastChildNumber . intValue (  )  )  { lastChildNumbers . put ( parentPath ,  childNumber )  ;  } } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
public List < TestResultDTO >  function ( TestResultsDTO arg0 )  { List < TestResultDTO >  loc0 = null ;  try { loc0 = arg0 . getTestResultLst (  )  ;  } catch  ( Exception loc1 )  { System . err . println ( "Error occurred while getting the test result list: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
EncryptedKeyElement function (  )  { if  ( m_EncryptedKeyElement != null )  { return m_EncryptedKeyElement ;  } if  ( m_KeyInfoEl != null )  { NodeList nodes = m_KeyInfoEl . getElementsByTagNameNS ( "*" ,  "EncryptedKey" )  ;  if  ( nodes . getLength (  )   >  0 )  { Element encryptedKeyEl =  ( Element )  nodes . item ( 0 )  ;  m_EncryptedKeyElement = new EncryptedKeyElement ( encryptedKeyEl ,  null )  ;  return m_EncryptedKeyElement ;  } } return null ;  }
void function ( String arg0 )  { try { failedImages . add ( arg0 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Failed to add the image URL to the tracker . " )  ;  } }
void function ( boolean arg0 )  { isCurrentScenario = arg0 ;  }
void function ( File arg0 )  { Scanner loc0 = new Scanner ( arg0 )  ;  loc0 . useDelimiter ( "srini_string" )  ;  while  ( loc0 . hasNext (  )  )  { _ignoreWords . add ( loc0 . next (  )  )  ;  } loc0 . close (  )  ;  } Note: The code assumes that the "_ignoreWords" variable is a Set < String >  member variable of the "WordCounter" class . 
public void function ( String arg0 ,  String arg1 )  { try { setChecksum ( arg0 )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public Object function ( Result arg0 )  { try { return withExceptionHandling ( new Trans < Object >  (  )  )  { public Object transform (  )  { return transformation . transformTo ( arg0 )  ;  } } )  ;  } catch  ( Exception loc0 )  { return null ;  } }
public void function ( Node loc0 )  { graph . removeVertex ( loc0 )  ;  nodesByIds . remove ( loc0 . getId (  )  )  ;  Collection < Edge >  loc1 = graph . getIncidentEdges ( loc0 )  ;  graph . remove ( loc0 )  ;  for  ( Edge loc2 : loc1 )  { graph . remove ( loc2 )  ;  } } Note: It's important to mention that removing a node from the graph may affect the connectivity and consistency of the graph .  Therefore ,  this method should be used with caution and appropriate consideration of the impact it may have on the overall graph structure . 
void function ( RuleSet ruleSet )  { try { if  ( ruleSet . getLanguage (  )  == null )  { ruleSet . setLanguage ( Language . JAVA )  ;  } for  ( int loc0 = 0 ;  loc0  <  ruleSets . size (  )  ;  loc0 ++  )  { RuleSet existingRuleSet = ruleSets . get ( loc0 )  ;  if  ( existingRuleSet . getLanguage (  )  == ruleSet . getLanguage (  )  )  { ruleSets . remove ( existingRuleSet )  ;  break ;  } } ruleSets . add ( ruleSet )  ;  ruleChain . addAll ( ruleSet . getRules (  )  )  ;  } catch  ( Exception loc1 )  { } }
void function ( XmlCursor arg0 ,  ObjArray arg1 )  { String loc0 = arg0 . getName (  )  ;  String loc1 = arg0 . getNamespaceURI (  )  ;  String loc2 =  ( String )  uriToPrefix . get ( loc1 )  ;  int loc3 = loc2 . size (  )  ;  undeclared . add ( loc0 )  ;  arg1 . add ( new Namespace ( loc0 ,  loc1 )  )  ;  }
public GetOfferDetailsResponse . Return . DetailOfferData function (  )  { GetOfferDetailsResponse . Return . DetailOfferData loc0 = new GetOfferDetailsResponse . Return . DetailOfferData (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntryValueItem (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntry (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImage (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataOfferDisplay (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataMerchant (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataProductsProduct (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataProducts (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataRedemptionAddressesRedemptionAddress (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataRedemptionAddresses (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSeo (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeoCountry (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeoCity (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeoRegion (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataTargetGeos (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeoCountry (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeoCity (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeoRegion (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataSourceGeos (  )  ;  loc0 . createGetOfferDetailsResponseReturnDetailOfferDataFulfillmentPartner (  )  ;  loc0 . createGetOfferDetailsResponseReturn (  )  ;  return loc0 ;  }
Supplier < T >  function ( Function < ? super F , T >  arg0 ,  Supplier < F >  arg1 )  { Preconditions . checkNotNull ( arg0 )  ;  Preconditions . checkNotNull ( arg1 )  ;  ThreadSafeSupplier < T >  loc0 = new ThreadSafeSupplier <  >  ( delegate )  ;  return  (  )  - >  { synchronized  ( delegate )  { if  ( !initialized )  { value = arg0 . apply ( arg1 . get (  )  )  ;  initialized = true ;  } return value ;  } } ;  }
Matrix function ( CategoricalDistribution arg0 )  { double [  ]  loc0 = arg0 . getValues (  )  ;  Matrix loc1 = new Matrix ( loc0 . length ,  1 )  ;  for ( int i=0 ;  i < loc0 . length ;  i ++  )  { loc1 . set ( i ,  0 ,  loc0 [ i ]  )  ;  } return loc1 ;  }
List < Node >  function (  )  { List < Node >  loc0 = new ArrayList <  >  (  )  ;  try { if  ( evaluationResults != null && !evaluationResults . isEmpty (  )  )  { loc0 . addAll ( evaluationResults )  ;  } } catch  ( Exception loc1 )  { LOGGER . warning ( "Failed to retrieve evaluation results: " + loc1 . getMessage (  )  )  ;  } return loc0 ;  }
boolean function (  )  { return services != null ;  }
void function ( int requestedBytes )  { if  ( mBuffer . length - mWriter . position (  )   <  requestedBytes )  { int newCapacity = Math . max ( mBuffer . length * 2 ,  mWriter . position (  )  + requestedBytes )  ;  byte [  ]  newBuffer = new byte [ newCapacity ]  ;  System . arraycopy ( mBuffer ,  0 ,  newBuffer ,  0 ,  mWriter . position (  )  )  ;  mBuffer = newBuffer ;  mWriter = ByteBuffer . wrap ( mBuffer )  ;  mWriter . position ( mWriter . position (  )  + requestedBytes )  ;  } }
String function (  )  throws BadSyntaxException { if  ( !matchStringConstant (  )  )  { throw new BadSyntaxException (  )  ;  } String loc0 = tok . sval ;  nextToken (  )  ;  return loc0 ;  }
boolean function ( Integer arg0 )  { try { return graph . addNode ( arg0 )  ;  } catch  ( Exception e )  { } }
public List < String >  function (  )  { List < String >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 . addAll ( this . produceMediaTypes )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  }
Message function ( String arg0 )  { Object loc0 ;  try { loc0 = JSONValue . parseWithException ( arg0 )  ;  } catch  ( ParseException e )  { throw new ParserException ( "Error parsing JSON object: " + e . getMessage (  )  )  ;  } return parseJSONValueToMessage ( loc0 )  ;  }
DenseMatrix64F function ( int arg0 ,  int arg1 ,  double [  ]  arg2 )  { DenseMatrix64F matrix = new DenseMatrix64F ( arg0 ,  arg1 )  ;  int numRows = matrix . getNumRows (  )  ;  int numCols = matrix . getNumCols (  )  ;  int min = Math . min ( numRows ,  numCols )  ;  int loc0 = Math . min ( numRows-1 ,  numCols )  ;  double [  ]  diag = new double [ min ]  ;  double [  ]  off = new double [ min-1 ]  ;  DenseMatrix64F copy = new DenseMatrix64F ( matrix )  ;  return matrix ;  }
String function (  )  { String loc0 = "" ;  try { loc0 = label (  )  ;  } catch  ( Exception e )  { loc0 = "Error: " + e . getMessage (  )  ;  } return loc0 + function (  )  ;  }
public static String function ( MediaInfo arg0 ,  int arg1 )  { Uri loc0 = getImageUri ( arg0 ,  arg1 )  ;  return loc0 . toString (  )  ;  }
long function (  )  { try { return totalElapsed . get (  )  ;  } catch  ( Exception e )  { return 0L ;  // or throw a custom exception } }
static String function ( String arg0 )  throws IOException { BufferedReader loc0 = new BufferedReader ( new FileReader ( arg0 )  )  ;  String loc1 ;  while  (  ( loc1 = loc0 . readLine (  )  )  != null )  { loc1 = loc1 . trim (  )  ;  if  ( !loc1 . startsWith ( "#" )  )  { loc0 . close (  )  ;  return loc1 ;  } } loc0 . close (  )  ;  return null ;  }
 @ Test void function (  )  { final double loc0 = 95 . 56789 ;  vtg . setMagneticCourse ( loc0 )  ;  assertTrue ( vtg . toString (  )  . contains ( "srini_string" )  )  ;  assertEquals ( loc0 ,  vtg . getMagneticCourse (  )  ,  0 . 1 )  ;  }
void function ( MessageContext arg0 )  { try { mc = arg0 ;  voidFunction ( mc )  ;  } catch  ( Exception loc0 )  { } }
public int function ( TtlBucket arg0 )  { int loc0 = Objects . hashCode ( arg0 . sTtlIntervalMs )  ;  loc0 = 31 * loc0 + Objects . hashCode ( arg0 . mTtlIntervalStartTimeMs )  ;  loc0 = 31 * loc0 + Objects . hashCode ( arg0 . mFiles )  ;  return loc0 ;  }
double function ( int arg0 ,  int arg1 )  { try { return W . get ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { return 0 . 0 ;  } }
public List < RuleSet >  function (  )  { List < RuleSet >  loc0 = new ArrayList <  >  (  )  ;  try { loc0 = ruleSets . toArray ( new RuleSet [ 0 ]  )  ;  } catch  ( Exception loc1 )  { } return loc0 ;  }
public int function ( String arg0 )  { int loc0 = 0 ;  try { loc0 = Integer . parseInt ( params . get ( arg0 )  )  ;  } catch  ( NumberFormatException e )  { } return loc0 ;  }
boolean function ( Bits arg0 )  { try { int loc0 = arg0 . ordinal (  )  ;  int loc1 = SVALS [ loc0 ]  . ordinal (  )  ;  Bits loc2 = extractOwnerBits ( loc1 )  ;  Bits loc3 = extractGroupBits ( loc1 )  ;  Bits loc4 = extractOtherBits ( loc1 )  ;  Bits loc5 = arg0 . extractOwnerBits ( loc0 )  ;  Bits loc6 = arg0 . extractGroupBits ( loc0 )  ;  Bits loc7 = arg0 . extractOtherBits ( loc0 )  ;  return  (  ( loc2 . or ( loc5 )  . equals ( loc2 )  )  &&  ( loc3 . or ( loc6 )  . equals ( loc3 )  )  &&  ( loc4 . or ( loc7 )  . equals ( loc4 )  )  )  ;  } catch  ( NullPointerException | IndexOutOfBoundsException e )  { return false ;  } }
void function (  )  { try { } catch  ( Exception e )  { LOG . warn ( "Failed to perform additional operations before disconnecting the connection" ,  e )  ;  } }
void function ( String arg0 )  { isActive = arg0 ;  }
String function (  )  { String loc0 = arg0 . getString (  )  ;  int loc1 = loc0 . length (  )  ;  return loc0 ;  }
CascadedStyle function ( CSSName arg0 ,  IdentValue arg1 )  { List < PropertyDeclaration >  loc0 = Collections . singletonList ( new PropertyDeclaration ( arg0 ,  new PropertyValue ( arg1 )  )  )  ;  CascadedStyle loc1 = new CascadedStyle (  )  ;  loc1 . addProperties ( loc0 . iterator (  )  )  ;  return loc1 ;  }
String function (  )  { String loc0 = xmlParser . getTitle (  )  ;  String loc1 = getMessage (  )  ;  String loc2 = avoidNull ( loc1 )  ;  return loc0 + " - " + loc2 ;  }
int function ( Object arg0 ,  int arg1 )  { int loc0 = System . identityHashCode ( arg0 )  ;  int loc1 = loc0 & _mask ;  Object loc2 = _keys [ loc1 ]  ;  while  ( loc2 != null )  { if  ( loc2 == DELETED || loc2 == arg0 )  { break ;  } loc1 =  ( loc1 + 1 )  & _mask ;  loc2 = _keys [ loc1 ]  ;  } _keys [ loc1 ]  = arg0 ;  _values [ loc1 ]  = arg1 ;  if  ( loc2 != null )  { return _values [ loc1 ]  ;  } if  (  ++ _size  >  _mask * 3 / 4 )  { resize ( _mask  <  <  1 )  ;  } return NULL ;  }
public int function (  )  { int loc0 = placementHint ;  return loc0 ;  }
URI function ( QName arg0 )  { for  ( ServiceContractResolver loc0 : resolvers )  { URI loc1 = loc0 . resolveContractLocation ( arg0 )  ;  if  ( loc1 != null )  { return loc1 ;  } } return null ;  }
boolean function ( OthelloSide arg0 )  { return !hasMoves ( arg0 )  ;  }
public void function (  )  { String bundleName = "com . example . messages" ;  ResourceBundle bundle = ResourceBundle . getBundle ( bundleName )  ;  assertNotNull ( bundle )  ;  String key = "test . key" ;  String expectedValue = "test . value" ;  String actualValue = bundle . getString ( key )  ;  assertEquals ( expectedValue ,  actualValue )  ;  Properties props = new Properties (  )  ;  Enumeration < String >  keys = bundle . getKeys (  )  ;  while  ( keys . hasMoreElements (  )  )  { String k = keys . nextElement (  )  ;  String v = bundle . getString ( k )  ;  props . put ( k ,  v )  ;  } assertNotNull ( props )  ;  assertFalse ( props . isEmpty (  )  )  ;  String resourceName = "/com/example/messages . properties" ;  Properties resourceProps = new Properties (  )  ;  try  ( InputStream stream = getClass (  )  . getResourceAsStream ( resourceName )  )  { assertNotNull ( stream )  ;  resourceProps . load ( stream )  ;  } catch  ( IOException ex )  { fail ( "Failed to load resource bundle properties" )  ;  } assertTrue ( props . equals ( resourceProps )  )  ;  }
void function ( Runnable task )  { synchronized ( internalLock )  { queue . add ( task )  ;  startQueueWorker (  )  ;  } }
void function ( Date arg0 )  { try { setExpires ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
void function ( Message arg0 ,  ClassResourceInfo arg1 )  { boolean canHandle = canHandle ( arg0 ,  arg1 )  ;  if  ( canHandle && isAuthenticated ( arg0 ,  arg1 )  )  { arg0 . put ( "authenticated" ,  true )  ;  } else { arg0 . put ( "authenticated" ,  false )  ;  throw new RuntimeException ( "Unauthorized" )  ;  } setPriority ( DEFAULT_PRIORITY )  ;  }
int function ( int arg0 ,  int arg1 )  { long INT_MASK = 0xffffffffL ;  long loc0 = UnsignedInts . toLong ( arg0 )  & INT_MASK ;  long loc1 = UnsignedInts . toLong ( arg1 )  & INT_MASK ;  try { return  ( int )   ( loc0 / loc1 )  ;  } catch  ( ArithmeticException e )  { return  ( int )   ( loc0  > = 0 ? INT_MASK : 0 )  ;  } }
public static Type function ( Type type )  { Type loc0 = null ;  try { loc0 = TypeUtil . getSingleTypeParameter ( type )  ;  } catch  ( RuntimeException e )  { } return loc0 ;  }
import org . apache . cxf . aegis . AegisContext ;  import org . apache . cxf . aegis . type . AegisType ;  import java . lang . reflect . Type ;  import java . util . Collection ;  public class TypeUtil { private static final Logger LOG = LogUtils . getL7dLogger ( TypeUtil . class )  ;  public static Object function ( AegisContext arg0 ,  Collection < ? >  arg1 ,  Type arg2 )  { AegisType loc0 = getWriteTypeStandalone ( arg0 ,  arg1 ,  arg2 )  ;  Map < Type ,  AegisType >  loc1 = getTypeMapping ( arg0 )  ;  AegisType . Creator loc2 = getTypeCreator ( arg0 )  ;  AegisType loc3 = createType ( arg0 ,  arg2 )  ;  return loc0 ;  } private static AegisType getWriteTypeStandalone ( AegisContext context ,  Object value ,  AegisType type )  { return context . getTypeMapping (  )  . getWriteType ( value . getClass (  )  ,  type )  ;  } private static Map < Type ,  AegisType >  getTypeMapping ( AegisContext context )  { return context . getTypeMapping (  )  . getTypeMap (  )  ;  } private static AegisType . Creator getTypeCreator ( AegisContext context )  { return context . getTypeMapping (  )  . getCreator (  )  ;  } private static AegisType createType ( AegisContext context ,  Type type )  { return context . createType ( type )  ;  } private static Class < ? >  getTypeClass ( Type type ,  boolean throwForNonClass )  { return org . apache . cxf . common . classloader . ClassLoaderUtils . getTypeClass ( type )  ;  } private static void setAttributeAttributes ( QName name ,  AegisType type ,  XmlSchema root )  { XmlSchemaUtils . setAttribute ( name ,  type . getSchemaType (  )  ,  root )  ;  } private static Type getSingleTypeParameter ( Type type )  { return org . apache . cxf . common . util . ReflectionUtil . getSingleTypeParameter ( type )  ;  } private static Type getSingleTypeParameter ( Type type ,  int index )  { return org . apache . cxf . common . util . ReflectionUtil . getSingleTypeParameter ( type ,  index )  ;  } private static Class < ? >  getTypeRelatedClass ( Type type )  { return org . apache . cxf . common . util . ReflectionUtil . getTypeRelatedClass ( type )  ;  } }
String function (  )  { IdentifierGenerator loc0 = arg0 . getManager (  )  . getIdGenerator (  )  ;  long loc1 = loc0 . generateSequenceIdentifier (  )  ;  return Long . toString ( loc1 )  ;  }
public int function ( String arg0 )  { try { SortPlan sortPlan = new SortPlan ( arg0 ,  new RecordComparator (  )  ,  new Transaction (  )  ,  new Schema (  )  )  ;  Scan scan = sortPlan . open (  )  ;  int distinctValues = 0 ;  Constant prevVal = null ;  while  ( scan . next (  )  )  { Constant currentVal = scan . getVal ( "col" )  ;  if  ( prevVal == null || prevVal . compareTo ( currentVal )  != 0 )  { distinctValues ++  ;  } prevVal = currentVal ;  } return distinctValues ;  } catch  ( Exception e )  { } return -1 ;  }
private byte fingerprintFunction ( ByteBuffer arg0 )  { ByteBuffer loc0 = ByteBuffer . allocate ( arg0 . remaining (  )  )  ;  loc0 . put ( arg0 )  ;  loc0 . rewind (  )  ;  MessageDigest loc1 = MessageDigest . getInstance ( "MD5" )  ;  loc1 . update ( BufferUtils . newByteArrayFromByteBuffer ( loc0 )  )  ;  byte [  ]  loc2 = loc1 . digest (  )  ;  byte loc3 = loc2 [ 0 ]  ;  for  ( int i = 1 ;  i  <  loc2 . length ;  i ++  )  { loc3 ^= loc2 [ i ]  ;  } return  ( byte )   ( loc3 == 0 ? 1 : loc3 )  ;  }
void function (  )  { int loc0 = 10 ;  mLockManager . setMaxLocks ( loc0 )  ;  BlockLockManager loc1 = new BlockLockManager ( mFolder . getRoot (  )  ,  1 )  ;  loc1 . lockBlock ( TEST_SESSION_ID ,  TEST_BLOCK_ID )  ;  loc1 . unlockBlock ( TEST_SESSION_ID ,  TEST_BLOCK_ID )  ;  lockExpectingHang ( loc1 ,  TEST_BLOCK_ID )  ;  }
String function ( String arg0 ,  int arg1 ,  char arg2 )  { checkNotNull ( arg0 )  ;  int loc0 = arg0 . length (  )  ;  if  ( loc0  > = arg1 )  { return arg0 ;  } int loc1 = arg1 - loc0 ;  StringBuilder loc2 = new StringBuilder (  )  ;  for  ( int loc3 = 0 ;  loc3  <  loc1 ;  loc3 ++  )  { loc2 . append ( arg2 )  ;  } loc2 . append ( arg0 )  ;  return loc2 . toString (  )  ;  }
public void function ( Object arg0 ,  Object arg1 )  { try { Hardware instance = Hardware . getInstance (  ( Context )  arg0 )  ;  assertNotNull ( instance )  ;  assertTrue ( instance . hasPressureSensor (  )  )  ;  } catch  ( Exception e )  { fail ( "Exception occurred: " + e . getMessage (  )  )  ;  } }
int function ( int arg0 ,  int arg1 )  { try { int loc0 = matrixItemUtility [ arg0 ]  [ arg1 ]  ;  int loc1 = matrixItemRemainingUtility [ arg0 ]  [ arg1 ]  ;  return loc0 + loc1 ;  } catch  ( ArrayIndexOutOfBoundsException e )  { System . err . println ( "Invalid arguments: " + e . getMessage (  )  )  ;  return 0 ;  } }
void function (  )  { FolderInfoResult loc0 = new FolderInfoResult (  )  ;  loc0 . setErrorLevel ( 0 )  ;  }
String function ( String arg0 ,  String arg1 ,  int arg2 )  { try { String [  ]  headerParts = arg0 . split ( "\t" )  ;  String [  ]  dataLineParts = arg1 . split ( "\t" )  ;  String data = TabDelimitedFileUtil . getPartStringAllowEmpty ( arg2 ,  dataLineParts )  ;  if  ( data . isEmpty (  )  )  { return TabDelimitedFileUtil . NA_STRING ;  } else { return data ;  } } catch  ( Exception e )  { return TabDelimitedFileUtil . NA_STRING ;  } }
public Long function ( String arg0 )  { Long loc0 = null ;  try { loc0 = Long . valueOf ( arg0 )  ;  } catch  ( NumberFormatException loc1 )  { } expectedDataUnitId = loc0 ;  return loc0 ;  }
void function ( Object arg0 )  { try { if  ( arg0 == null )  { throw new internal_error ( "Helper function for null test .  Throws an internal_error exception if its parameter is null . " )  ;  } } catch  ( internal_error e )  { } }
void function ( Object arg0 ,  Object arg1 )  { WalletFiles . log . debug ( "Scheduling background save" )  ;  WalletFiles . savePending . set ( true )  ;  WalletFiles . executor . schedule (  (  )  - >  { WalletFiles . savePending . set ( false )  ;  WalletFiles . vListener . beforeAutoSave (  )  ;  try { File loc0 = File . createTempFile ( "wallet" ,  null ,  WalletFiles . file . getParentFile (  )  )  ;  WalletFiles . onBeforeAutoSave ( loc0 )  ;  WalletFiles . saver . call (  )  ;  loc0 . renameTo ( WalletFiles . file )  ;  WalletFiles . onAfterAutoSave ( WalletFiles . file )  ;  } catch  ( Exception loc1 )  { WalletFiles . log . error ( "Failed to auto-save wallet" ,  loc1 )  ;  } WalletFiles . vListener . afterAutoSave (  )  ;  } ,  WalletFiles . delay ,  WalletFiles . delayTimeUnit )  ;  }
void function ( int arg0 ,  int arg1 )  { TestBlockInnerRankUpdate obj = new TestBlockInnerRankUpdate (  )  ;  int loc0 = obj . N + 2 ;  int loc1 = obj . N - 1 ;  obj . checkSymmRankNMinus_U ( arg0 ,  arg1 )  ;  }
boolean function ( AbstractGoal arg0 ,  AbstractGoal arg1 )  { return this . job (  )  . conflictsWith ( arg0 . job (  )  )  ;  }
public String function (  )  { try { return this . workflowImplId ;  } catch  ( Exception loc0 )  { return null ;  } }
void function ( boolean arg0 )  { ignoreExceptions = arg0 ;  } The function sets the value of the "ignoreExceptions" boolean variable to the value of the input boolean argument "arg0" .  If "ignoreExceptions" is set to true ,  exceptions during applying a rule are logged as warnings and the processing is continued with the next rule .  If "ignoreExceptions" is set to false ,  the processing will be aborted with the exception .  This method is useful during unit tests to ensure that all exceptions are caught and not overlooked . 
String function ( String arg0 ,  String [  ]  arg1 )  { try { if  ( StringUtils . isEmpty ( arg0 )  )  { throw new IdentityValidationException ( "Input cannot be empty" )  ;  } if  ( !isValidOverWhiteListPatterns ( arg0 ,  arg1 )  )  { String whiteListPatternsStr = getPatternString ( arg1 )  ;  String errorMsg = String . format ( msgSection1 + msgSection2 + msgSection4 + msgSection3 ,  whiteListPatternsStr ,  blackListPatternsStr )  ;  throw new IdentityValidationException ( errorMsg )  ;  } return arg0 ;  } catch  ( IdentityValidationException e )  { } }
void function (  )  { double arg0 = 10 . 0 ;  MWVParser mwvParser = new MWVParser (  )  ;  mwvParser . parse ( EXAMPLE )  ;  assertEquals ( 0 . 0 ,  mwvParser . getSpeed (  )  ,  0 . 0 )  ;  mwvParser . setSpeed ( arg0 )  ;  double loc0 = mwvParser . getSpeed (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 0 )  ;  }
void function ( long arg0 )  { try { Thread . sleep ( arg0 )  ;  } catch  ( InterruptedException e )  { } }
void function (  )  { try { Position instance = new Position (  )  ;  double arg0 = 0 . 0 ;  instance . setLongitude ( arg0 )  ;  double loc0 = instance . getLongitude (  )  ;  assertEquals ( arg0 ,  loc0 ,  0 . 0 )  ;  double arg1 = 180 . 0 ;  instance . setLongitude ( arg1 )  ;  double loc1 = instance . getLongitude (  )  ;  assertEquals ( arg1 ,  loc1 ,  0 . 0 )  ;  char loc2 = instance . getLongitudeHemisphere (  )  ;  assertEquals ( 'E' ,  loc2 )  ;  } catch  ( Exception e )  { fail ( "An exception occurred: " + e . getMessage (  )  )  ;  } }
Iterable < T >  function ( Iterable < T >  arg0 ,  Predicate < ? super T >  arg1 )  { return new Iterable < T >  (  )  {  @ Override public Iterator < T >  iterator (  )  { return new FilteringIterator < T >  ( arg0 . iterator (  )  ,  arg1 )  ;  } } ;  }
List < CoordinatorActionBean >  function ( List < CoordinatorActionBean >  arg0 )  { List < CoordinatorActionBean >  loc0 = null ;  try { loc0 = actions ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function (  @ ModelAttribute Schedule arg0 )  { try { Schedule loc0 = repository . save ( arg0 )  ;  } catch  ( Exception e )  { } }
Future < Void >  function ( Runnable arg0 ,  long arg1 )  throws TimeoutException { Future < Void >  loc0 = WaitForAsyncUtils . asyncFx ( arg0 )  ;  WaitForAsyncUtils . waitForMillis ( arg1 ,  loc0 )  ;  return loc0 ;  }
void function ( Popup popup ,  Logger loc0 )  { popup . setLogger ( loc0 )  ;  }
void function (  )  { try { int arg0 = 30 ;  // replace with desired value time . setSeconds ( arg0 )  ;  int loc0 = time . getSeconds (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  } catch  ( Exception e )  { } }
ByteBuffer function ( int capacity )  { ByteBuffer loc0 = ByteBuffer . allocate ( capacity )  ;  loc0 . order ( ByteOrder . nativeOrder (  )  )  ;  for  ( int loc1 = 0 ;  loc1  <  capacity / 4 ;  loc1 ++  )  { loc0 . putInt ( loc1 * 4 ,  loc1 )  ;  } loc0 . flip (  )  ;  return loc0 ;  }
Sentence function ( String arg0 ,  String arg1 ,  Object arg2 )  { try { Class < ? extends SentenceParser >  loc0 = parsers . get ( arg1 )  ;  if  ( loc0 == null )  { throw new IllegalArgumentException ( "Parser not found for type: " + arg1 )  ;  } SentenceParser loc1 = loc0 . newInstance (  )  ;  loc1 . setTalker ( arg0 )  ;  loc1 . parse ( arg2 )  ;  return createParserImpl ( arg1 ,  loc1 )  ;  } catch  ( InstantiationException | IllegalAccessException e )  { throw new IllegalArgumentException ( "Failed to create parser for type: " + arg1 ,  e )  ;  } }
void function ( BigDecimal arg0 )  { feedId = arg0 ;  }
void function ( long arg0 ,  long arg1 ,  long arg2 )  { RPCBlockReadResponse resp = new RPCBlockReadResponse ( arg0 ,  arg1 ,  arg2 ,  null ,  STATUS )  ;  ByteBuf mBuffer = RPCBlockReadResponse . encode ( resp )  ;  RPCBlockReadResponse loc0 = RPCBlockReadResponse . decode ( mBuffer )  ;  assertValid ( arg0 ,  arg1 ,  arg2 ,  STATUS ,  loc0 )  ;  RPCBlockReadResponse loc1 = new RPCBlockReadResponse ( arg0 ,  arg1 ,  arg2 ,  null ,  STATUS )  ;  loc1 . decode ( mBuffer )  ;  assertValid ( arg0 ,  arg1 ,  arg2 ,  STATUS ,  loc1 )  ;  }
double function (  )  { double loc0 = 0 . 0 ;  try { BasePriceType loc1 = lineItem . getPrice (  )  ;  if  ( loc1 != null )  { loc0 = loc1 . getValue (  )  . doubleValue (  )  ;  java . util . Currency loc2 = loc1 . getValue (  )  . getCurrency (  )  ;  if  ( !loc2 . equals ( java . util . Currency . getInstance ( "USD" )  )  )  { throw new UnsupportedOperationException ( "Only USD currency is supported . " )  ;  } } else { loc0 = getTheItemPrice (  )  . getValue (  )  . doubleValue (  )  ;  } } catch  ( Exception e )  { } return loc0 ;  }
AtomicLongMap function (  )  { AtomicLongMap atomicLongMap = null ;  try { atomicLongMap = new AtomicLongMap (  )  ;  ConcurrentHashMap < K ,  Long >  map = new ConcurrentHashMap <  >  (  )  ;  atomicLongMap . asMap = map ;  atomicLongMap . map = map ;  } catch  ( Exception e )  { } return atomicLongMap ;  }
void function ( boolean arg0 )  { XRLog . loggingEnabled = arg0 ;  }
void function ( Object arg0 ,  Object arg1 ,  Object arg2 )  { Preconditions . checkNotNull ( arg0 )  ;  Preconditions . checkNotNull ( arg1 )  ;  Preconditions . checkNotNull ( arg2 )  ;  EvictionPlan plan =  ( EvictionPlan )  arg1 ;  BlockMetadataManager meta =  ( BlockMetadataManager )  arg2 ;  long bytesToBeAvailable =  ( long )  arg0 ;  boolean blocksInTheSameDir = blocksInTheSameDir ( plan ,  meta )  ;  boolean requestSpaceSatisfied = requestSpaceSatisfied ( bytesToBeAvailable ,  plan ,  meta )  ;  if  ( blocksInTheSameDir && requestSpaceSatisfied )  { assertEvictionPlanValid ( bytesToBeAvailable ,  plan ,  meta )  ;  } }
Here's the concise method named "function" that calls the mentioned functions with exception handling: ``` public GetOfferDetailsResponse . Return function (  )  { try { GetOfferDetailsResponse response = createGetOfferDetailsResponse (  )  ;  GetOfferDetailsResponse . Return detail = response . getReturn (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData data = createGetOfferDetailsResponseReturnDetailOfferData (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . Merchant merchant = createGetOfferDetailsResponseReturnDetailOfferDataMerchant (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . Merchant . Addresses addresses = createGetOfferDetailsResponseReturnDetailOfferDataMerchantAddresses (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . FulfillmentPartner partner = createGetOfferDetailsResponseReturnDetailOfferDataFulfillmentPartner (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferDisplay display = createGetOfferDetailsResponseReturnDetailOfferDataOfferDisplay (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia media = createGetOfferDetailsResponseReturnDetailOfferDataOfferMedia (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage image = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImage (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry entry = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntry (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value value = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntryValue (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . OfferMedia . OfferImage . Entry . Value . Item item = createGetOfferDetailsResponseReturnDetailOfferDataOfferMediaOfferImageEntryValueItem (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . Products products = createGetOfferDetailsResponseReturnDetailOfferDataProducts (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . Products . Product product = createGetOfferDetailsResponseReturnDetailOfferDataProductsProduct (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . RedemptionAddresses redemption = createGetOfferDetailsResponseReturnDetailOfferDataRedemptionAddresses (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . RedemptionAddresses . RedemptionAddress address = createGetOfferDetailsResponseReturnDetailOfferDataRedemptionAddressesRedemptionAddress (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . Seo seo = createGetOfferDetailsResponseReturnDetailOfferDataSeo (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . SourceGeos sourceGeos = createGetOfferDetailsResponseReturnDetailOfferDataSourceGeos (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . SourceGeos . Geo geo = createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeo (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . SourceGeos . Geo . Country country = createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeoCountry (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . SourceGeos . Geo . Region region = createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeoRegion (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . SourceGeos . Geo . City city = createGetOfferDetailsResponseReturnDetailOfferDataSourceGeosGeoCity (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . TargetGeos targetGeos = createGetOfferDetailsResponseReturnDetailOfferDataTargetGeos (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . TargetGeos . Geo targetGeo = createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeo (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . TargetGeos . Geo . Country countryTarget = createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeoCountry (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . TargetGeos . Geo . Region regionTarget = createGetOfferDetailsResponseReturnDetailOfferDataTargetGeosGeoRegion (  )  ;  GetOfferDetailsResponse . Return . DetailOfferData . TargetGeos
public static Element function ( InputStream arg0 )  { ParamChecker . notNull ( arg0 ,  "InputStream" )  ;  SAXBuilder loc0 = createSAXBuilder (  )  ;  Document loc1 = loc0 . build ( arg0 )  ;  Element loc2 = loc1 . getRootElement (  )  ;  XmlUtils . removeComments ( loc2 )  ;  return loc2 ;  } Note: This method takes an input stream as an argument ,  checks if it is not null using ParamChecker . notNull (  )  ,  creates a SAXBuilder instance using the XmlUtils . createSAXBuilder (  )  method ,  builds a Document object using the build (  )  method of SAXBuilder ,  retrieves the root element of the document using getRootElement (  )  ,  and removes comments from the root element using XmlUtils . removeComments (  )  .  It then returns the root element . 
JobLauncherController (  ) { try { synchJobLauncher = new SimpleJobLauncher (  )  ;  synchJobLauncher . setJobRepository ( jobRepository )  ;  synchJobLauncher . afterPropertiesSet (  )  ;  } catch  ( Exception e )  { logger . error ( "Failed to provide SimpleJobLauncher bean" ,  e )  ;  } }
public static void function ( Object [  ]  arg0 ,  String arg1 )  { try { Assert . notEmpty ( arg0 ,  arg1 )  ;  } catch  ( IllegalArgumentException e )  { System . err . println ( "The array is empty or null: " + e . getMessage (  )  )  ;  } }
boolean function (  )  { return useKeyIdentifier ;  }
import java . util . * ;  class ChildGenUML { Logger LOG = Logger . getLogger ( ChildGenUML . class )  ;  Enumeration function ( Object arg0 )  { IteratorEnumeration loc0 = new IteratorEnumeration ( gen2 ( arg0 )  )  ;  return loc0 ;  } Iterator gen2 ( Object arg0 )  { } }
boolean function (  )  { int loc0 = 0 ;  for  ( Integer value : invMap . values (  )  )  { loc0 += value ;  } return loc0  > = limit ;  }
public String function ( String arg0 )  { HostSpecifier loc0 = HostSpecifier . from ( arg0 )  ;  return loc0 . canonicalForm ;  }
Project function (  )  { Project loc0 = null ;  try { loc0 = makeEmptyProject ( true )  ;  } catch  ( Exception loc1 )  { LOG . error ( "Error creating empty project" ,  loc1 )  ;  } return loc0 ;  }
String function ( String arg0 ,  Table arg1 )  { String loc0 = arg1 . generateCreateTableScript ( arg0 )  ;  return loc0 . replaceAll ( "/\\* . *?\\*/" ,  "" )  ;  }
public String function ( String arg0 )  { String loc0 = "" ;  try { loc0 = _uriResolver . getBaseUri (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function (  )  { String loc0 = ThreadContext . peek (  )  ;  ThreadContext . pop (  )  ;  }
void function (  )  { function (  )  ;  Mode loc0 = new Mode (  )  ;  Mode loc1 = Mode . getDefault (  )  ;  Assert . assertEquals ( loc1 ,  loc0 )  ;  loc0 . setOwnerBits ( 4 )  ;  loc0 . setGroupBits ( 2 )  ;  loc0 . setOtherBits ( 1 )  ;  Assert . assertEquals ( 4 ,  loc0 . getOwnerBits (  )  )  ;  Assert . assertEquals ( 2 ,  loc0 . getGroupBits (  )  )  ;  Assert . assertEquals ( 1 ,  loc0 . getOtherBits (  )  )  ;  short loc2 = loc0 . toShort (  )  ;  Mode loc3 = new Mode ( loc0 )  ;  Assert . assertEquals ( loc2 ,  loc3 . toShort (  )  )  ;  }
public String function ( MyComplexStruct obj )  { String loc0 = obj . getElem1 (  )  ;  return loc0 ;  }
public void function ( Object arg0 ,  Object arg1 )  { try { TimeDescriptionImpl loc0 =  ( TimeDescriptionImpl )  arg0 ;  TimeDescriptionImpl loc1 =  ( TimeDescriptionImpl )  arg1 ;  loc0 . getRepeatTimes ( true )  . add ( loc1 . getTime (  )  )  ;  loc0 . equals ( loc1 )  ;  loc0 . hashCode (  )  ;  loc0 . toString (  )  ;  if  ( loc0 . getTime (  )  == null )  { throw new NullPointerException (  )  ;  } } catch  ( ClassCastException e )  { } catch  ( NullPointerException e )  { } }
private static ConfigurationFactory getFactory (  )  { try { return ConfigurationFactory . getInstance (  )  ;  } catch  ( ConfigurationException e )  { return null ;  } } private static Configuration getConfiguration (  )  { ConfigurationFactory factory = getFactory (  )  ;  return factory != null ? factory . getConfiguration (  )  : null ;  }
boolean function ( byte [  ]  arg0 ,  int arg1 ,  int arg2 )  { Utf8 . checkPositionIndexes ( arg1 ,  arg2 ,  arg0 . length )  ;  return Utf8 . isWellFormedSlowPath ( arg0 ,  arg1 ,  arg2 )  ;  }
void function ( CallbackHandler arg0 )  { callbackHandler = arg0 ;  }
String [  ]  [  ]  function (  )  { try { processMatrix (  )  ;  } catch  ( Exception e )  { System . out . println ( "Error while processing matrix: " + e . getMessage (  )  )  ;  } return matrix ;  }
public void function ( String arg0 )  { String loc0 ;  try { loc0 = createTemporaryDirectory (  )  . getAbsolutePath (  )  ;  } catch  ( IOException loc1 )  { throw new RuntimeException ( "Failed to create temporary directory" ,  loc1 )  ;  } mWorkDirectory = loc0 ;  }
boolean function ( HttpServletRequest arg0 )  { try { boolean loc0 = function ( arg0 )  ;  String loc1 = getEmailId ( arg0 )  ;  return loc0 &&  ( loc1 != null && !loc1 . isEmpty (  )  )  ;  } catch  ( Exception e )  { return false ;  } }
public static String function ( ByteBuffer arg0 )  { try { CharsetDecoder loc0 = DECODER . reset (  )  ;  CharBuffer loc1 = loc0 . decode ( arg0 )  ;  return loc1 . toString (  )  ;  } catch  ( CharacterCodingException e )  { LOG . error ( "Failed to decode ASCII string from buffer" ,  e )  ;  return null ;  } }
void function (  )  { for  ( SentenceListener loc0 : getSentenceListeners (  )  )  { try { loc0 . readingStopped (  )  ;  } catch  ( Exception ex )  { LOGGER . log ( Level . WARNING ,  LOG_MSG ,  ex )  ;  } } }
Object [  ]  function ( Class clazz ,  Object [  ]  args ,  String methodName ,  Object instance )  { Object [  ]  loc0 = new Object [ args . length ]  ;  System . arraycopy ( args ,  0 ,  loc0 ,  0 ,  args . length )  ;  Object loc1 = PrivilegedAccessor . invokeConstructor ( clazz ,  loc0 )  ;  PrivilegedAccessor . invokeMethod ( instance ,  methodName ,  null ,  loc0 )  ;  return loc0 ;  }
int function ( int arg0 )  { try { time . setHour ( arg0 )  ;  } catch  ( IllegalArgumentException e )  { fail ( "Exception caught: " + e . getMessage (  )  )  ;  } int loc0 = time . getHour (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  return loc0 ;  }
Pageable loc0 = PageRequest . of ( 0 ,  10 )  ;  log . debug ( "Getting all books with pageable: {}" ,  loc0 )  ;  bookRepository . findAll ( loc0 )  ; 
public static StoredBlock function ( int arg0 ,  int arg1 ,  BigInteger arg2 ,  Block arg3 ,  BlockStore arg4 )  { try { StoredBlock prev = arg4 . get ( arg3 . getPrevBlockHash (  )  )  ;  BigInteger loc0 = prev . getChainWork (  )  . add ( arg2 )  ;  int loc1 = prev . getHeight (  )  + 1 ;  StoredBlock loc2 = new StoredBlock ( arg3 ,  loc0 ,  loc1 )  ;  return loc2 ;  } catch  ( BlockStoreException e )  { throw new RuntimeException ( e )  ;  } }
Object function (  )  { Object loc0 = getContext (  )  ;  Object loc1 = getOperation ( "getClassifier" )  ;  Object loc2 = loc1 == null ? null : loc1 instanceof Method ?  ( Method )  loc1 : getMethod ( loc1 . toString (  )  )  ;  return loc2 == null ? null :  ( Object )  invokeMethod ( loc2 ,  getComponent (  )  ,  new Object [  ]  { loc0 } )  ;  }
Vector function ( boolean arg0 )  { Vector repeatTimes = new Vector (  )  ;  try { } catch  ( Exception e )  { } return repeatTimes ;  }
boolean function ( boolean arg0 ,  String arg1 )  { LineBuffer buffer = new LineBuffer (  )  ;  buffer . handleLine ( arg1 ,  System . lineSeparator (  )  )  ;  boolean loc0 = buffer . sawReturn ;  String loc1 = buffer . line . toString (  )  ;  return arg0 && loc0 && !loc1 . isEmpty (  )  ;  }
public static ScopeKind function ( String arg0 ,  String arg1 )  { try { ScopeKind sk = ScopeKind . forName ( arg0 )  ;  List < String >  loc0 = sk . refTypeName (  )  ;  if  ( loc0 . isEmpty (  )  || loc0 . size (  )   >  1 )  { throw new IllegalStateException ( "Invalid list size: " + loc0 . size (  )  )  ;  } String loc1 = loc0 . get ( 0 )  ;  if  ( !loc1 . equals ( arg1 )  )  { throw new IllegalStateException ( "Invalid type name: " + loc1 )  ;  } return sk ;  } catch  ( IllegalArgumentException e )  { throw new IllegalStateException ( "Invalid enumeration name: " + arg0 )  ;  } }
public void function ( ObjectType arg0 )  { try { setObjectType ( arg0 )  ;  } catch  ( Exception e )  { } }
void function ( Timestamp arg0 )  { try { this . fetcherStartTimestamp = arg0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting fetcher start timestamp: " + e . getMessage (  )  )  ;  } }
void function ( String arg0 )  { source = arg0 ;  } This method sets the source variable of the Interaction object to the value of the argument passed to the method . 
boolean function ( String arg0 ,  String arg1 )  { try { String loc0 = "file downloaded to destination" ;  String loc1 = "file downloaded" ;  if  ( loc0 . equalsIgnoreCase ( arg0 )  || loc1 . equalsIgnoreCase ( arg1 )  )  { return true ;  } else { return false ;  } } catch  ( Exception e )  { System . err . println ( "Exception caught: " + e . getMessage (  )  )  ;  return false ;  } }
SearchConditionBuilder function (  )  { try { SearchConditionBuilder loc0 = instance (  )  ;  loc0 . DEFAULT_LANGUAGE = "FIQL" ;  loc0 . FIQL = loc0 . DEFAULT_LANGUAGE ;  return loc0 ;  } catch  ( Exception loc1 )  { } }
File function (  )  { File loc0 = sourceCodeFile ;  return loc0 ;  }
void function ( Object arg0 )  { try { DataHandler loc0 =  ( DataHandler )  arg0 ;  this . attachinfo = loc0 ;  } catch  ( Exception e )  { } }
private static void function ( LocalAlluxioClusterResource loc0 ,  AlluxioURI loc1 ,  int loc2 )  { waitForPersist ( loc0 ,  loc1 ,  Constants . SECOND_MS )  ;  }
public void function (  )  { System . out . println (  )  ;  String loc0 = "" ;  FileHandler loc1 = new FileHandler (  )  ;  loc1 . readFromGameFile (  )  ;  String nodeName = loc1 . getNodeName (  )  ;  assertEquals ( "Test of readFromGameFile method ,  of class FileHandler . " ,  nodeName )  ;  }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 ,  String arg5 )  { String loc0 = String . format ( "MERGE GRAPH  < %s >  \nUSING REVISION  < %s >  \nFROM BRANCH  < %s >  \nINTO BRANCH  < %s >  \n%s" ,  arg0 ,  arg4 ,  arg5 ,  arg5 ,  arg1 )  ;  String loc1 = String . format ( "INSERT DATA {GRAPH  < %s >  {%s}}" ,  arg0 ,  arg1 )  ;  String loc2 = String . format ( "DELETE WHERE {GRAPH  < %s >  {%s}}" ,  arg0 ,  arg2 )  ;  String loc3 = String . format ( "INSERT DATA {GRAPH  < %s >  {%s}}" ,  arg0 ,  arg3 )  ;  String loc4 = String . format ( "COMMIT  < %s >   < %s >  '%s'  < %s > " ,  arg0 ,  arg5 ,  arg2 ,  arg1 )  ;  String loc5 = String . format ( "SELECT * FROM  < %s >  REVISION  < %s > " ,  arg0 ,  arg5 )  ;  return String . format ( "%s ;  %s ;  %s ;  %s ;  %s ;  %s" ,  loc0 ,  loc1 ,  loc2 ,  loc3 ,  loc4 ,  loc5 )  ;  }
WorkflowStore function ( WorkflowStore arg0 )  { try { if  ( arg0 . getTransactionIsolation (  )  == Connection . TRANSACTION_NONE )  { throw new RuntimeException ( "Transaction is not supported for workflow store . " )  ;  } WorkflowStoreService service = Services . get (  )  . get ( WorkflowStoreService . class )  ;  return service . getWorkflowStore ( arg0 )  ;  } catch  ( Exception loc0 )  { throw new RuntimeException ( "Exception occurred while getting workflow store instance . " ,  loc0 )  ;  } }
byte [  ]  function (  )  { try { return chainCode ;  } catch  ( Exception e )  { return null ;  } }
void function ( int arg0 )  { synchronized ( internalLock )  { suspensions += arg0 ;  while  ( suspensions  >  0 )  { try { isWorkerRunning = false ;  internalLock . wait (  )  ;  } catch  ( InterruptedException loc0 )  { log . log ( Level . SEVERE ,  "Unexpected interruption while waiting for queue worker" ,  loc0 )  ;  Thread . currentThread (  )  . interrupt (  )  ;  } } } }
Verb function (  )  { return Verb . POST ;  }
public static void function ( UnderFileSystem arg0 ,  String arg1 )  { UnderFileSystemMockFactory factory = UnderFileSystemMockFactoryRegistry . find ( arg0 . getUnderFSType (  )  )  ;  UnderFileSystemMock ufsMock = factory . create ( arg0 . getUri (  )  . toString (  )  ,  arg0 . getConf (  )  )  ;  String loc0 = ufsMock . resolveUri ( arg1 )  ;  ufsMock . mockUnderFileSystem ( loc0 )  ;  }
int function ( StoredBlock arg0 )  { int loc0 = arg0 . getHeight (  )  ;  int loc1 = loc0 - 1 ;  if  (  ( loc0 % getInterval (  )  )  == 0 )  { StoredBlock loc2 = arg0 ;  for  ( int loc3 = 0 ;  loc3  <  getInterval (  )  - 1 ;  loc3 ++  )  { if  ( loc2 == null )  { break ;  } loc2 = loc2 . getPrev ( this )  ;  } if  ( loc2 == null )  { return getTargetTimespan (  )  / getTargetSpacing (  )  ;  } long loc4 = arg0 . getHeader (  )  . getTimeSeconds (  )  - loc2 . getHeader (  )  . getTimeSeconds (  )  ;  if  ( loc4  <  getTargetTimespan (  )  / 4 )  { loc4 = getTargetTimespan (  )  / 4 ;  } if  ( loc4  >  getTargetTimespan (  )  * 4 )  { loc4 = getTargetTimespan (  )  * 4 ;  } BigInteger loc6 = loc2 . getChainWork (  )  . add ( BigInteger . valueOf ( loc4 * loc1 )  )  ;  BigInteger loc7 = BigInteger . valueOf ( getTargetTimespan (  )  )  . multiply ( loc6 )  ;  BigInteger loc8 = BigInteger . valueOf ( loc0 )  . multiply ( BigInteger . valueOf ( getTargetSpacing (  )  )  )  . add ( BigInteger . valueOf ( getTargetSpacing (  )  / 2 )  )  ;  return loc7 . divide ( loc8 )  . intValue (  )  ;  } else { return arg0 . getHeader (  )  . getDifficultyTargetAsInteger (  )  ;  } }
void function (  )  { try { vCloseRequested = true ;  socket . close (  )  ;  } catch  ( IOException loc0 )  { log . error ( "IOException occurred while closing socket: {}" ,  loc0 . getMessage (  )  )  ;  } catch  ( RuntimeException loc1 )  { log . error ( "RuntimeException occurred while closing socket: {}" ,  loc1 . getMessage (  )  )  ;  } finally { try { if  ( socket != null && !socket . isClosed (  )  )  { socket . close (  )  ;  } } catch  ( IOException loc2 )  { log . error ( "Failed to close socket in finally block: {}" ,  loc2 . getMessage (  )  )  ;  } } }
public int function ( byte [  ]  arg0 ,  int arg1 )  { HashFunction loc0 = Hashing . murmur3_32 ( Constants . SEED )  ;  int loc1 = loc0 . hashBytes ( arg0 )  . asInt (  )  % arg1 ;  return  ( loc1 != 0 )  ? loc1 : 1 ;  }
File function ( String arg0 ,  String arg1 )  { String loc0 = com . gitblit . utils . FileUtils . resolveParameter ( Constants . baseFolder$ ,  baseFolder ,  arg0 )  ;  return new File ( loc0 ,  arg1 )  ;  }
public double function ( BlockMatrix64F arg0 )  { decomp . setA ( arg0 )  ;  QR = decomp . getQR (  )  ;  double [  ]  diagR = SpecializedOps . qualityTriangular ( QR )  ;  double max = diagR [ 0 ]  ;  for  ( int i = 1 ;  i  <  diagR . length ;  i ++  )  { double val = diagR [ i ]  ;  if  ( val  >  max )  { max = val ;  } } return max / diagR [ 0 ]  ;  }
void function ( final int arg0 ,  final ByteBuffer arg1 ,  final MediaCodec . BufferInfo arg2 )  { if  ( mIsStarted && arg0  <  mEncoderCount )  { mMediaMuxer . writeSampleData ( arg0 ,  arg1 ,  arg2 )  ;  mStatredCount ++  ;  } }
public static FilenameFilter function ( Filter < File >  arg0 )  { return new FilenameFilter (  )  {  @ Override public boolean accept ( File arg1 ,  String arg2 )  { return arg0 . accept ( new File ( arg1 ,  arg2 )  )  ;  } public String toString (  )  { return arg0 . toString (  )  ;  } } ;  }
public static QualifiedName function ( String arg0 ,  NamespaceContext arg1 )  { String [  ]  loc0 = arg0 . split ( ":" ,  2 )  ;  if  ( loc0 . length == 2 )  { return new QualifiedName ( loc0 [ 1 ]  ,  arg1 . getNamespaceURI ( loc0 [ 0 ]  )  )  ;  } else { int loc1 = arg0 . indexOf ( '}' )  ;  return new QualifiedName ( arg0 . substring ( loc1 + 1 )  ,  arg0 . substring ( 1 ,  loc1 )  )  ;  } }
class AttributeToolkit { String constructPredicate ( Attribute attribute )  { } String function ( Attribute arg0 )  { String loc0 = constructPredicate ( arg0 )  ;  return loc0 ;  } }
int function ( String arg0 )  { int loc0 ;  if  ( lhsscan . hasField ( arg0 )  )  return lhsscan . getInt ( arg0 )  ;  else if  ( rhsscan != null && rhsscan . hasField ( arg0 )  )  return rhsscan . getInt ( arg0 )  ;  else throw new RuntimeException ( "field " + arg0 + " not found . " )  ;  }
String function (  )  { String loc0 = this . url ;  return loc0 ;  }
void function ( AuthenticationRequest authReq ,  String relyingParty )  { authReq . setRelyingParty ( relyingParty )  ;  }
public  < T >  T function ( String propertyName ,  Class < T >  returnType )  { Object propertyValue = jsObject . getProperty ( propertyName )  ;  return returnType . cast ( propertyValue )  ;  }
public String [  ]  function (  )  { return dnsSeeds ;  }
Map < String ,  String >  function ( String arg0 ,  String arg1 )  { Map < String ,  String >  map = new HashMap <  >  (  )  ;  map . put ( arg0 ,  arg1 )  ;  return map ;  }
List < Inode < ? >  >  function ( String arg0 ,  String arg1 ,  Mode . Bits arg2 ,  LockedInodePath arg3 )  { List < Inode < ? >  >  loc0 = arg3 . getInodeList (  )  ;  String loc1 = arg3 . getClientUser (  )  ;  List < String >  loc2 = getGroups ( loc1 )  ;  boolean loc3 = isPrivilegedUser ( loc1 ,  loc2 )  ;  checkInodeList ( loc1 ,  loc2 ,  arg2 ,  arg3 . getFullPathName (  )  ,  loc0 ,  !loc3 )  ;  return loc0 ;  }
void function (  )  { Time loc0 = new Time ( "srini_string" )  ;  assertEquals ( arg0 ,  loc0 . getHour (  )  )  ;  assertEquals ( arg1 ,  loc0 . getMinutes (  )  )  ;  assertEquals ( arg2 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  loc0 . setHour ( arg4 )  ;  loc0 . setMinutes ( arg5 )  ;  loc0 . setSeconds ( arg6 )  ;  assertEquals ( arg4 ,  loc0 . getHour (  )  )  ;  assertEquals ( arg5 ,  loc0 . getMinutes (  )  )  ;  assertEquals ( arg6 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  loc0 . setSeconds ( arg7 )  ;  assertEquals ( arg6 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  loc0 . setHour ( arg8 )  ;  assertEquals ( arg8 ,  loc0 . getHour (  )  )  ;  loc0 . setMinutes ( arg9 )  ;  assertEquals ( arg9 ,  loc0 . getMinutes (  )  )  ;  loc0 . setSeconds ( arg10 )  ;  assertEquals ( arg10 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  assertEquals ( loc0 ,  loc0 . toDate (  )  )  ;  assertEquals ( arg11 ,  loc0 . getMilliseconds (  )  )  ;  loc0 . setHour ( arg12 )  ;  assertEquals ( arg12 ,  loc0 . getHour (  )  )  ;  loc0 . setMinutes ( arg13 )  ;  assertEquals ( arg13 ,  loc0 . getMinutes (  )  )  ;  loc0 . setSeconds ( arg14 )  ;  assertEquals ( arg14 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  loc0 . setSeconds ( arg15 )  ;  assertEquals ( arg14 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  assertEquals ( arg16 ,  loc0 . parseTimeWithoutDecimals ( arg17 )  )  ;  assertEquals ( arg18 ,  loc0 . parseTimeWithDecimals ( arg19 )  )  ;  loc0 . setHour ( arg20 )  ;  assertEquals ( arg20 ,  loc0 . getHour (  )  )  ;  loc0 . setMinutes ( arg21 )  ;  assertEquals ( arg21 ,  loc0 . getMinutes (  )  )  ;  loc0 . setSeconds ( arg22 )  ;  assertEquals ( arg22 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  loc0 . setHour ( arg23 )  ;  assertEquals ( arg23 ,  loc0 . getHour (  )  )  ;  loc0 . setMinutes ( arg24 )  ;  assertEquals ( arg24 ,  loc0 . getMinutes (  )  )  ;  loc0 . setSeconds ( arg25 )  ;  assertEquals ( arg25 ,  loc0 . getSeconds (  )  ,  loc3 )  ;  assertEquals ( arg26 ,  loc0 . formatTimeNoDecimals (  )  )  ;  assertEquals ( arg27 ,  loc0 . formatTimeWithOneDecimal (  )  )  ;  assertEquals ( arg28 ,  loc0 . formatTimeWithDecimals ( arg29 )  )  ;  }
Socket function (  )  { Socket loc0 = m_socket ;  return loc0 ;  }
boolean function ( Language arg0 )  { for  ( RuleSet loc0 : ruleSets )  { if  ( loc0 . usesDFA ( arg0 )  )  { return true ;  } } return false ;  }
boolean function ( String arg0 ,  String arg1 )  { boolean loc0 = function ( arg0 ,  arg1 )  ;  boolean loc1 = STSUtils . TOKEN_TYPE_SCT_05_02 . equals ( arg1 )  ;  boolean loc2 = STSUtils . TOKEN_TYPE_SCT_05_12 . equals ( arg1 )  ;  return loc0 || loc1 || loc2 ;  }
public String function (  )  { String loc0 = "" ;  try { loc0 = this . getPropertyName (  )  ;  } catch  ( Exception e )  { System . err . println ( "Error: Failed to get the name of the message property from which the content type has been extracted . " )  ;  } return loc0 ;  }
int function ( int arg0 )  { try { return arg0 / 3 ;  } catch  ( ArithmeticException e )  { System . err . println ( "Division by zero!" )  ;  return 0 ;  } }
 < T >  T function ( long arg0 ,  Callable < T >  arg1 )  throws TimeoutException ,  InterruptedException ,  ExecutionException ,  TimeoutException { Future < T >  future = async ( arg1 )  ;  return waitForMillis ( arg0 ,  future )  ;  }
public DecisionTree function ( DataSet arg0 ,  String arg1 )  { List < String >  loc0 = arg0 . getNonTargetAttributes (  )  ;  ConstantDecisonTree loc1 = new ConstantDecisonTree ( arg0 . mostCommonTargetValue (  )  )  ;  DecisionTreeLearner loc2 = new DecisionTreeLearner (  )  ;  return loc2 . decisionTreeLearning ( arg0 ,  loc0 ,  loc1 )  ;  } This function takes a DataSet object and a String object as input arguments .  It calls the getNonTargetAttributes method on the DataSet object to retrieve a list of non-target attributes .  It then creates a ConstantDecisionTree object using the most common target value of the DataSet object .  Finally ,  it creates a DecisionTreeLearner object and calls the decisionTreeLearning method on it with the DataSet object ,  list of non-target attributes ,  and the ConstantDecisionTree object as arguments .  The function returns the resulting DecisionTree object . 
void function (  )  { try { function (  )  ;  m_selectorManager . addChannelInterestNow (  )  ;  m_socketChannel . register ( m_selectorManager . getSelector (  )  ,  SelectionKey . OP_WRITE )  ;  } catch  ( Exception e )  { LOG . error ( "Error in function: " + e . getMessage (  )  ,  e )  ;  } }
OutStreamOptions function ( long arg0 )  { mTtl = arg0 ;  return this ;  }
void function ( EntityClassifier < EntityViewInfo >  arg0 )  { arg0 . apply ( entityClassifier )  ;  entityTree . getBoundingBox (  )  ;  applyClassifierAndUpdateTree (  )  ;  fireMapDataEvent ( new MapEvent ( this ,  MapEvent . Type . MAP_MODIFIED )  )  ;  }
void function (  )  { final double loc0 = 1 . 2 ;  final HDGTest loc1 = new HDGTest (  )  ;  loc1 . setUp (  )  ;  loc1 . hdg . setVariation ( loc0 )  ;  assertEquals ( loc0 ,  loc1 . hdg . getVariation (  )  ,  0 . 0 )  ;  assertTrue ( loc1 . hdg . toString (  )  . contains ( Double . toString ( loc0 )  )  )  ;  }
void function ( TestResultDetailsDTO dto ,  Long dataUnitId )  { try { dto . setDataUnitId ( dataUnitId )  ;  } catch  ( Exception e )  { } }
public void function ( DefaultConditionsProvider loc0 ,  long loc1 ,  long loc2 )  { if  ( loc0 . isFailLifetimeExceedance (  )  && loc1  >  loc0 . getMaxLifetime (  )  )  { loc0 . setLifetime ( loc0 . getMaxLifetime (  )  )  ;  } else { loc0 . setLifetime ( loc1 )  ;  } }
void function (  )  { async = true ;  }
public class HashCodeBuilder { private final int iConstant ;  private int iTotal ;  public HashCodeBuilder ( int iConstant )  { this . iConstant = iConstant ;  iTotal = 0 ;  } public HashCodeBuilder function ( char arg0 )  { int loc0 = arg0 ;  iTotal =  ( iTotal * iConstant )  + loc0 ;  return this ;  } public int toHashCode (  )  { return iTotal ;  } } This is a revised implementation of the `HashCodeBuilder` class with a method named `function` that appends a hash code for a character argument to the accumulated hash code value .  The method returns the `this` reference of the `HashCodeBuilder` object to allow for method chaining . 
String function ( boolean arg0 ,  String arg1 )  { String dataSourceName = null ;  try { dataSourceName = getDataSourceName (  )  ;  } catch  ( Exception e )  { } return dataSourceName ;  }
void function ( IdentityMapper arg0 )  { setIdentityMapper ( arg0 )  ;  }
void function ( DenseMatrix64F arg0 )  { double [  ]  loc0 = new double [ diagSaved . length ]  ;  copyDiag ( diagSaved ,  loc0 )  ;  double [  ]  loc1 = new double [ offSaved . length ]  ;  copyOff ( offSaved ,  loc1 )  ;  setQ ( computeVectors )  ;  setFastEigenvalues ( true )  ;  if  ( !decomp . decompose ( arg0 )  )  return ;  if  ( !process (  )  )  return ;  double [  ]  loc2 = new double [ values . length ]  ;  copyEigenvalues ( loc2 )  ;  }
String function ( String arg0 ,  String arg1 )  { String loc0 = "srini_string" ;  if  ( arg0 != null && !arg0 . isEmpty (  )  )  { return arg0 ;  } else { return loc0 ;  } }
void function (  )  { long arg0 = TimeUnit . HOURS . toMillis ( 1 )  ;  String loc0 = WebUtils . convertMsToClockTime ( arg0 )  ;  Assert . assertEquals ( "01:00:00" ,  loc0 )  ;  }
void function ( int arg0 )  { try { this . bufferedImageType = arg0 ;  this . outputImage = createBufferedImage ( width ,  height )  ;  } catch  ( Exception e )  { } }
void function ( Object [  ]  arg0 )  { int loc0 = 0 ;  int loc1 = 4 ;  mypage . clear (  )  ;  setFirstRecordPosition ( loc0 )  ;  setLastRecordPosition ( loc1 )  ;  append ( arg0 )  ;  }
public List < String >  function (  )  { List < String >  loc0 = new ArrayList <  >  (  )  ;  Collection < UserModel >  loc1 = userService . getAllUsers (  )  ;  for  ( UserModel loc2 : loc1 )  { loc0 . add ( loc2 . getUsername (  )  )  ;  } return loc0 ;  }
double function ( DenseMatrix64F arg0 ,  EigenDecomposition < DenseMatrix64F >  arg1 )  { return DecompositionFactory . quality ( arg0 ,  arg1 )  ;  }
class SecurityUtils { boolean isAuthenticationEnabled (  )  { } boolean isAuthorizationEnabled (  )  { } void function (  )  { boolean loc0 = isAuthenticationEnabled (  )  ;  boolean loc1 = isAuthorizationEnabled (  )  ;  } }
void function ( boolean arg0 )  { XpathNodeTracker tracker = new XpathNodeTracker ( new XPathContext (  )  ,  false ,  false )  ;  tracker . trackNodeReferences = arg0 ;  tracker . nodeReferenceMap = new HashMap < Node ,  Integer >  (  )  ;  }
int function ( MatrixPosition arg0 )  { int loc0 = arg0 . row ;  int loc1 = arg0 . column ;  int loc2 = originalMatrix . matrixItemRemainingUtility [ loc0 ]  [ loc1 ]  ;  return loc2 ;  } This method takes a MatrixPosition object as input and returns an integer value .  It retrieves the remaining utility for the specified cell in the originalMatrix object using the row and column fields of the MatrixPosition object passed as an argument .  No exception handling is included in this implementation . 
double loc0 = 90 . 1 ;  hdt . setHeading ( loc0 )  ;  double loc1 = hdt . getHeading (  )  ;  assertEquals ( loc0 ,  loc1 ,  0 . 0 )  ; 
public Double function ( int arg0 ,  ReshapeMatrix64F arg1 ,  int arg2 ,  int arg3 ,  int arg4 ,  int arg5 ,  boolean arg6 ,  int arg7 ,  int arg8 )  { int loc0 = arg0 % arg4 ;  int loc1 = arg0 / arg4 ;  if  ( arg6 )  { loc0 += arg2 ;  loc1 += arg3 ;  } else { loc0 += arg3 ;  loc1 += arg2 ;  } int loc2 = loc0/arg5 ;  int loc3 = loc1/arg5 ;  loc0 = loc0%arg5 ;  loc1 = loc1%arg5 ;  return arg1 . get ( loc3*arg1 . getStride (  )  + loc2*arg5 + loc0*arg1 . getStride (  )  + loc1 + arg7*arg1 . getStride (  )  + arg8 )  ;  }
public String function (  )  { String loc0 = "" ;  switch  ( this )  { case CCK_GUARDED: loc0 = "cck_guarded" ;  break ;  case CCK_SEQUENTIAL: loc0 = "cck_sequential" ;  break ;  case CCK_CONCURRENT: loc0 = "cck_concurrent" ;  break ;  default: throw new IllegalStateException ( "Unknown enum value: " + this )  ;  } return loc0 ;  }
int function (  )  { return this . _column ;  }
void function ( Crypto signatureCrypto )  { this . signatureCrypto = signatureCrypto ;  }
void function (  )  { double arg0 = 45 . 0 ;  RMCTest test = new RMCTest (  )  ;  test . rmc . setCourse ( arg0 )  ;  assertEquals ( arg0 ,  test . rmc . getCourse (  )  ,  0 . 001 )  ;  assertTrue ( test . rmc . toString (  )  . contains ( "Course" )  )  ;  }
int function ( int arg0 )  { int loc0 = arg0 ;  return loc0 ;  }
public void function ( Date arg0 )  { GregorianCalendar cal = new GregorianCalendar (  )  ;  cal . setTime ( arg0 )  ;  int loc0 = cal . get ( Calendar . HOUR_OF_DAY )  ;  int loc1 = cal . get ( Calendar . MINUTE )  ;  double loc2 = cal . get ( Calendar . SECOND )  ;  this . setHour ( loc0 )  ;  this . setMinutes ( loc1 )  ;  this . setSeconds ( loc2 )  ;  }
void function ( Stack < Tag >  tags ,  SpannableStringBuilder builder )  { while ( !tags . empty (  )  )  { Tag tag = tags . pop (  )  ;  TagStyle style = tagStyles . get ( tag . name )  ;  int end = builder . length (  )  ;  int start = builder . getSpanStart ( tag )  ;  if  ( start  > = 0 && start  <  end )  { builder . setSpan ( style ,  start ,  end ,  Spannable . SPAN_EXCLUSIVE_EXCLUSIVE )  ;  } else { builder . append ( " [ /" + tag . name + " ] " )  ;  } } }
String [  ]  function (  )  { return new String [  ] {"GRAPH_SEARCH" ,  "BF_SEARCH" ,  "ID_SEARCH" ,  "TREE_SEARCH" ,  "RBF_SEARCH" ,  "ASTAR_SEARCH" ,  "UC_SEARCH" ,  "DF_SEARCH" ,  "GBF_SEARCH" ,  "HILL_SEARCH" ,  "srini_string"} ;  }
void function ( TripleObjectTypeEnum arg0 )  { this . objectType = arg0 ;  }
public static void function ( Object arg0 ,  long arg1 )  { String loc0 = String . valueOf ( arg0 )  ;  MoreObjects . addHolder (  )  . add ( "" ,  arg1 )  ;  }
Conduit function ( ClientConfiguration clientConfig )  { Conduit loc0 = clientConfig . getConduit (  )  ;  if  ( loc0 instanceof HTTPConduit )  { return loc0 ;  } return null ;  }
int function ( int arg0 ,  int arg1 )  { setInputMode (  )  ;  int loc0 = remaining (  )  ;  return loc0 ;  }
public String function (  )  { String loc0 = SecurityConfigParams . getInstance (  )  . getKeyAlias (  )  ;  if  ( loc0 == null || loc0 . isEmpty (  )  )  { loc0 = ServerConfigParams . getFirstProperty ( "keyAlias" )  ;  } return loc0 ;  }
float function ( double arg0 ,  double arg1 ,  double arg2 )  { float loc0 =  ( float )   (  ( arg0 + arg1 )  / 2 . 0 * arg2 )  ;  return loc0 ;  }
Map < String ,  String >  function ( IStoredSettings arg0 ,  String arg1 )  { Map < String ,  String >  map = new LinkedHashMap <  >  (  )  ;  List < String >  values = arg0 . getStrings ( arg1 )  ;  for  ( String loc0 : values )  { String [  ]  loc1 = loc0 . split ( "=" ,  2 )  ;  if  ( loc1 . length == 2 )  { map . put ( loc1 [ 0 ]  ,  loc1 [ 1 ]  )  ;  } } return map ;  }
public AbstractAction function (  )  { AbstractAction loc0 = null ;  ProjectActions theInstance = ProjectActions . getInstance (  )  ;  theInstance . setTarget ( null )  ;  theInstance . determineRemoveEnabled (  )  ;  theInstance . getRemoveFromDiagramAction (  )  . actionPerformed ( null )  ;  loc0 = theInstance . undoAction ;  return loc0 ;  } This method retrieves the action that can undo the last user interaction on the project .  It first obtains the instance of the ProjectActions class ,  sets the target to null ,  determines if the remove action is enabled ,  and performs the remove action .  Finally ,  it returns the undo action from the instance of the ProjectActions class . 
void function ( T arg0 )  { for  ( ProviderListener < T >  loc0 : listeners )  { loc0 . providerUpdate ( createProviderEvent (  )  )  ;  } } This method iterates over all the registered listeners and calls their "providerUpdate" method with a newly created provider event .  The method takes a single argument of type T ,  which is used to create the provider event . 
int function ( Collection < Object >  arg0 ,  Collection < Object >  arg1 )  { int count = 0 ;  for  ( Object loc0 : arg0 )  { if  ( !arg1 . contains ( loc0 )  )  { arg1 . add ( loc0 )  ;  count ++  ;  } } return count ;  }
void function ( O arg0 ,  int arg1 )  { DocumentElement < O >  loc0 = new DocumentElement <  >  (  )  ;  IntegerHolder loc1 = new IntegerHolder ( arg1 )  ;  data . put ( arg0 ,  loc0 )  ;  loc0 . setMultiplicity ( loc1 )  ;  count . inc (  )  ;  wordCountMultiSet += arg1 ;  }
void function ( FullyQualifiedClassType arg0 )  { handlerClass = arg0 ;  }
String function ( IndividualStructure loc0 )  { return loc0 . individualUri ;  }
import javax . swing . JOptionPane ;  public class Popup { String appName = "JaMuz" ;  Logger logger = null ;  void function ( String arg0 )  { JOptionPane . showMessageDialog ( null ,  arg0 )  ;  } void error ( String arg0 )  { } void error ( String arg0 ,  Exception arg1 )  { } void error ( Exception arg0 )  { } void error ( String methodName ,  String sql ,  Exception ex )  { } void setLogger ( Logger logger )  { } void popupError ( String str )  { } void warning ( String str )  { } }
int function (  )  { int loc0 = length (  )  ;  return loc0 ;  }
void function (  )  { byte loc0 = 0x00 ;  ExpectedException loc1 = ExpectedException . none (  )  ;  PlainSaslServer loc2 = new PlainSaslServer (  )  ;  Callback [  ]  loc3 = new MockCallbackHandler (  )  ;  }
public List < SequenceWithUtility >  function (  )  { List < SequenceWithUtility >  loc0 = new ArrayList <  >  (  )  ;  for  ( SequenceWithUtility seq : sequences )  { loc0 . add ( seq )  ;  } return loc0 ;  }
public Object function ( Object arg0 )  { try { int loc0 =  ( Integer ) arg0 ;  Object loc1 = values . get ( loc0 )  ;  if  ( loc1 == null )  { throw new IllegalStateException ( "Result value is null . " )  ;  } if  ( loc1 instanceof Boolean )  { return  ( Boolean ) loc1 ;  } else if  ( loc1 instanceof Integer )  { return  (  ( Integer ) loc1 )  . intValue (  )  ;  } else if  ( loc1 instanceof Object )  { return loc1 ;  } else { throw new IllegalStateException ( "Result value is not a boolean ,  integer ,  or object . " )  ;  } } catch  ( Exception e )  { Boolean loc2 = false ;  int loc3 = 0 ;  Object loc4 = null ;  if  ( loc2 )  { loc3 = loc3 + 1 ;  } else { loc4 = null ;  } return loc4 ;  } }
void function ( boolean arg0 )  { recyclerView . setOnTouchListener ( arg0 ? new DragDropTouchListener (  )  : null )  ;  }
public static CommandHandler function ( String arg0 )  { try { return CommandHandler . valueOf ( arg0 )  ;  } catch  ( IllegalArgumentException e )  { return null ;  } }
void function ( String arg0 )  { setRoleClassifierType ( arg0 )  ;  }
URL function ( String arg0 )  { URL loc0 = findResource ( arg0 )  ;  InputStream loc1 = loc0 . openStream (  )  ;  String loc2 = IOUtils . toString ( loc1 ,  StandardCharsets . UTF_8 )  ;  IOUtils . closeQuietly ( loc1 )  ;  return loc2 ;  }
void function ( FMLInitializationEvent arg0 ,  ServerProxy arg1 )  { arg1 . registerRenders (  )  ;  }
import java . math . BigInteger ;  import java . util . List ;  public class AttackerUtility { byte [  ]  correctSize ( final byte [  ]  array ,  final int blockSize ,  final boolean removeSignByte )  { } int findLCM ( final int a ,  final int b )  { } BigInteger findLCM ( final BigInteger ba ,  final BigInteger bb )  { } BigInteger findLCM ( final List < BigInteger >  numbers )  { } static BigInteger function ( BigInteger arg0 ,  BigInteger arg1 )  { BigInteger loc0 = arg0 . abs (  )  ;  BigInteger loc1 = arg1 . abs (  )  ;  while  ( loc1 . compareTo ( BigInteger . ZERO )  != 0 )  { BigInteger loc2 = loc0 . mod ( loc1 )  ;  loc0 = loc1 ;  loc1 = loc2 ;  } return loc0 ;  } }
public Integer function ( List < T >  arg0 ,  Integer arg1 )  { if  ( arg0 != null && arg0 . size (  )   >  0 )  { return arg1 - arg0 . size (  )  ;  } return arg1 ;  }
void function ( String arg0 )  { feedId = arg0 ;  }
public short function ( short arg0 ,  String arg1 ,  RGBColor arg2 ,  float arg3 ,  Rect arg4 ,  Counter arg5 )  { return CSSValue . CSS_PRIMITIVE_VALUE ;  } Note: This method simply returns the constant value CSSValue . CSS_PRIMITIVE_VALUE without performing any exception handling or using any of the member variables or member functions defined in the FSCssValue class .  The argument names and local variable names have been modified for clarity and consistency with the requested changes . 
MatrixPosition function ( int row ,  int column )  { int value = originalMatrix . get ( row ,  column )  ;  int remainingUtility = getRemainingUtility ( row ,  column )  ;  int [  ]  itemNames = getItemNames (  )  ;  List < Integer >  items = new ArrayList <  >  (  )  ;  for  ( int i = 0 ;  i  <  itemNames . length ;  i ++  )  { if  ( originalMatrix . get ( row ,  i )  == 1 )  { items . add ( itemNames [ i ]  )  ;  } } int localSequenceUtility = getLocalSequenceUtility ( new MatrixPosition ( row ,  column ,  items )  )  ;  return new MatrixPosition ( value ,  remainingUtility ,  localSequenceUtility )  ;  }
public void function ( String arg0 )  { String [  ]  parts = arg0 . split ( ":" )  ;  String role = parts . length == 1 ? parts [ 0 ]  : parts [ 1 ]  ;  AccessPermission permission = permissionFromRole ( role )  ;  String repositoryName = repositoryFromRole ( role )  ;  repositoryName = repositoryName . toLowerCase (  )  ;  if  ( repositoryName . endsWith ( " . git" )  )  { repositoryName = repositoryName . substring ( 0 ,  repositoryName . length (  )  - 4 )  ;  } if  ( parts . length == 1 || parts [ 0 ]  . equals ( "RW+" )  )  { put ( permissions ,  repositoryName ,  permission )  ;  } else if  ( parts [ 0 ]  . equals ( "R" )  )  { add ( permissions ,  repositoryName ,  permission )  ;  } else if  ( parts [ 0 ]  . equals ( "RW" )  )  { put ( permissions ,  repositoryName ,  AccessPermission . WRITE )  ;  add ( permissions ,  repositoryName ,  AccessPermission . READ )  ;  } }
import java . util . * ;  public class CollectionUtil { public static  < T >  List < T >  function ( List < T >  arg0 ,  T arg1 )  { arg0 . add ( arg1 )  ;  return arg0 ;  } }
boolean function ( StoredBlock arg0 ,  StoredBlock arg1 )  { int result = arg0 . getChainWork (  )  . compareTo ( arg1 . getChainWork (  )  )  ;  return result  >  0 ;  }
public String function (  )  { String loc0 = this . placeId ;  return loc0 ;  }
public void function ( boolean arg0 )  { boolean loc0 = arg0 ;  if  ( loc0 )  { setTypedTime ( true )  ;  setEncoding ( "UTF-8" )  ;  } else { setTypedTime ( false )  ;  setEncoding ( null )  ;  } } This method takes a boolean argument "arg0" and sets the encoding and typed time based on its value .  If "arg0" is true ,  it sets the encoding to "UTF-8" and typed time to true .  If "arg0" is false ,  it sets the encoding to null and typed time to false . 
public static ByteBuffer function ( String arg0 )  { try { byte [  ]  loc0 = arg0 . getBytes ( "US-ASCII" )  ;  ByteBuffer loc1 = ByteBuffer . wrap ( loc0 )  ;  return loc1 ;  } catch  ( UnsupportedEncodingException loc2 )  { ByteBuffer loc3 = ByteBuffer . allocate ( 0 )  ;  LOG . error ( "Failed to convert string to ByteBuffer" ,  loc2 )  ;  return loc3 ;  } }
DataServerMessage function ( long arg0 ,  long arg1 )  { DataServerMessage loc0 = DataServerMessage . createBlockRequestMessage ( arg0 ,  0 ,  arg1 )  ;  mBlockWorkerClient . request ( loc0 )  ;  return loc0 ;  }
boolean function (  )  { Date loc0 = new Date (  )  ;  return loc0 . after ( arg0 . getExpires (  )  )  ;  }
void function ( String arg0 )  { builder (  )  . setUnsafeReplacement ( arg0 )  . build (  )  ;  }
boolean function ( final Callable < Boolean >  arg0 )  { boolean loc0 ;  try { loc0 = arg0 . call (  )  ;  } catch  ( Exception loc1 )  { LOG . error ( "srini_string" + arg0 ,  loc1 )  ;  loc0 = false ;  } CliUtils . printPassInfo ( loc0 )  ;  return loc0 ;  }
void function ( String fileName ,  int flag )  { PageFormatter formatter = new BTPageFormatter (  )  ;  Buffer buf = new Buffer (  )  ;  buf . assignToNew ( fileName ,  formatter )  ;  Block blk = buf . getLastBlock (  )  ;  BTreePage page = new BTreePage ( blk ,  flag )  ;  }
boolean function ( int arg0 ,  int arg1 )  { for  ( int loc0 = 0 ;  loc0  <  arg0 ;  loc0 ++  )  { if  ( loc0 ++   <  arg1 )  { return false ;  } } return true ;  }
void function ( Object arg0 ,  Object arg1 )  { RpcConnection loc0 =  ( RpcConnection )  arg0 ;  MainFrame loc1 =  ( MainFrame )  arg1 ;  loc0 . finalize (  )  ;  loc0 . close (  )  ;  System . out . println ( "Destructor cleans up . " )  ;  }
void function ( Class arg0 ,  Connection arg1 )  { closeAll ( arg0 ,  arg1 ,  null )  ;  closeConnection ( arg1 ,  JdbcUtil . getName (  )  )  ;  logMessage ( "Frees Database Connection . " )  ;  }
public List < String >  function (  )  { return roles ;  }
public Permission function ( Permission arg0 )  { Mode loc0 = arg0 . getMode (  )  . applyUMask ( Permission . FILE_UMASK )  ;  return new Permission ( loc0 ,  arg0 . getOwner (  )  ,  arg0 . getGroup (  )  )  ;  }
void function (  )  { fin . setInputs (  )  ;  futa . setAction ( player ,  mob )  ;  futa . nextStep (  )  ;  }
int function (  )  { int loc0 = elements . size (  )  ;  int loc1 = 0 ;  for  ( Element element : elements )  { loc1 += element . getFrequency (  )  ;  } return loc0 == 0 ? 0 :  ( int )  ( sumRutils / loc0 )  +  ( int )  ( sumIutils / loc1 )  ;  }
void function (  )  { GeneralMotorCon loc0 = GeneralMotorCon . getInstance (  )  ;  loc0 . appendToConsole ( "Right Move the drone a little to the right" )  ;  loc0 . spinRight (  )  ;  loc0 . forward ( 1000 )  ;  loc0 . hover (  )  ;  } Note: I have assumed that the "goRight (  ) " function mentioned in the question refers to the "spinRight (  ) " function in the code provided . 
ELEvaluator function (  )  { return ELEvaluator . current . get (  )  ;  }
boolean function ( File arg0 ,  boolean arg1 )  { File loc0 = arg0 ;  boolean loc1 = arg1 ;  if ( !loc0 . exists (  )  ) { loc0 . mkdir (  )  ;  loc1 = true ;  } return loc1 ;  } Note: This function takes in a File object and a boolean value ,  checks if the file exists ,  creates a new directory if it does not exist ,  and returns a boolean indicating whether the file manager had to create a new database directory . 
public static  < T >  Function < T ,  T >  function ( T value )  { try { return Functions . constantFunction ( value )  ;  } catch  ( Exception e )  { throw new RuntimeException ( e )  ;  } }
public String function ( TokenReference tokenRef )  { String loc0 = tokenRef . getWsse11TokenType (  )  ;  return loc0 ;  } This function takes in a "TokenReference" object named "tokenRef" and returns the value of its "wsse11TokenType" member variable as a String . 
void function ( String arg0 )  { resultCode = arg0 ;  }
void function ( String type ,  String arg0 ,  char [  ]  arg1 ,  String arg2 ,  int arg3 ,  boolean arg4 )  { RpcConnection rpcConn = new RpcConnection (  )  ;  rpcConn . setup ( arg0 ,  arg1 ,  arg2 ,  arg3 ,  arg4 )  ;  }
void function (  )  { BlacklistedSite site1 = new BlacklistedSite ( uri1 )  ;  BlacklistedSite site2 = new BlacklistedSite ( uri2 )  ;  Set < BlacklistedSite >  blackListedSitesSet = new HashSet <  >  ( Arrays . asList ( site1 ,  site2 )  )  ;  Mockito . when ( mockRepository . getAll (  )  )  . thenReturn ( blackListedSitesSet )  ;  boolean loc0 = service . isBlacklisted ( uri1 )  ;  boolean loc1 = service . isBlacklisted ( uri2 )  ;  boolean loc2 = service . isBlacklisted ( uri3 )  ;  assertTrue ( loc0 )  ;  assertTrue ( loc1 )  ;  assertFalse ( loc2 )  ;  Mockito . verify ( mockRepository ,  times ( 3 )  )  . getAll (  )  ;  }
static int function ( String arg0 ,  int arg1 )  { Objects . requireNonNull ( arg0 )  ;  long loc0 = Long . parseLong ( arg0 ,  arg1 )  ;  if  (  ( loc0 & INT_MASK )  != loc0 )  { throw new NumberFormatException ( "Input string '" + arg0 + "' is not a valid unsigned integer in base " + arg1 )  ;  } return  ( int )  loc0 ;  }
AuthenticationHolderEntity function (  )  { String loc0 = AuthorizationCodeEntity . QUERY_BY_VALUE ;  String loc1 = getCode (  )  ;  String loc2 = AuthorizationCodeEntity . QUERY_EXPIRATION_BY_DATE ;  Date loc3 = getExpiration (  )  ;  String loc4 = AuthorizationCodeEntity . PARAM_DATE ;  Long loc5 = getId (  )  ;  String loc6 = "SELECT OBJECT ( ac . authenticationHolder )  FROM AuthorizationCodeEntity ac WHERE ac . code = :code AND ac . expiration = :date AND ac . id = :id" ;  TypedQuery < AuthenticationHolderEntity >  query = entityManager . createQuery ( loc6 ,  AuthenticationHolderEntity . class )  ;  query . setParameter ( "code" ,  loc1 )  ;  query . setParameter ( loc4 ,  loc3 )  ;  query . setParameter ( "id" ,  loc5 )  ;  return query . getSingleResult (  )  ;  }
void function (  )  { try { RTEParser parser = new RTEParser (  )  ;  int arg0 = 5 ;  parser . setSentenceCount ( arg0 )  ;  int loc0 = parser . getSentenceCount (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  } catch  ( Exception e )  { fail ( "Exception: " + e . getMessage (  )  )  ;  } }
Script function ( List < TransactionSignature >  arg0 ,  List < ECKey >  arg1 ,  byte [  ]  arg2 ,  Script arg3 )  { checkArgument ( arg0 != null && !arg0 . isEmpty (  )  ,  "TransactionSignature list must be non-empty" )  ;  checkArgument ( arg1 != null && !arg1 . isEmpty (  )  ,  "ECKey list must be non-empty" )  ;  int loc0 = arg0 . size (  )  ;  ScriptBuilder loc1 = new ScriptBuilder (  )  . smallNum ( loc0 )  ;  for  ( TransactionSignature signature : arg0 )  { loc1 . data ( signature . encodeToBitcoin (  )  )  ;  } int loc2 = arg1 . size (  )  ;  loc1 . smallNum ( loc2 )  ;  for  ( ECKey key : arg1 )  { loc1 . data ( key . getPubKey (  )  )  ;  } loc1 . smallNum ( loc0 )  . op ( OP_CHECKMULTISIG )  ;  if  ( arg3 != null )  { loc1 . data ( arg3 . getProgram (  )  )  ;  } if  ( arg2 != null )  { return ScriptBuilder . createP2SHOutputScript ( loc1 . build (  )  . getSHA256Hash (  )  )  ;  } else { return loc1 . build (  )  ;  } }
public static boolean function ( String arg0 ,  SecurityOption arg1 )  { SecurityOption loc0 = getEnum ( arg0 ,  SecurityOption . class )  ;  return loc0 . equals ( arg1 )  ;  }
void function ( String arg0 )  { referencedRevisionLabelB = arg0 ;  }
double [  ]  function ( double [  ]  arg0 )  { try { int length = arg0 . length ;  double [  ]  result = new double [ length ]  ;  for  ( int i = 0 ;  i  <  length ;  i ++  )  { double loc0 = arg0 [ i ]  ;  double loc1 = Math . abs ( loc0 )  ;  result [ i ]  = loc1 ;  } return result ;  } catch  ( Exception e )  { } }
void function ( Escapers . Builder arg0 ,  char arg1 ,  char arg2 ,   @ Nullable String arg3 )  { arg0 . setSafeRange ( arg1 ,  arg2 )  . setUnsafeReplacement ( arg3 )  ;  }
void function ( Object arg0 )  { listeners . add (  ( LineListener )  arg0 )  ;  } This method takes an object as an argument and adds it to the list of listeners without any exception handling .  The method is concise and follows the naming conventions and requirements specified in the prompt . 
long function (  )  { Date loc0 = stopTime ;  Date loc1 = startTime ;  long loc2 = loc0 . getTime (  )  - loc1 . getTime (  )  ;  return loc2 ;  }
void function ( Graphics2D arg0 )  { try { Map < ? ,  ? >  loc0 = getRenderingHints (  )  ;  if  ( loc0 != null )  { arg0 . setRenderingHints ( loc0 )  ;  } } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
String function (  )  { String loc0 = classnamePrefix ;  int loc1 = loc0 . lastIndexOf ( " . " )  ;  if  ( loc1  >  0 )  { loc0 = loc0 . substring ( 0 ,  loc1 + 1 )  ;  } else { loc0 = "" ;  } return loc0 ;  }
void function ( File file ,  MapBuilder consumer )  { InputStream loc0 = null ;  try { OsmReader reader = new OsmReader (  )  ;  loc0 = reader . createFileStream ( file )  ;  reader . parseMap ( loc0 ,  consumer )  ;  } catch  ( Exception loc1 )  { OsmReader . LOG . error ( "Failed to read OSM file" ,  loc1 )  ;  } finally { if  ( loc0 != null )  { try { loc0 . close (  )  ;  } catch  ( IOException loc2 )  { OsmReader . LOG . error ( "Failed to close input stream" ,  loc2 )  ;  } } } }
public byte [  ]  function ( Object arg0 )  { int loc0 = 0 ;  try { if  ( arg0 instanceof Integer )  { loc0 =  ( Integer )  arg0 ;  Object loc1 = values . get ( loc0 )  ;  if  ( loc1 instanceof byte [  ]  )  { return  ( byte [  ]  )  loc1 ;  } else { throw new IllegalStateException ( "Value is not binary data . " )  ;  } } else { throw new IllegalArgumentException ( "Argument is not an integer index . " )  ;  } } catch  ( IndexOutOfBoundsException e )  { throw new IllegalArgumentException ( "Index out of bounds . " )  ;  } }
void function ( long arg0 ,  long arg1 )  { Thread loc0 = new Thread (  (  )  - >  { mLockManager . lockBlock ( arg0 ,  arg1 ,  BlockLockType . WRITE )  ;  } )  ;  loc0 . start (  )  ;  try { loc0 . join (  )  ;  } catch  ( InterruptedException loc1 )  { Thread . currentThread (  )  . interrupt (  )  ;  } Assert . assertTrue ( mLockManager . isBlockLocked ( arg0 )  )  ;  }
void function ( Type o )  { Iterator < Type >  loc0 = v . iterator (  )  ;  while  ( loc0 . hasNext (  )  )  { Type loc1 = loc0 . next (  )  ;  if  ( ts . isSubtype ( loc1 ,  o )  )  { loc0 . remove (  )  ;  } } }
AttributedURIType function ( EndpointReferenceType arg0 )  { if  ( arg0 == null )  { return null ;  } AddressingProperties loc0 =  ( AddressingProperties )  arg0 . getReferenceProperties (  )  . get ( AddressingConstants . WSAM_ACTION_QNAME )  ;  if  ( loc0 != null && loc0 . getFaultTo (  )  != null )  { return loc0 . getFaultTo (  )  . getAddress (  )  ;  } return null ;  }
Remember you have a Java class named "EaseEmojicon" ,  member variables "Type type ,  String iconPath ,  String identityCode ,  String bigIconPath ,  int bigIcon ,  String emojiText ,  int icon ,  String name" ,  member functions "String getEmojiText  (   )  ,  void setIcon  (  int icon  )  ,  void setBigIcon  (  int dynamicIcon  )  ,  void setIdentityCode  (  String identityCode  )  ,  String newEmojiText  (  int codePoint  )  ,  String getIconPath  (   )  ,  void setType  (  Type type  )  ,  String getBigIconPath  (   )  ,  Type getType  (   )  ,  String getIdentityCode  (   )  ,  void setIconPath  (  String iconPath  )  ,  String getName  (   )  ,  int getBigIcon  (   )  ,  int getIcon  (   )  ,  void setBigIconPath  (  String bigIconPath  )  ,  void setEmojiText  (  String emojiText  ) " .  Write a concise method named function that calls void function ( String arg0 )  - A method that takes a String argument and assigns it to a class member variable called "name" using the "this" keyword .  without exception handling to "set name of emoji icon" remove comments ;  remove summary ;  remove throws ;  remove function modifiers ;  change method name to "function" ;  change argument names to "arg0" ,  "arg1" .  .  .  ;  change local variable names to "loc0" ,  "loc1" .  .  . 
public void function ( long arg0 )  { try { Util . getCurrentTime (  )  ;  } catch  ( Exception e )  { } }
public void function ( String arg0 ,  String arg1 )  { roleClassifier = arg0 ;  if  ( arg1 != null )  { roleClassifierType = arg1 ;  } else { Set < Principal >  roles = null ;  try { roles = DefaultSecurityContext . getSubjectRoles (  )  ;  } catch  ( Exception ex )  { } if  ( roles != null )  { parseRolesFromSubject ( null ,  new Subject ( true ,  roles ,  Collections . emptySet (  )  ,  Collections . emptySet (  )  )  )  ;  } else { parseRolesFromSubject ( null ,  new Subject (  )  )  ;  } } }
void function (  )  { TestBufferedBlockOutStream locTestStream = mTestStream ;  byte [  ]  locIncreasingBytes = Arrays . copyOfRange ( INCREASING_BYTES ,  0 ,   ( int )  BLOCK_LENGTH )  ;  locTestStream . before ( locIncreasingBytes . length )  ;  for  ( int locI = 0 ;  locI  <  locIncreasingBytes . length ;  locI ++  )  { locTestStream . write ( locIncreasingBytes [ locI ]  )  ;  } locTestStream . flush (  )  ;  locTestStream . flush (  )  ;  byte [  ]  locWrittenBytes = locTestStream . getWrittenBytes (  )  ;  assertEquals ( locIncreasingBytes . length ,  locWrittenBytes . length )  ;  assertArrayEquals ( locIncreasingBytes ,  Arrays . copyOfRange ( locWrittenBytes ,  0 ,  locIncreasingBytes . length )  )  ;  locTestStream . write ( 0 )  ;  locTestStream . flush (  )  ;  mThrown . expect ( IOException . class )  ;  locTestStream . write ( 0 )  ;  locTestStream . flush (  )  ;  }
void function ( short arg0 )  { ensureCapacity ( 2 )  ;  mBuffer [ mWriter . position (  )  ]  =  ( byte )  ( arg0  >  >  8 )  ;  mBuffer [ mWriter . position (  )  + 1 ]  =  ( byte )  ( arg0 & 0xFF )  ;  mWriter . position ( mWriter . position (  )  + 2 )  ;  }
void function ( InodeFile arg0 )  { TtlBucket loc0 = getBucketContaining ( arg0 )  ;  if  ( loc0 != null )  { loc0 . removeFile ( arg0 )  ;  } }
String function (  )  { String loc0 = noRun ;  return loc0 ;  }
List < Inode < ? >  >  function ( PermissionChecker arg0 ,  SomeClass arg1 ,  String arg2 )  { if  ( arg0 . mPermissionCheckEnabled )  { String loc0 = arg0 . getClientUser (  )  ;  List < String >  loc1 = arg0 . getGroups ( loc0 )  ;  List < Inode < ? >  >  loc2 = arg1 . getInodeList (  )  ;  arg0 . checkInodeList ( loc0 ,  loc1 ,  Mode . Bits . WRITE ,  arg1 . getPath (  )  ,  loc2 ,  false )  ;  return loc2 ;  } else { return arg1 . getInodeList (  )  ;  } }
String function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 ,  String arg4 )  { String query = "DELETE WHERE {%s}" ;  String triples = arg4 ;  String sparqlQuery = String . format ( query ,  triples )  ;  Endpoint loc0 = new Endpoint (  )  ;  String result = loc0 . sparql ( sparqlQuery )  ;  return result ;  }
void function (  )  { mThrown . expect ( LineageNotFoundException . class )  ;  mThrown . expectMessage ( "Lineage not found" )  ;  long loc0 = 123 ;  // replace with desired lineage ID try { mLineageStore . deleteLineage ( loc0 )  ;  } catch  ( LineageNotFoundException loc1 )  { } }
public boolean function (  )  { return streaming && fd . valid (  )  ;  } Note: I assumed that the "fd" variable represents a valid file descriptor for the socket and that the "valid (  ) " method checks whether the file descriptor is valid or not .  If this is not the case ,  you may need to adjust the implementation of the "function" method accordingly . 
public String function (  )  { String loc0 = "" ;  try { CString handlerName = new CString (  )  ;  handlerName . setValue ( this . handlerName )  ;  loc0 = handlerName . getValue (  )  ;  } catch  ( Exception e )  { } return loc0 ;  }
void function ( SshDisconnectedEvent arg0 )  { connected = false ;  System . out . println ( "Disconnected from host: " + arg0 . getHost (  )  )  ;  }
public long function ( RMMessage message )  { try { return message . getMessageNumber (  )  ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } return -1 ;  }
import java . util . Collections ;  import java . util . List ;  public class CertConstraintsJaxBUtils { public List < String >  function ( CertificateConstraintsType arg0 )  { if  ( arg0 != null && arg0 . isSetIssuerDNConstraints (  )  )  { IssuerDNConstraintsType loc0 = arg0 . getIssuerDNConstraints (  )  ;  if  ( loc0 != null && loc0 . getRegularExpression (  )  != null )  { return loc0 . getRegularExpression (  )  . getValue (  )  ;  } } return Collections . emptyList (  )  ;  } }
public void function ( List < String >  arg0 )  { try { this . registeredAudiences = new LinkedList < String >  ( arg0 )  ;  } catch  ( Exception e )  { } }
public Script function ( byte [  ]  arg0 ,  List < ECKey >  arg1 ,  int arg2 )  { ArrayList < byte [  ]  >  loc0 = new ArrayList <  >  (  )  ;  for  ( ECKey key : arg1 )  { loc0 . add ( key . getPubKey (  )  )  ;  } byte [  ]  loc1 = TransactionSignature . encodeToBitcoin ( arg0 ,  Transaction . SigHash . ALL ,  false )  ;  List < byte [  ]  >  loc2 = new ArrayList <  >  (  )  ;  loc2 . add ( loc1 )  ;  byte [  ]  loc3 = createMultiSigInputScriptBytes ( loc2 )  ;  return new ScriptBuilder (  )  . smallNum ( arg1 . size (  )  )   . addAllPubKeys ( loc0 )   . smallNum ( arg2 )   . op ( OP_CHECKMULTISIG )   . build (  )  ;  }
class UnsignedInts { private static final long INT_MASK = 0xffffffffL ;  static long function ( int arg0 )  { try { long loc0 = arg0 & INT_MASK ;  return loc0 ;  } catch  ( Exception e )  { } return 0 ;  } }
public FileDescriptor function (  )  { return fd ;  }
Site function ( String arg0 )  { log . debug ( "Getting site with id: {}" ,  arg0 )  ;  Site loc0 = siteRepository . findByHost ( arg0 )  ;  return loc0 ;  }
public static ByteBuffer function ( int arg0 ,  int arg1 )  { try { byte [  ]  loc0 = BufferUtils . getIncreasingByteArray ( arg1 ,  arg0 )  ;  return ByteBuffer . wrap ( loc0 )  ;  } catch  ( Exception e )  { } }
void function (  )  { empty = new TTMParser (  )  ;  empty . setStatus ( "A" )  ;  assertTrue ( empty . toString (  )  . contains ( "Status=A" )  )  ;  }
public static boolean function ( String arg0 )  { boolean loc0 = false ;  if  ( arg0 != null && arg0 . length (  )   > = 2 )  { char loc1 = arg0 . charAt ( 0 )  ;  char loc2 = arg0 . charAt ( 1 )  ;  loc0 =  ( loc2 == ':' &&  ( loc1  > = 'a' && loc1  < = 'z' || loc1  > = 'A' && loc1  < = 'Z' )  )  ;  } return loc0 ;  }
void function ( final D1Submatrix64F arg0 ,  final D1Submatrix64F arg1 ,  final double gamma )  { final int blockLength = arg0 . col1 - arg0 . col0 ;  final double [  ]  u = new double [ blockLength ]  ;  final double [  ]  y = new double [ blockLength ]  ;  final double beta = 1 . 0 / BlockHouseHolder . innerProdRow ( blockLength ,  arg0 ,  arg0 . row0 ,  arg0 ,  arg0 . row0 ,  arg0 . row0 - arg0 . row1 - 1 )  ;  final double yTu = BlockHouseHolder . innerProdRow ( blockLength ,  arg0 ,  arg0 . row0 ,  arg1 ,  arg0 . row0 ,  0 )  ;  for  ( int i = 0 ;  i  <  blockLength ;  i ++  )  { u [ i ]  = arg0 . get ( arg0 . row0 - i ,  i )  ;  y [ i ]  = arg1 . get ( arg0 . row0 ,  i )  - beta * yTu * u [ i ]  ;  } for  ( int i = 0 ;  i  <  blockLength ;  i ++  )  { double loc0 = 0 . 0 ;  for  ( int j = 0 ;  j  <  blockLength ;  j ++  )  { loc0 += u [ j ]  * y [ j ]  ;  } loc0 *= 0 . 5 * gamma ;  for  ( int j = 0 ;  j  <  blockLength ;  j ++  )  { arg1 . set ( arg0 . row0 ,  j ,  y [ j ]  - loc0 * u [ j ]  )  ;  } } }
String function ( String arg0 )  { String loc0 = arg0 . replaceAll ( "\\? . *" ,  "" )  ;  try { loc0 = loc0 . replaceFirst ( ":\\d{1 , 5}" ,  "" )  ;  } catch  ( Exception e )  { } return loc0 ;  }
int function ( OthelloBoard arg0 )  { BitSet loc0 =  ( BitSet )  arg0 . taken . clone (  )  ;  loc0 . andNot ( arg0 . black )  ;  return loc0 . cardinality (  )  ;  }
public BookPreview function ( UUID arg0 )  { for  ( BookPreview loc0 : data )  { if  ( loc0 . getUUID (  )  . equals ( arg0 )  )  { return loc0 ;  } } return null ;  }
int function ( BinaryMinHeap heap )  { int loc0 = heap . size (  )  ;  return loc0 ;  } Note: Since there is no information about the return type or the exception handling requirements of the calling code ,  the return type and exception handling have been omitted from this function .  The function simply takes a BinaryMinHeap object as an argument ,  calls the "size (  ) " method of the object to check whether the heap is empty or not ,  and returns the size of the heap . 
public DagEngine function ( String arg0 ,  String arg1 )  { DagEngine loc0 = null ;  try { loc0 = new DagEngineService (  )  . getDagEngine ( arg0 ,  arg1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } return loc0 ;  }
void function (  )  { String loc0 = "" ;  ResourceLoader loc1 = new ResourceLoader (  )  ;  InputStream loc2 = null ;  InputStream loc3 = loc1 . getResourceStream ( loc0 )  ;  Assert . assertNotNull ( loc3 )  ;  System . out . println ( "Test of getResourceStream method ,  of class ResourceLoader . " )  ;  }
void function ( Iterable < ? extends T >  arg0 )  { offerAll ( arg0 . iterator (  )  )  ;  }
public static ProjectValidation function (  )  { try { return new ProjectValidation (  )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Failed to create an instance of ProjectValidation: " + loc0 . getMessage (  )  )  ;  return null ;  } }
boolean function ( Map < String ,  String >  arg0 ,  String arg1 ,  String arg2 )  { if  ( arg0 == null || arg1 . isEmpty (  )  || arg2 . isEmpty (  )  )  { return false ;  } arg0 . put ( arg1 ,  arg2 )  ;  return true ;  }
Object function ( Object arg0 ,  Object arg1 )  { Object loc0 = arg0 != null ? arg0 : arg1 ;  Object loc1 = loc0 != null ? loc0 : null ;  return loc1 ;  }
String function (  )  { String loc0 = this . csr ;  return loc0 ;  }
public static void function ( String arg0 ,  Throwable arg1 )  { if  ( URLogs . issIsLogEnabled (  )  )  { String loc0 = URLogs . getContent ( URLogs . getCurrentStackTraceElement (  )  )  ;  String loc1 = arg1 . getMessage (  )  ;  arg1 . printStackTrace (  )  ;  Log . e ( URLogs . getsApplicationTag (  )  ,  String . format ( URLogs . TAG_CONTENT_PRINT ,  loc0 ,  loc1 )  )  ;  } }
Set < String >  function (  )  { try { return this . recentlyGrantedPermissions ;  } catch  ( Exception e )  { return new HashSet <  >  (  )  ;  } }
boolean function ( Fiat arg0 ,  Fiat arg1 )  { return arg0 . compareTo ( arg1 )   <  0 ;  }
public void function ( AuthenticationRequest instance ,  String type )  { try { instance . setType ( type )  ;  } catch  ( Exception e )  { } }
String function ( String arg0 )  { try { String loc0 = CacheUtil . md5sum ( arg0 )  ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
void function ( BufferedByteWriter writer ,  int value )  { writer . ensureCapacity ( 4 )  ;  writer . putInt ( Integer . reverseBytes ( value )  )  ;  }
public String function ( Object arg0 ,  Object arg1 )  { String result = "" ;  Object facade =  (  ( NotationUtilityJava )  arg0 )  . getFacade (  )  ;  if  (  (  ( NotationUtilityJava )  arg0 )  . isAAttribute ( facade )  )  { if  (  (  ( NotationUtilityJava )  arg0 )  . isReadOnly ( facade )  )  { result = "final " ;  } } else if  (  (  ( NotationUtilityJava )  arg0 )  . isAOperation ( facade )  )  { if  (  (  ( NotationUtilityJava )  arg0 )  . isLeaf ( facade )  )  { result = "final " ;  } } return result ;  }
public DenseMatrix64F function (  )  { SingularValueDecomposition < DenseMatrix64F >  loc0 = this . svd ;  int loc1 = loc0 . numberOfSingularValues (  )  ;  DenseMatrix64F loc2 = new DenseMatrix64F ( loc1 ,  loc1 )  ;  for  ( int i = 0 ;  i  <  loc1 ;  i ++  )  { double loc3 = loc0 . getSingularValue ( i )  ;  loc2 . set ( i ,  i ,  loc3 )  ;  } return loc2 ;  }
public static OpenIDClaimMapper function (  )  { if ( instance == null )  { synchronized ( OpenIDClaimMapper . class )  { if ( instance == null )  { loc0 = new OpenIDClaimMapper (  )  ;  loc0 . process ( OPENID_CLAIM_MAPPER_FILE_PATH )  ;  instance = loc0 ;  } } } return instance ;  }
public void function ( Hessian2Input arg0 )  { if  ( arg0 != null )  { arg0 . resetReferences (  )  ;  _freeHessian2Input . free ( arg0 )  ;  } }
public static void function ( String [  ]  arg0 )  { try { SshExample loc0 = new SshExample (  )  ;  loc0 . connected ( new SshConnectedEvent (  )  )  ;  loc0 . disconnected ( new SshDisconnectedEvent (  )  )  ;  loc0 . dataReceived ( new SshDataReceivedEvent (  )  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Main method for SshExample: " + loc1 . getMessage (  )  )  ;  } }
String [  ]  function ( String arg0 )  { String cleanPost = arg0 . replaceAll ( "\\p{Punct}" ,  "" )  ;  String [  ]  cleanPostTokens = cleanPost . split ( "\\s+" )  ;  List < String >  tempList = new ArrayList <  >  ( Arrays . asList ( cleanPostTokens )  )  ;  tempList . removeIf ( loc0 - >  loc0 . startsWith ( " < ! -- " )  || loc0 . startsWith ( " < summary > " )  || loc0 . startsWith ( " < /summary > " )  )  ;  cleanPostTokens = tempList . toArray ( new String [ 0 ]  )  ;  return cleanPostTokens ;  }
Abstraction function (  )  { Abstraction loc0 = abstraction ;  while  ( loc0 != null && !loc0 . isAbstractionActiveAtStmt ( sinkStmt )  )  { loc0 = loc0 . getPreviousAbstraction (  )  ;  } return loc0 ;  }
public long function ( TtlBucket arg0 ,  TtlBucket arg1 )  { long loc0 = arg0 . getTtlIntervalStartTimeMs (  )  ;  long loc1 = arg1 . getTtlIntervalStartTimeMs (  )  ;  return Long . compare ( loc0 ,  loc1 )  ;  }
public Document function ( InputStream arg0 ,  LuceneDocumentMetadata arg1 ,  boolean arg2 ,  boolean arg3 )  { TikaLuceneContentExtractor extractor = new TikaLuceneContentExtractor (  )  ;  LuceneDocumentMetadata loc0 = arg1 != null ? arg1 : extractor . defaultDocumentMetadata ;  return extractor . extractAll ( arg0 ,  loc0 ,  arg2 ,  arg3 )  ;  } This method uses the TikaLuceneContentExtractor class to extract the content and metadata from the given input stream  ( arg0 )  ,  along with the provided LuceneDocumentMetadata  ( arg1 )  .  It also allows for the option to extract content and/or metadata depending on the boolean values of arg2 and arg3 .  If no LuceneDocumentMetadata is provided ,  the method uses the default metadata from the TikaLuceneContentExtractor class .  The method returns the Document object that contains the extracted content and metadata . 
List < T >  function (  )  { try { Arrays . sort ( buffer ,  0 ,  bufferSize ,  comparator )  ;  int limit = Math . min ( bufferSize ,  k )  ;  T [  ]  topElements = Arrays . copyOf ( buffer ,  limit )  ;  Arrays . fill ( buffer ,  0 ,  limit ,  null )  ;  bufferSize = 0 ;  return Collections . unmodifiableList ( Arrays . asList ( topElements )  )  ;  } catch  ( Exception e )  { throw new IllegalStateException ( "Failed to retrieve top elements" ,  e )  ;  } }
void function (  )  { ZDAParser loc0 = new ZDAParser (  )  ;  loc0 . parse ( EXAMPLE )  ;  Date loc1 = loc0 . getTime (  )  ;  assertNotNull ( loc1 )  ;  assertEquals ( "03:29:15" ,  new SimpleDateFormat ( "HH:mm:ss" )  . format ( loc1 )  )  ;  }
void function (  )  { try { int loc0 = cal . get ( Calendar . DAY_OF_MONTH )  ;  int loc1 = instance . getDay (  )  ;  assertEquals ( loc0 ,  loc1 )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  } }
void function (  )  { LanguageVersion loc0 = LanguageRegistry . findLanguageVersionByTerseName ( terseName ,  version )  ;  assertEquals ( expected ,  loc0 )  ;  }
String function ( String arg0 )  { String loc0 = escape ( arg0 )  ;  loc0 = loc0 . replace ( "*" ,  " . *" )  ;  loc0 = loc0 . replace ( "?" ,  " . " )  ;  return loc0 ;  }
public void function ( BigDecimal arg0 )  { try { BigDecimal loc0 = arg0 . setScale ( 2 ,  RoundingMode . HALF_UP )  ;  this . expDataUnitId = loc0 ;  } catch  ( NullPointerException | ArithmeticException ex )  { } }
OperationMetric function ( OperationMetricKey arg0 ,  ASTMethodOrConstructorDeclaration arg1 )  { return calculator . get ( arg0 ,  arg1 )  ;  }
void function (  )  { GSVTest gsvTest = new GSVTest (  )  ;  gsvTest . setUp (  )  ;  GSVParser parser = new GSVParser (  )  ;  parser . parse ( EXAMPLE )  ;  int loc0 = parser . getSentenceIndex (  )  ;  assertEquals ( 2 ,  loc0 )  ;  }
SiteUrl function ( String arg0 ,  String arg1 ,  String arg2 ,  String arg3 )  { SiteUrl loc0 = new SiteUrl ( arg0 ,  arg1 ,  arg2 ,  arg3 )  ;  log . debug ( "Creating new SiteUrl instance: {}" ,  loc0 )  ;  return siteUrlRepository . save ( loc0 )  ;  }
DataServerMessage function (  )  { DataServerMessage loc0 = new DataServerMessage (  )  ;  DataServerMessage loc1 = new DataServerMessage ( false ,  RPCMessage . Type . RPC_BLOCK_REQUEST )  ;  ByteBuffer loc2 = ByteBuffer . allocate ( HEADER_PREFIX_LENGTH )  ;  return loc0 ;  }
public boolean function (  )  { boolean loc0 = getEntityManager (  )  . getTransaction (  )  . isActive (  )  ;  return loc0 ;  }
void function (  )  { try { TTMParser loc0 = new TTMParser (  )  ;  loc0 . parse ( EXAMPLE )  ;  double loc1 = 0 . 0 ;  assertEquals ( loc1 ,  loc0 . getTimeToCPA (  )  ,  0 . 01 )  ;  } catch  ( Exception e )  { fail ( "Exception thrown: " + e . getMessage (  )  )  ;  } }
void function ( SshDisconnectedEvent arg0 )  { connected = false ;  System . out . println ( "Disconnected from host " + arg0 . getHost (  )  )  ;  }
String function (  )  { String loc0 = this . value ;  return loc0 ;  }
public boolean function (  )  { boolean loc0 = idx . next (  )  ;  if  ( loc0 )  { Constant loc1 = idx . getVal ( "indexColumnName" )  ;  ts . moveToRid ( idx . getDataRid (  )  )  ;  return true ;  } else { ts . close (  )  ;  return false ;  } } Note: Replace "indexColumnName" with the actual name of the column in the index . 
void function (  )  { before (  )  ;  mBlockStream . seekInternal ( mEOFBlockStream ,   ( int )  BLOCK_LENGTH )  ;  after (  )  ;  }
void function (  )  { try { loc0 = 6 ;  // Example value for the month argument instance . setMonth ( loc0 )  ;  } catch  ( IllegalArgumentException e )  { fail ( "Unexpected exception: " + e . getMessage (  )  )  ;  } }
String function ( Set < String >  arg0 ,  FitnessFunction arg1 ,  int arg2 )  { GeneticAlgorithm geneticAlgorithm = new GeneticAlgorithm (  )  ;  geneticAlgorithm . validatePopulation ( arg0 )  ;  geneticAlgorithm . clearInstrumentation (  )  ;  geneticAlgorithm . setPopulationSize ( GeneticAlgorithm . POPULATION_SIZE )  ;  return geneticAlgorithm . ga ( arg0 ,  arg1 )  ;  }
public RPPA function (  )  { return arg1 ;  } Note: This method simply returns the RPPA value stored in the member variable "rppaValue" .  It does not perform any computation or modification to the value . 
void function ( QName arg0 )  { path . addLast ( attributes . get ( arg0 )  )  ;  path . getLast (  )  . type = XPathContext . ATTRIBUTE ;  }
EncryptionProperties function (  )  { EncryptionProperties loc0 = new EncryptionProperties (  )  ;  loc0 . setEncryptionKey ( arg0 )  ;  loc0 . setSignatureKey ( arg1 )  ;  return loc0 ;  }
AccessToken function ( List < String >  arg0 ,  Mode arg1 ,  String arg2 )  { try { JSONObject sharedTestUser = findOrCreateSharedTestAccount ( arg0 ,  arg1 ,  arg2 )  ;  return getAccessTokenForUser ( arg0 ,  Mode . SHARED ,  sharedTestUser . getString ( "id" )  )  ;  } catch  ( Exception e )  { System . out . println ( "Exception occurred: " + e . getMessage (  )  )  ;  return null ;  } }
public static void function (  @ Nullable Closeable arg0 ,  boolean arg1 )  { if  ( arg0 == null )  { return ;  } try { arg0 . close (  )  ;  } catch  ( IOException loc0 )  { if  ( arg1 )  { logger . log ( Level . WARNING ,  "IOException thrown while closing Closeable resource" ,  loc0 )  ;  } else { throw new RuntimeException ( loc0 )  ;  } } }
void function ( final String arg0 ,  final String arg1 )  { try { properties . setProperty ( arg0 ,  arg1 )  ;  logger . debug ( "Setter for property '{}' called with value '{}'" ,  arg0 ,  arg1 )  ;  } catch  ( Exception loc0 )  { logger . error ( "Error setting property '{}'" ,  arg0 ,  loc0 )  ;  } }
public class RSSFeed { String _title ,  _image ,  _description ,  _language ,  _link ,  _rss_link ;  List < RSSItem >  _items ;  String function (  )  { String loc0 = "" ;  try { loc0 = getLink (  )  ;  } catch  ( Exception e )  { } String loc1 = "" ;  try { loc1 = getLanguage (  )  ;  } catch  ( Exception e )  { } String loc2 = "" ;  try { loc2 = getTitle (  )  ;  } catch  ( Exception e )  { } String loc3 = "" ;  try { loc3 = get_image (  )  ;  } catch  ( Exception e )  { } String loc4 = "" ;  try { loc4 = getDescription (  )  ;  } catch  ( Exception e )  { } String loc5 = "" ;  try { loc5 = getRSSLink (  )  ;  } catch  ( Exception e )  { } return loc0 + loc1 + loc2 + loc3 + loc4 + loc5 ;  } String getLink (  )  { return _link ;  } String getLanguage (  )  { return _language ;  } String getTitle (  )  { return _title ;  } void setItems ( List < RSSItem >  items )  { _items = items ;  } String get_image (  )  { return _image ;  } String getDescription (  )  { return _description ;  } String getRSSLink (  )  { return _rss_link ;  } void set_image ( String _image )  { this . _image = _image ;  } }
public void function ( ItemStack itemStack )  { if  ( isFull (  )  )  return ;  int amount = itemStack . getAmount (  )  ;  Item item = itemStack . getItem (  )  ;  int maxAmount = limit - count ;  int toAdd = Math . min ( amount ,  maxAmount )  ;  count += toAdd ;  if  ( invMap . containsKey ( item )  )  { invMap . put ( item ,  invMap . get ( item )  + toAdd )  ;  } else { invMap . put ( item ,  toAdd )  ;  } }
void function (  )  { Date arg0 = new Date (  )  ;  Date arg1 = new Date (  )  ;  assertEquals ( arg0 ,  arg1 )  ;  }
public Integer function (  )  { Integer loc0 = null ;  try { if  ( !vstack . empty (  )  )  { loc0 = vstack . peek (  )  . intValue (  )  ;  } else { throw new Exception ( "Stack is empty . " )  ;  } } catch  ( Exception e )  { System . err . println ( e . getMessage (  )  )  ;  } return loc0 ;  }
String function ( String arg0 )  { try { int loc0 = arg0 . lastIndexOf ( '/' )  ;  return loc0  > = 0 ? arg0 . substring ( 0 ,  loc0 )  : "" ;  } catch  ( Exception e )  { return "" ;  } }
void function (  )  { SetAttributeOptions loc0 = SetAttributeOptions . defaults (  )  ;  Assert . assertNull ( loc0 . owner (  )  )  ;  Assert . assertNull ( loc0 . group (  )  )  ;  Assert . assertNull ( loc0 . mode (  )  )  ;  Assert . assertNull ( loc0 . content (  )  )  ;  }
public int function ( int arg0 ,  int arg1 ,  int arg2 ,  int arg3 )  { int loc0 = arg0 ;  if  ( hasHardenedBit ( arg0 )  )  { throw new IllegalArgumentException ( "Can't derive a hardend child from a hardend child . " )  ;  } loc0 |=  ( arg3 & HARDENED_BIT )  ;  loc0 &= ~HARDENED_BIT ;  loc0 =  ( loc0  <  <  24 )  |  ( arg1  <  <  16 )  |  ( arg2  <  <  8 )  | arg3 ;  return loc0 ;  }
public static void function ( AbstractConfigurableProvider obj ,  List < String >  arg0 )  { try { obj . setProduceMediaTypes ( arg0 )  ;  } catch  ( Exception loc0 )  { LOG . log ( Level . WARNING ,  "Error setting custom produce media types" ,  loc0 )  ;  } }
boolean function ( String arg0 )  { return !arg0 . isEmpty (  )  ;  }
void function (  )  { Mockito . when ( mClient . listObjectsV2 ( Matchers . any ( ListObjectsV2Request . class )  )  )   . thenThrow ( AmazonClientException . class )  ;  try { mS3UnderFileSystem . delete ( PATH ,  false )  ;  Assert . assertFalse ( "Delete method should not have been called . " ,  false )  ;  } catch  ( Exception e )  { System . out . println ( "Exception caught: " + e . getMessage (  )  )  ;  } }
void function ( int arg0 )  { requestedCameraId = arg0 ;  }
List < ByteBuffer >  function ( List < ByteBuffer >  arg0 )  { int loc0 = arg0 . size (  )  ;  List < ByteBuffer >  loc1 = new ArrayList <  >  ( loc0 )  ;  for  ( int loc2 = 0 ;  loc2  <  loc0 ;  loc2 ++  )  { loc1 . add ( cloneByteBuffer ( arg0 . get ( loc2 )  )  )  ;  } return loc1 ;  }
String function ( GameRequestContent arg0 )  { String loc0 = null ;  try { loc0 = arg0 . getTitle (  )  ;  } catch  ( NullPointerException e )  { } return loc0 ;  }
void function ( VertexLabelType arg0 ,  VertexLabelType arg1 ,  EdgeLabelType arg2 )  { Hashtable < VertexLabelType ,  EdgeLabelType >  loc0 = globalEdgeLookup . get ( arg0 )  ;  if  ( loc0 == null )  { loc0 = checkForNewVertex ( arg0 )  ;  } loc0 . put ( arg1 ,  arg2 )  ;  }
public static WritableMap function (  @ Nullable String arg0 ,   @ Nullable String arg1 )  { WritableMap loc0 = Arguments . createMap (  )  ;  try { loc0 . putString ( "key" ,  arg0 )  ;  loc0 . putString ( "errorMessage" ,  arg1 )  ;  } catch  ( Exception e )  { WritableMap loc1 = AsyncStorageErrorUtil . getDBError ( null )  ;  loc1 . putString ( "message" ,  e . getMessage (  )  )  ;  return loc1 ;  } return loc0 ;  }
List < String >  function (  )  { List < String >  loggers = new ArrayList <  >  (  )  ;  try { for  ( String loggerName : LOGGER_NAMES )  { loggers . add ( loggerName )  ;  } } catch  ( Exception e )  { } return loggers ;  }
void function ( JobsGroup arg0 ,  Context arg1 )  { JobsGroup loc0 = null ;  synchronized ( this )  { loc0 = this . jobs . put ( arg0 . getId (  )  ,  arg0 )  ;  } if  ( loc0 != null )  { this . groupFinished ( loc0 ,  arg1 )  ;  } this . finishRunningJobs ( arg1 )  ;  this . controller . run (  )  ;  }
public int function ( int arg0 ,  int arg1 )  { int loc0 = arg0 / arg1 ;  try { if  ( loc0  <  0 )  { throw new IllegalArgumentException ( "Invalid arguments for pagination" )  ;  } } catch  ( IllegalArgumentException e )  { System . err . println ( e . getMessage (  )  )  ;  loc0 = 0 ;  } return loc0 ;  }
public void function ( UriPrefixPair [  ]  arg0 )  { try { this . packagePrefixes = arg0 ;  } catch  ( Exception loc0 )  { loc0 . printStackTrace (  )  ;  } }
public void function ( long arg0 )  { try { long loc0 = arg0 ;  setSeqId ( loc0 )  ;  } catch  ( Exception e )  { } }
String function ( ProfileData arg0 ,  ArrayList < String >  arg1 ,  ArrayList < String >  arg2 )  { ProfileData loc0 = new ProfileData (  )  ;  HashMap < String ,  String >  loc1 = new HashMap < String ,  String >  (  )  ;  ArrayList < ProfileData >  loc2 = new ArrayList < ProfileData >  (  )  ;  ArrayList < String >  loc3 = new ArrayList < String >  (  )  ;  ArrayList < String >  loc4 = new ArrayList < String >  (  )  ;  createUnion ( arg0 ,  arg1 ,  arg2 )  ;  mergeProfiles ( loc1 ,  loc2 ,  loc3 ,  loc4 )  ;  for  ( String loc5 : loc1 . keySet (  )  )  { String loc6 = loc1 . get ( loc5 )  ;  String [  ]  loc7 = loc6 . split ( VALUE_SEPARATOR )  ;  String loc8 = createKey ( loc7 [ 0 ]  ,  loc7 [ 1 ]  )  ;  loc0 . put ( loc8 ,  loc6 )  ;  } return loc0 ;  }
public static void function ( DenseMatrix64F arg0 ,  DenseMatrix64F arg1 ,  double arg2 )  { DenseMatrix64F Q = new DenseMatrix64F ( arg1 . numRows ,  arg1 . numRows )  ;  DenseMatrix64F u = arg0 ;  CommonOps . identity ( Q )  ;  if  ( !MatrixFeatures . isVector ( u )  )  { throw new IllegalArgumentException ( "u must be a vector" )  ;  } CommonOps . multAddTransB ( -arg2 ,  u ,  u ,  Q )  ;  }
Bits function ( Bits arg0 )  { Bits loc0 = getUMask (  )  . not (  )  ;  Bits loc1 = arg0 . and ( loc0 )  ;  Bits loc2 = getOtherBits (  )  . and ( loc0 )  ;  Bits loc3 = getOwnerBits (  )  . or ( loc1 )  ;  Bits loc4 = getGroupBits (  )  . or ( loc2 )  ;  return new Mode ( loc3 ,  loc4 ,  SVALS ,  loc1 )  ;  }
public static Waypoint function ( double arg0 ,  double arg1 )  { try { double loc0 = arg0 ;  double loc1 = arg1 ;  return new Waypoint ( new Position ( loc0 ,  loc1 )  )  ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return null ;  } }
void function ( RegPCLTestResultDetailsEntityPK obj ,  long arg0 )  { obj . setTestId ( arg0 )  ;  }
void function ( boolean arg0 ,  BlockMatrix64F arg1 )  { boolean saveW = arg0 ;  BlockMatrix64F dataWTA = arg1 ;  D1Submatrix64F loc0 = new D1Submatrix64F (  )  ;  D1Submatrix64F loc1 = new D1Submatrix64F (  )  ;  D1Submatrix64F loc2 = new D1Submatrix64F ( dataWTA )  ;  double [  ]  loc3 = new double [ 1 ]  ;  double [  ]  loc4 = new double [ 1 ]  ;  BlockMatrix64F dataW = new BlockMatrix64F ( 1 ,  1 )  ;  int blockLength = 0 ;  D1Submatrix64F loc5 = new D1Submatrix64F ( dataW )  ;  BlockMatrix64F dataA = null ;  saveW = arg0 ;  dataWTA = arg1 ;  }
void function ( final ProtocolHandler arg0 )  { try { this . m_readHandler . setProtocolHandler ( arg0 )  ;  } catch  ( Exception loc0 )  { } }
byte [  ]  function (  )  { boolean loc0 = isRaw (  )  ;  format . checkType ( 'B' ,  loc0 )  ;  int loc1 = getByteArrayLength (  )  ;  byte [  ]  loc2 = new byte [ loc1 ]  ;  getByteArrayInternal ( loc1 ,  loc2 ,  0 ,  loc1 )  ;  return loc2 ;  }
public void function (  )  { LogoutRequestSender loc0 = LogoutRequestSender . getInstance (  )  ;  loc0 . sendLogoutRequests ( new SingleLogoutRequestDTO [  ] {arg0 ,  arg1} )  ;  } Note: The code assumes that SingleLogoutRequestDTO objects arg0 and arg1 have already been instantiated and initialized elsewhere in the code . 
int function (  )  { try { int loc0 = this . num ;  return loc0 ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return 0 ;  // or any other value to indicate an error } }
String function (  )  { String loc0 = mUri . getPath (  )  ;  try { loc0 = loc0 . substring ( loc0 . lastIndexOf ( AlluxioURI . SEPARATOR )  + 1 )  ;  } catch  ( IndexOutOfBoundsException e )  { } catch  ( NullPointerException e )  { loc0 = "" ;  } return loc0 ;  }
public void function ( XKMSRequestAbstractType arg0 ,  XKMSResponseAbstractType arg1 )  { try { String loc0 = arg0 . getRequestId (  )  ;  arg1 . setRequestId ( loc0 )  ;  String loc1 = arg1 . getId (  )  ;  arg1 . setId ( loc1 )  ;  } catch  ( Exception e )  { } }
Object function ( Object arg0 ,  Object arg1 )  { try { if  ( arg0 instanceof JSObject && arg1 instanceof JSObject )  { JSObject jsObj0 =  ( JSObject )  arg0 ;  JSObject jsObj1 =  ( JSObject )  arg1 ;  if  ( jsObj0 . equals ( jsObj1 )  )  { return "undefined" ;  } } } catch  ( Exception e )  { } return null ;  }
void function (  )  { Page loc0 = view . getPage (  )  ;  Bitmap loc1 = loc0 . getBitmap (  )  ;  Canvas loc2 = new Canvas ( loc1 )  ;  view . draw ( loc2 ,  loc1 )  ;  view . invalidate (  )  ;  }
void function (  )  { final int arg0 = 1 ;  final double arg1 = 32 . 123456 ;  instance . setLatitude ( arg0 ,  arg1 )  ;  assertTrue ( instance . toString (  )  . contains ( "Latitude=" + arg0 + "°" + arg1 )  )  ;  final String loc0 = "4717 . 11234 , N" ;  instance . parseLatitude ( loc0 )  ;  assertEquals ( arg0 ,  instance . getLatitude (  )  )  ;  assertEquals ( arg1 ,  instance . getLatitudeMinutes (  )  ,  0 . 0001 )  ;  assertEquals ( loc0 ,  instance . getLatDecimalMinutes (  )  )  ;  }
void function ( TextViewUndoRedo arg0 )  { try { arg0 . mTextView . removeTextChangedListener ( arg0 . mChangeListener )  ;  } catch  ( Exception loc0 )  { } }
HighLevelChangeRenaming loc0 =  ( HighLevelChangeRenaming ) arg1 ;  try { if  ( arg0 . containsKey (  ( String ) arg2 )  )  { System . out . println ( "Overwriting high level change  ( renaming )  for identifier " + arg2 )  ;  } arg0 . put (  ( String ) arg2 ,  loc0 )  ;  } catch  ( Exception e )  { System . err . println ( "An error occurred while adding high level change  ( renaming ) : " + e . getMessage (  )  )  ;  }
void function ( String arg0 ,  Bundle arg1 ,  RequestListener arg2 ,  Object arg3 )  { fb . runner . request ( arg0 ,  arg1 ,  null ,  arg2 ,  arg3 )  ;  }
void function ( Rotation arg0 )  { this . rotation = arg0 ;  for ( StateListener loc0 : this . listeners )  { loc0 . onRotationChanged ( this . rotation )  ;  } }
int function ( char [  ]  arg0 ,  char [  ]  arg1 )  { int loc0 = 0 ;  try { while  ( true )  { char c =  ( char )  System . in . read (  )  ;  if  ( arg0 . endChar ( c )  )  { return arg0 . getPeekCount (  )  ;  } if  ( arg0 . addChar ( c )  && !arg0 . hasFreePart (  )  )  { return arg0 . getPeekCount (  )  ;  } } } catch  ( IOException e )  { throw new RuntimeException ( e )  ;  } finally { arg0 . reset (  )  ;  } }
import io . netty . buffer . ByteBuf ;  import io . netty . buffer . Unpooled ;  import org . apache . commons . lang3 . ArrayUtils ;  import java . nio . ByteBuffer ;  public class DataByteBufferTest { private ByteBuffer mBuffer = null ;  private int LENGTH = 5 ;  public void length (  )  { System . out . println ( "Buffer length is: " + mBuffer . capacity (  )  )  ;  } public void readOnlyByteBuffer (  )  { ByteBuffer readOnlyBuffer = mBuffer . asReadOnlyBuffer (  )  ;  System . out . println ( "Read-only buffer created with capacity: " + readOnlyBuffer . capacity (  )  )  ;  } public void nettyOutput (  )  { ByteBuf byteBuf = Unpooled . wrappedBuffer ( mBuffer )  ;  System . out . println ( "ByteBuf created with capacity: " + byteBuf . capacity (  )  )  ;  } private void function (  )  { try { ByteBuffer loc0 = BufferUtils . getIncreasingByteBuffer ( LENGTH )  ;  mBuffer = loc0 ;  System . out . println ( "New ByteBuffer created with capacity: " + mBuffer . capacity (  )  )  ;  } catch  ( Exception loc1 )  { System . out . println ( "Error creating ByteBuffer: " + loc1 . getMessage (  )  )  ;  } } }
void function (  )  { setUp (  )  ;  testAddWaypointId (  )  ;  testSetRouteTypeActive (  )  ;  testSetSentenceIndexWithNegativeValue (  )  ;  testIsActiveRoute (  )  ;  testGetSentenceCount (  )  ;  testSetWaypointIds (  )  ;  testSetRouteId (  )  ;  testGetWaypointIds (  )  ;  testGetRouteId (  )  ;  testSetRouteTypeWorking (  )  ;  testIsLast (  )  ;  testGetWaypointCount (  )  ;  testSetSentenceIndex (  )  ;  testGetSentenceIndex (  )  ;  testConstructor (  )  ;  testSetSentenceCountWithNegativeValue (  )  ;  testIsWorkingRoute (  )  ;  testSetSentenceCount (  )  ;  assertTrue ( rte . isFirst (  )  )  ;  }
public void function ( List < RSSItem >  arg0 )  { try { for  ( RSSItem loc0 : arg0 )  { loc0 . setTitle ( loc0 . getTitle (  )  )  ;  loc0 . setLink ( loc0 . getLink (  )  )  ;  loc0 . setDescription ( loc0 . getDescription (  )  )  ;  loc0 . setPubDate ( loc0 . getPubDate (  )  )  ;  } _items = arg0 ;  } catch  ( Exception e )  { System . out . println ( "Error setting RSSItem properties: " + e . getMessage (  )  )  ;  } }
void function ( long arg0 )  { try { setGeneB ( arg0 )  ;  } catch  ( Exception loc0 )  { System . out . println ( "Error setting Entrez Gene ID for Gene B: " + loc0 . getMessage (  )  )  ;  } }
void function (  )  { mThrown . expect ( ClosedChannelException . class )  ;  ByteBuffer loc0 = getIncreasingByteBuffer ( TEST_BLOCK_SIZE )  ;  mWriter . getChannel (  )  ;  mWriter . append ( loc0 )  ;  mWriter . close (  )  ;  ByteBuffer loc1 = getIncreasingByteBuffer ( TEST_BLOCK_SIZE )  ;  mWriter . append ( loc1 )  ;  mWriter . close (  )  ;  assertEquals ( 2 * TEST_BLOCK_SIZE ,  mFolder . getRoot (  )  . length (  )  )  ;  }
public class BlockIdTest { long MAX_SEQUENCE_NUMBER = 16777215L ;  void function (  )  { long arg0 = 123456L ;  long arg1 = MAX_SEQUENCE_NUMBER ;  BlockId blockId = new BlockId (  )  ;  blockId . createBlockId ( arg0 ,  arg1 )  ;  long loc0 = blockId . getContainerId (  )  ;  long loc1 = blockId . getSequenceNumber (  )  ;  assertEquals ( arg0 ,  loc0 )  ;  assertEquals ( arg1 ,  loc1 )  ;  } void getContainerIdAndSequenceNumber (  )  { } void getMaxSequenceNumber (  )  { } }
void function ( YahooImageSearcher arg0 )  { try { runFullTest ( arg0 )  ;  } catch  ( Exception loc0 )  { LOG . debug ( "Error in function: " + loc0 . getMessage (  )  )  ;  } }
Stmt function ( String fmt ,  Object .  .  .  subst )  { QQ qq = new QQ (  )  ;  Node node = qq . parse ( QQ . STMT ,  fmt ,  subst )  ;  String s = node . toString (  )  . replaceAll ( "/\\* . *?\\*/" ,  "" )  ;  String [  ]  lines = s . split ( "\n" )  ;  List < String >  nonEmptyLines = new ArrayList <  >  (  )  ;  for  ( String line : lines )  { String trimmedLine = line . trim (  )  ;  if  ( !trimmedLine . isEmpty (  )  )  { nonEmptyLines . add ( trimmedLine )  ;  } } return  ( Stmt )  qq . ext . nf (  )  . toArray ( nonEmptyLines . toArray ( new String [ 0 ]  )  )  ;  }
List < String >  function (  )  { return getRedirectUris (  )  ;  }
byte [  ]  function (  )  { try { return this . errors ;  } catch  ( Exception e )  { e . printStackTrace (  )  ;  return new byte [ 0 ]  ;  } }
public int function ( CancerStudy arg0 ,  CancerStudy arg1 )  { String loc0 = arg0 . getName (  )  ;  String loc1 = arg1 . getName (  )  ;  return loc0 . compareTo ( loc1 )  ;  }
public static boolean function ( final String arg0 ,  final String arg1 )  { try { if  ( arg0 . equals ( arg1 )  )  { return true ;  } if  ( !arg0 . startsWith ( " . " )  )  { return false ;  } int dotIndex = arg0 . indexOf ( " . " ,  1 )  ;  if  ( dotIndex == -1 )  { return false ;  } String loc0 = arg0 . substring ( dotIndex )  ;  String loc1 = arg1 ;  if  ( !loc0 . equals ( loc1 )  )  { return false ;  } if  ( arg0 . substring ( 1 ,  dotIndex )  . indexOf ( " . " )  != -1 )  { return false ;  } return true ;  } catch  ( NullPointerException ex )  { return false ;  } catch  ( Exception ex )  { return false ;  } }
public ListIterator < BasicLogRecord >  function (  )  { flush (  )  ;  LogIterator loc0 = new LogIterator (  )  ;  List < BasicLogRecord >  loc1 = new ArrayList < BasicLogRecord >  (  )  ;  while  ( loc0 . hasNext (  )  )  { loc1 . add ( loc0 . next (  )  )  ;  } return loc1 . listIterator ( loc1 . size (  )  )  ;  }
GetOfferDetailsResponse . Return . DetailOfferData . Merchant . Addresses function (  GetOfferDetailsResponse . Return . DetailOfferData loc0 ,  String arg1 ,  String arg2 )  { GetOfferDetailsResponse . Return . DetailOfferData . Merchant merchant = loc0 . getMerchant (  )  ;  if  ( merchant == null )  { return null ;  } GetOfferDetailsResponse . Return . DetailOfferData . Merchant . Addresses addresses = merchant . getAddresses (  )  ;  if  ( addresses == null )  { return null ;  } return addresses ;  }
void function ( String arg0 )  { Block loc0 = filemgr . append ( arg0 )  ;  write ( loc0 )  ;  }
void function ( Node arg0 ,  NodeTest arg1 )  { CountingNodeTester counter = new CountingNodeTester (  )  ;  arg0 . test ( counter ,  arg1 )  ;  counter . noMoreNodes ( arg1 )  ;  }
int function ( int arg0 )  { conflictsNotApproved = arg0 ;  return conflictsNotApproved ;  }
public EdgeLabelType function ( VertexLabelType arg0 ,  VertexLabelType arg1 )  { globalEdgeLookup . get ( arg0 )  . remove ( arg1 )  ;  return globalEdgeLookup . get ( arg0 )  . get ( arg1 )  ;  } Note: This implementation assumes that the edge exists in the graph ,  and does not handle cases where the specified vertices or edge do not exist .  Also ,  it does not modify the vertexLabels list or any other data structures in the LabeledGraph class . 
void function ( EntityLivingBase arg0 ,  double arg1 )  { if  ( mob . getDistanceSq ( arg0 )   >  arg1 * arg1 )  { mob . getNavigator (  )  . tryMoveToEntityLiving ( arg0 ,  1 . 0 )  ;  } }
String function ( String arg0 ,  String arg1 )  { String loc0 = FederationUtils . asLink ( arg0 ,  arg1 ,  null )  ;  String loc1 = retrieveJson ( loc0 )  ;  return loc1 ;  }
boolean function ( CharSequence arg0 ,  int arg1 )  { if  ( arg1  <  0 || arg1  > = arg0 . length (  )  - 1 )  { return false ;  } char loc0 = arg0 . charAt ( arg1 )  ;  if  ( Character . isHighSurrogate ( loc0 )  )  { char loc1 = arg0 . charAt ( arg1 + 1 )  ;  return Character . isLowSurrogate ( loc1 )  ;  } return false ;  }
String function (  )  { String loc0 = null ;  try { loc0 = mAlluxioMaster . getRPCBindHost (  )  ;  } catch  ( Exception loc1 )  { LOG . error ( "Failed to get RPC bind host" ,  loc1 )  ;  } return loc0 ;  }
String function ( Escaper escaper ,  char c )  { String replacement = escaper . escape ( String . valueOf ( c )  )  ;  return escaper . stringOrNull ( replacement . toCharArray (  )  )  ;  }
public void function (  )  { String loc0 = "prefix-bucket" ;  String loc1 = "src" ;  String loc2 = "dst" ;  String loc3 = "path" ;  try { when ( mClient . listObjects ( any ( ListObjectsRequest . class )  )  )   . thenThrow ( ServiceException . class )  ;  doThrow ( ServiceException . class )  . when ( mOSSUnderFileSystem )   . rename ( eq ( loc0 + "/" + loc1 )  ,  eq ( loc0 + "/" + loc2 )  )  ;  assertFalse ( mOSSUnderFileSystem . rename ( loc3 + "/" + loc1 ,  loc3 + "/" + loc2 )  )  ;  } catch  ( ServiceException e )  { fail ( "Unexpected exception " + e )  ;  } }
void function ( int opcode )  { chunks . add ( new ScriptChunk ( opcode ,  null )  )  ;  int size = chunks . size (  )  ;  }
void function (  )  { Configuration . set ( "allocator" ,  GreedyAllocator . class . getName (  )  )  ;  Allocator allocator = Allocator . Factory . create ( mManagerView )  ;  Assert . assertTrue ( allocator instanceof GreedyAllocator )  ;  }
void function ( String arg0 )  { contentEncoding = arg0 ;  } Note: The above code assumes that `contentEncoding` is a member variable of the `RabbitMQMessage` class .  If `contentEncoding` is not a member variable ,  then it should be declared as a local variable inside the `function` method . 
void function ( boolean arg0 )  { if  ( sawReturn || line . length (  )   >  0 )  { if  ( finishLine ( arg0 )  )  { line . setLength ( 0 )  ;  sawReturn = false ;  } } }
void function (  )  { _use_count ++  ;  }
Iterator < Document < O >  >  function (  )  { while  ( true )  { if  ( i  > = documents . length )  { return null ;  } File loc0 = documents [ i ++  ]  ;  if  ( loc0 . isDirectory (  )  )  { documents = loc0 . listFiles ( fileFilter )  ;  i = 0 ;  continue ;  } if  ( !loc0 . exists (  )  )  { continue ;  } return getDocumentsFromDirectory ( loc0 )  ;  } }
Intent function ( Intent arg0 ,  String arg1 )  { try { Intent loc0 = arg0 . getIntent (  )  ;  String loc1 = loc0 . getStringExtra ( INTENT_EXTRA_TRANSACTION_HASH_OLD )  ;  if  ( loc1 != null )  { arg0 . putExtra ( INTENT_EXTRA_TRANSACTION_HASH ,  loc1 )  ;  } else { arg0 . putExtra ( INTENT_EXTRA_TRANSACTION_HASH ,  arg1 )  ;  } } catch  ( Exception e )  { } return arg0 ;  }
Iterator < OrderLineTypeFacade >  function (  )  { Iterator < OrderLineTypeFacade >  loc0 = null ;  try { OrderType loc1 = order ;  List < OrderLineType >  loc2 = loc1 . getOrderLine (  )  ;  loc0 = new ArrayList < OrderLineTypeFacade >  ( loc2 . size (  )  )  . iterator (  )  ;  for  ( OrderLineType loc3 : loc2 )  { loc0 . add ( new OrderLineTypeFacade ( loc3 )  )  ;  } } catch  ( Exception loc4 )  { } return loc0 ;  }
void function ( FolderInfo . CheckedFlag arg0 )  { checkedFlag = arg0 ;  }
void function ( Bundle arg0 )  { Bundle loc0 = new Bundle (  )  ;  getVista (  )  . onSaveInstanceState ( loc0 )  ;  arg0 . putBundle ( "PresenterState" ,  loc0 )  ;  }
String function ( Block arg0 ,  int arg1 )  { sLock ( arg0 )  ;  Buffer loc0 = getBuffer ( arg0 )  ;  return loc0 . getString ( arg1 )  ;  }
BitcoinPacketHeader function ( ByteBuffer arg0 )  { byte [  ]  loc0 = new byte [ BitcoinSerializer . HEADER_LENGTH ]  ;  arg0 . get ( loc0 )  ;  BitcoinPacketHeader loc1 = new BitcoinPacketHeader ( loc0 )  ;  return loc1 ;  }
public void function ( List < Node >  arg0 ,  RuleContext arg1 ,  Language arg2 ,  Rule rule )  { RuleChainVisitor loc0 = languageToRuleChainVisitor . get ( arg2 )  ;  loc0 . add ( rule )  ;  }
void function (  )  { EventAction action = new EventAction (  )  ;  action . function (  )  ;  action . trigger ( null )  ;  }
ASTElement function ( String arg0 ,  String arg1 ,  String arg2 )  { ASTElement loc0 = element ( arg0 )  ;  tagList . openTag ( loc0 )  ;  ASTElement loc1 = element ( arg1 )  ;  tagList . openTag ( loc1 )  ;  ASTElement loc2 = element ( arg1 )  ;  tagList . openTag ( loc2 )  ;  tagList . closeTag ( loc2 )  ;  tagList . closeTag ( loc1 )  ;  tagList . closeTag ( loc0 )  ;  assertFalse ( tagList . isOpen ( loc0 )  )  ;  assertTrue ( tagList . isEmpty (  )  )  ;  return loc2 ;  }
